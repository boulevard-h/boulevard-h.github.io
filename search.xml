<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HelloWorld &amp; 建站教程</title>
      <link href="/2024/10/12/HelloWorld&amp;%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"/>
      <url>/2024/10/12/HelloWorld&amp;%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1. 简要介绍"></a>1. 简要介绍</h2><p><a href="https://hexo.nodejs.cn/">hexo</a> 是一个强大的博客框架项目，将 Markdown 文档转化为博客网站，并且拥有大量自定义主题模板可以使用。在安装了 hexo 以后，只需要在 hexo 博客目录下简单的执行一行 <code>hexo server</code> 命令即可生成网站，并且在本地的 4000 端口访问它。</p><p>因此，本教程的重点不是如何安装和使用 hexo，而是如何把你的 hexo 页面部署在网站上。</p><p>GitHub Pages 就是一个不错的部署平台，hexo 官方支持 GitHub 一键部署，可以直接将生成的网页文件推送到 GitHub Pages 对应的仓库中去。</p><p>但是 GitHub Pages 也有一些缺点：</p><ol><li>国内访问速度慢（emmm</li><li>源码和静态网站分离，也就是说，被我们 push 到 GitHub 仓库中的只有静态网站，而没有你的 hexo 目录</li></ol><p>第二个问题可以使用 GitHub Actions 解决。使用两个仓库（或者一个仓库的两个分支也可），一个存储 hexo 源码，一个存储静态网站。然后在 hexo 源码仓库中写一个 actions 脚本，当推送新内容的时候，自动运行 hexo 生成静态网站并且推送到另一个仓库。</p><p>而更好的方法是使用 Netlify，其在国内的访问速度比 GitHub Pages 快，而且非常方便：与你的 GitHub hexo 源码仓库关联以后，会自动拉取其源码，然后自动部署生成网站。</p><p><strong>唯一美中不足的是，在我使用了两年的 Netlify 后，我的账号莫名其妙被 ban 了</strong>，所以本网站目前又迁移回了 GitHub Pages。</p><h2 id="2-GitHub-Pages-配置教程"><a href="#2-GitHub-Pages-配置教程" class="headerlink" title="2. GitHub Pages 配置教程"></a>2. GitHub Pages 配置教程</h2><p>follow 这篇博客即可，实测没有问题：</p><p><a href="https://tech.yemengstar.com/hexo-tutorial-deploy-githubpages-beginner/">HEXO系列教程 | 使用GitHub部署静态博客HEXO | 小白向教程 – 夜梦星尘の折腾日记 (yemengstar.com)</a></p><p><a href="https://tech.yemengstar.com/hexo-tutorial-use-your-domain-beginner/">HEXO系列教程 | 为HEXO绑定自己的域名 | 小白向教程 – 夜梦星尘の折腾日记 (yemengstar.com)</a></p><h2 id="3-Netlify-配置教程"><a href="#3-Netlify-配置教程" class="headerlink" title="3. Netlify 配置教程"></a>3. Netlify 配置教程</h2><p>如果有幸能够注册 Netlify 账号而且不被 ban 的话，可以按照这个教程配置：</p><p><a href="https://blog.cuijiacai.com/blog-building/">个人博客搭建教程 | 爱扑bug的熊 (cuijiacai.com)</a></p><p>但是没有配置其中的CloudWare CDN加速，Netlify自带的已经够用</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简易教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zotero Setting</title>
      <link href="/2024/10/11/Zotero-Setting/"/>
      <url>/2024/10/11/Zotero-Setting/</url>
      
        <content type="html"><![CDATA[<h2 id="1-下载-zotero-amp-安装插件"><a href="#1-下载-zotero-amp-安装插件" class="headerlink" title="1. 下载 zotero &amp; 安装插件"></a>1. 下载 zotero &amp; 安装插件</h2><p>从 <a href="https://www.zotero.org/">Zotero官网</a> 下载 zotero 即可，教程下载的是 zotero7。</p><p>安装好 Zotero 以后，从 <a href="https://zotero-chinese.com/plugins/">Zotero 插件商店</a> 搜索并下载如下插件：</p><ul><li>Better Notes for Zotero</li><li>Easier Citation</li><li>Ethereal Reference</li><li>Ethereal Style</li><li>Green Frog</li><li>Jasminum</li><li>Sci-PDF</li><li>Translate for Zotero</li><li>Zotero Reading List</li></ul><p>下载插件后，在 zotero 中的 <strong><em>工具 &gt; 插件</em></strong> 中，点击右上角的 <strong><em>设置符号</em></strong> ，选择 <strong><em>Install Plugin From File…</em></strong> 安装下载好的插件。</p><h2 id="2-插件设置"><a href="#2-插件设置" class="headerlink" title="2. 插件设置"></a>2. 插件设置</h2><p>有些插件安装好之后可以直接使用，有些插件需要设置，在 <strong><em>编辑 &gt; 设置</em></strong> 中可以进行设置。</p><h3 id="2-1-翻译"><a href="#2-1-翻译" class="headerlink" title="2.1 翻译"></a>2.1 翻译</h3><p>翻译主要是要配置翻译的服务和API密钥。在翻译服务中，后面有钥匙🔑符号的代表需要密钥，要去对应的翻译官网注册账号并获取密钥，我用的是有道智云，注册送100元翻译额度，老牌的DeepL当然也不错。</p><p>如果懒得注册的话，也可以用前面几个不需要密钥的服务凑合一下。</p><p><img src="/images/Zotero-Setting/image-20241011171856198.png" alt="image-20241011171856198"></p><h3 id="2-2-绿青蛙"><a href="#2-2-绿青蛙" class="headerlink" title="2.2 绿青蛙"></a>2.2 绿青蛙</h3><p>绿青蛙可以从 <a href="https://www.easyscholar.cc/">easyScholar</a> 拉取期刊的数据如分区/等级，和翻译一样，在 easySchlar 官网注册得到密钥以后填入即可使用。</p><h3 id="2-3-笔记"><a href="#2-3-笔记" class="headerlink" title="2.3 笔记"></a>2.3 笔记</h3><p>笔记插件 Better Notes 本身不需要设置，但是之前遇到了写笔记时使用中文+数学公式就打不出字or闪退的情况，后面发现是需要在 <strong><em>设置&gt;高级&gt;语言和区域</em></strong> 中勾选 <strong><em>启用双向文本编辑工具</em></strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QMK 固件降低延迟</title>
      <link href="/2024/10/11/QMK-Low-Latency/"/>
      <url>/2024/10/11/QMK-Low-Latency/</url>
      
        <content type="html"><![CDATA[<p>平常打游戏的键盘用的是 kbdfans 的 kbd8x_mk2，一测延迟有 10ms，刚好又看到 qmk 仓库中有这把键盘的源码，于是想着修改一下参数，降低延迟。</p><p>在 config.h 中这些参数可能影响延迟：</p><ul><li>USB_POLLING_INTERVAL_MS 轮询率，默认 1 ms，所以也不是瓶颈所在</li><li>MATRIX_IO_DELAY 矩阵扫描率，默认 30 us，更加没问题了</li><li>DEBOUNCE 消抖时间，默认 5 ms，关系很大，根据轴体素质可以适当降低。我用的力驰的轴，素质比较高，测试了设置为 0 小键都不会有问题，但是空格会双击，最后调节到了 2 ms</li></ul><p>此外，还尝试了编译时加上 OPT=2 等，最后发现还是消抖最有用，可能是这把键盘使用的是垃圾 Atmega32U4，性能太差了，导致有些优化看不出来。</p><p>对于 STM32F401 等 MCU，可以参考这个开源工程做到 8K：</p><ul><li><a href="https://www.bilibili.com/video/BV1nA411d77x/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">QMK键盘延迟测试 以及1k与8khz回报率延迟对比_哔哩哔哩_bilibili</a></li><li><a href="https://github.com/luantty2/qmk_firmware/tree/qmk_master_build_2022q4/keyboards/akeypad">qmk_firmware/keyboards/akeypad at qmk_master_build_2022q4 · luantty2/qmk_firmware (github.com)</a></li><li><a href="https://github.com/luantty2/akeypad">luantty2/akeypad (github.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客制化键盘 </tag>
            
            <tag> DIY </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>家庭Mesh组网（二）—— 家庭 Mesh 配置</title>
      <link href="/2024/08/07/Home-Mesh-2/"/>
      <url>/2024/08/07/Home-Mesh-2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-家庭网络拓扑分析"><a href="#1-家庭网络拓扑分析" class="headerlink" title="1. 家庭网络拓扑分析"></a>1. 家庭网络拓扑分析</h2><p>设备介绍：</p><ul><li>GS3202：移动送的光猫，配置较差，只有1口是千兆，2-4口是百兆</li><li>RT-AC66U：老华硕路由器，暂时接在百兆口苟延残喘，只能给我的房间提供网络</li><li>E2633：据说是中兴 AX3000 巡天的运营商定制版，可以和中兴设备组网</li><li>IPTV：父母用的电视机顶盒</li></ul><p>需求主要两点：</p><ul><li>把老华硕路由换掉，并和 E2633 组网，因此需要换成中兴的路由器</li><li>IPTV 可以正常使用</li></ul><p><img src="/images/Home-Mesh-2/image-20240807002546154.png" alt="image-20240807002546154" style="zoom: 50%;" /></p><p>先介绍关于 IPTV 的内容：</p><p>如果 IPTV 和路由器都放在客厅电视柜的话，需要两根从客厅到弱电箱的网线分别连接千兆口（一般是1口）与路由器，电视口（一般是2口）与IPTV。</p><p>而之前家里装网络的电信师傅搞了一个很神奇的操作：把8芯的网线强行分成两个4芯，而4芯线的速度一般不到百兆，只能说操作非常难绷。</p><p><img src="/images/Home-Mesh-2/image-20240807003538442.png" alt="image-20240807003538442" style="zoom:50%;" /></p><p>而第一张图中移动的装法则是把 IPTV 连接到了 E2633 路由器的 LAN 口上，并且在路由器和光猫中进行了一些设置如下。</p><p>超级管理员进入光猫后台可以看到 IPTV 业务的 VLAN ID 为 512，正常而言，绑定选项中的 LAN2 是勾选的，然后直接用 IPTV 机顶盒连接到光猫的 LAN2 就行。而这里用不到把它取消绑定了。</p><p>在绑定配置中，将 VLAN 512 绑定至 LAN1，实现对连接 E2633 路由器和光猫网线的复用。</p><p><img src="/images/Home-Mesh-2/image-20240807005057259.png" alt="image-20240807005057259" style="zoom:50%;" /></p><p><img src="/images/Home-Mesh-2/image-20240807005332174.png" alt="image-20240807005332174"></p><p>然后，在路由器中设置IPTV透传，这样就可以让 IPTV 机顶盒连接路由器 LAN1 来看电视。</p><p><img src="/images/Home-Mesh-2/image-20240807090923306.png" alt="image-20240807090923306"></p><p>然而，设置完成后打开 IPTV 却没有网络。</p><p>经过排查，是路由器上网方式设置的问题导致的。光猫中，Internet 服务的模式是路由模式，并且带有 DHCP Server；而 IPTV 服务的模式是桥接模式，且不带有 DHCP Server。路由器设置的上网模式是桥接，对于 Internet 服务而言，光猫是路由模式，所以路由器是桥接模式不影响上网；而对于 IPTV 服务而言，光猫和路由都是桥接模式的话，自然就上不了网了，光猫和路由都不会分配 IP 地址和路由。</p><p>因此，这里把路由器的上网模式从桥接改为 DHCP 就可以了。</p><p><img src="/images/Home-Mesh-2/image-20240807010031313.png" alt="image-20240807010031313" style="zoom:50%;" /></p><h2 id="2-方案选择"><a href="#2-方案选择" class="headerlink" title="2. 方案选择"></a>2. 方案选择</h2><p>由于客厅和卧室到弱电箱的网线都只有一根，所以最简单的方案是：AX3000晴天是一种<strong>壁挂式</strong>路由，作为主路由挂在弱电箱旁边，然后直接可以连接客厅和卧室的子路由。</p><p>然而，经过多方咨询，了解到这种情况下 <strong>IPTV 只能接到主路由的 LAN 口</strong>，没有办法接到子路由的 LAN 口。因为如果 IPTV 要使用的话，主路由和子路由都要配置 IPTV 透传，那样主路由的 LAN1 口既要做 MESH，又要做 IPTV 透传，所以<strong>不可用！</strong></p><p><img src="/images/Home-Mesh-2/image-20240807091416567.png" alt="image-20240807091416567" style="zoom:50%;" /></p><p>而突发奇想的第二种方法是用旧华硕路由器关闭 WiFi 功能，或者是用软路由等，然后让两个中兴的路由器连接到上面做 AP Mesh。但是，同样也无法使用 IPTV。</p><p><img src="/images/Home-Mesh-2/image-20240807091804810.png" alt="image-20240807091804810" style="zoom:50%;" /></p><p>所以为了这个 IPTV，就只能使用最复杂的 VLAN 方案了，使用两个水星 GS105 pro 网管交换机。1口作为 trunk，复用传输数据；2 口划入 VLAN2，负责光猫和主路由 WAN 口连接；3 口划入 VLAN3，负责主路由 LAN 口和副路由 WAN 口连接；4 口划入 VLAN4，负责光猫 IPTV 口和 IPTV 机顶盒连接。</p><p>注意这里我把 AX3000 巡天和 E2633 调换了位置，是因为标准版比定制版更适合作为主路由。</p><p><img src="/images/Home-Mesh-2/image-20240807092605776.png" alt="image-20240807092605776"></p><h2 id="3-Mesh-配置"><a href="#3-Mesh-配置" class="headerlink" title="3. Mesh 配置"></a>3. Mesh 配置</h2><p>首先，在弱电箱旁边不使用交换机直接按照：光猫 - 主路由 - 子路由的顺序测试组网，这个过程非常简单，把主路由接上网线通电以后，连接默认的 WiFi 进入设置网站设置 WiFi 名和密码等即可。</p><p>然后在主路由的设置网页中关闭“自组网V2”选项，将子路由恢复默认设置（用牙签戳reset五秒以上，如果是全新的就不需要恢复了），然后把子路由的 WAN 接到主路由的 LAN，可以看到子路由闪灯，过一段时间等子路由灯绿了就是自动配置好 mesh 了，上到路由管理后台可以看到组网情况：</p><p><img src="/images/Home-Mesh-2/image-20240808103924014.png" alt="image-20240808103924014" style="zoom: 80%;" /></p><p>此时，说明两个路由器的组网功能是正常的，然后就把两个路由器分别放到客厅和卧室，然后配置 VLAN 交换机来单线复用。</p><p>在拓扑中可以看到，两个交换机的端口对应是对称的，所以两个交换机的设置是一模一样的。</p><p>首先，把交换机用网线接入到电脑上，交换机的默认配置地址是 192.168.0.1，所以将电脑有线网卡的 IP 设置为 192.168.0.x 网段，这里我设置为了 192.168.0.3：</p><p><img src="/images/Home-Mesh-2/image-20240808100011860.png" alt="image-20240808100011860" style="zoom: 80%;" /></p><p>然后，就可以在浏览器访问 192.168.0.1 来进入交换机的配置网页，然后输入交换机背面的默认账号密码登录。</p><p>首先进入到 “VLAN - 801.2Q VLAN”，开启 “802.1Q VLAN使能” 并应用，然后配置各个端口的 VLAN。</p><p>需要注意的是 trunk 端口（也就是复用多个 VLAN 的端口，这里是 1 号口）需要设置为 tagged，而只走一个 VLAN 的端口设置为 untagged，总体 VLAN 设置如下：</p><p><img src="/images/Home-Mesh-2/image-20240808102554708.png" alt="image-20240808102554708" style="zoom: 80%;" /></p><p>然后在 “VLAN - 802.1Q PVID设置” 中把三个 untagged 端口的 PVID 设置为对应的：</p><p><img src="/images/Home-Mesh-2/image-20240808103118558.png" alt="image-20240808103118558"></p><p>两台 VLAN 交换机保存退出以后，按照拓扑定义的方式接线，等待几十秒以后主路由和子路由都亮绿灯，组网成功。但是使用 VLAN4 的 IPTV 却没有正常工作，下面介绍 IPTV 的进一步配置方法。</p><h2 id="4-IPTV-配置"><a href="#4-IPTV-配置" class="headerlink" title="4. IPTV 配置"></a>4. IPTV 配置</h2><p>IPTV 通过 VLAN4 在光猫的 2 号口和机顶盒之间传输数据，但是机顶盒并不能联网。</p><p>在机顶盒上面检测，机顶盒到光猫的内网是通的，但是不能到外网。</p><p>在 1. 中通过路由器透传配置 IPTV 的情况中，需要把路由器上网设置从桥接改为 DHCP 才能让 IPTV 机顶盒上网，这是因为光猫中 IPTV 设置的模式是桥接模式，需要内网的路由器进行路由和 IP 地址分配。在使用 VLAN 交换机复用的配置中也是类似的，光猫无法直接路由 IPTV 的数据，但是这里的 IPTV 机顶盒又没有接入到路由器 LAN 口，那么要怎么给其配置呢？答案是先配置交换机，把交换机加入到主路由的网络中，而 IPTV 机顶盒又连接在交换机上面，可以通过这个方式继续让路由器给 IPTV 路由。</p><p>在交换机的 “系统管理 - IP设置” 中设置IP 和网络，由于主路由的 IP 是 192.168.5.1，所以把弱电箱交换机的 IP 设置为 192.168.5.252，客厅交换机的 IP 设置为 192.168.5.253，两者的默认网关都设置为主路由 192.168.5.1。</p><p>而且这样一来，两个交换机加入了主路由的网络，无需用网线连接到交换机上面才能设置，而是直接连上 WiFi，访问上面的两个 IP 地址就能设置交换机。</p><p>此外，在两个交换机的 “二层交换 - IGMP 侦听” 中，都把 IGMP 侦听关掉（IPTV 是基于 IGMP 组播实现的，至于为什么关闭侦听我也不是很清楚…）。</p><p>然后重新尝试 IPTV 就可以正常使用了。</p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> Mesh </tag>
            
            <tag> 无线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>家庭Mesh组网（一）—— Mesh 介绍</title>
      <link href="/2024/08/06/Home-Mesh-1/"/>
      <url>/2024/08/06/Home-Mesh-1/</url>
      
        <content type="html"><![CDATA[<p>家里的老华硕 <a href="https://www.asus.com.cn/networking-iot-servers/wifi-routers/asus-wifi-routers/rt-ac66u-b1/">RT-AC66U</a> 在辛苦工作了五年后终于开始出问题了，WiFi 信号一天消失不见好几次，刚好电信的百兆宽带也要到期了，准备换成移动手机送的千兆。于是打算顺便把家里的路由器一换，组成现在流行的多路由器 Mesh 组网方案。</p><h2 id="1-什么是-Mesh？为什么要用-Mesh？"><a href="#1-什么是-Mesh？为什么要用-Mesh？" class="headerlink" title="1. 什么是 Mesh？为什么要用 Mesh？"></a>1. 什么是 Mesh？为什么要用 Mesh？</h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/343117525">2024年新版 路由器Mesh组网全攻略（网络拓扑方案、装修网线预埋方案） - 知乎 (zhihu.com)</a></p><p>在家庭无线网络中，由于水泥墙等阻隔，一个路由器产生的 WiFi 信号很难覆盖全家，在一些死角处信号会很差。一个常见的误区是：购买价格昂贵的高端路由器来获得超强的穿墙能力，从而覆盖全家。因为相关标准对无线发射功率做了限制，最好的路由器也无法发出足够穿墙的信号，除非是类似华硕改地区为澳大利亚（澳洲对无线发射功率的限制较为宽松）等骚操作来进行。</p><p>与其花大几百乃至上千买一个不一定有用的高端路由器，不如多买两个普通路由器，放在不同的房间里面来覆盖信号死角。</p><p>而单纯放置多个路由器的坏处就是在一个家中有好几个不同的 WiFi，走到不同的地方要切换到信号好的一个。而 Mesh 组网可以让多个路由器共享一个 WiFi 名称（SSID），在用户的感知上，全屋只有一个 WiFi。</p><p>Mesh 分为有线 Mesh 和无线 Mesh 两种方式，有线 Mesh 的路由器之间采用有线进行连接，而无线 Mesh 的路由器之间使用无线信号传输通信。很明显，有线 Mesh 更加稳定高效，但布局也比无线困难。下面介绍有线 Mesh 的几种常见拓扑：</p><h2 id="2-传统有线-Mesh"><a href="#2-传统有线-Mesh" class="headerlink" title="2. 传统有线 Mesh"></a>2. 传统有线 Mesh</h2><p><img src="/images/Home-Mesh-1/image-20240806234856308.png" alt="image-20240806234856308"></p><p>在最传统的 Mesh 拓扑结构中，主路由的 WAN 口连接光猫，而其他子路由的 WAN 口连接主路由的 LAN 口。</p><p><strong>注：</strong>WAN 口是路由器网线入口，LAN 口是路由器网线出口。</p><p>在传统的家庭网线布局中，光猫往往位于<strong>弱电箱</strong>，也就是一个墙内的铁皮小箱子。箱子中有多条网线连接至不同房间的网口。因此，<strong>主路由</strong>往往需要<strong>也放置在弱电箱</strong>中，导致主路由的<strong>信号被弱电箱削减</strong>很多，也<strong>不容易散热</strong>，且很多弱电箱<strong>放不下</strong>较好的主路由。</p><p>另一种方式是把主路由放在弱电箱之外，在弱电箱中再放一个<strong>交换机</strong>，把主路由的 LAN 口和子路由的 WAN 口连接到交换机上。</p><p>交换机是很便宜的，做起来不难。这样做最大的难点是<strong>主路由需要有两根网线连接到弱电箱</strong>，一根负责连接光猫与 WAN 口，一根负责连接 LAN 口与交换机。而大多数家庭装修的时候，都只给一个房间配备了一根网线。</p><p><img src="/images/Home-Mesh-1/v2-f29c72cec154b87a4af078255ea82333_r.jpg" alt="img"></p><p>但是这种在弱电箱中放置交换机，而把主路由放在外面的思路是好的，只不过需要一对 <strong>VLAN 交换机</strong>来进行<strong>单线复用</strong>。VLAN 虚拟局域网可以通过标签（tag）把一个物理 LAN <strong>隔离</strong>为多个虚拟 LAN。</p><p>位于弱电箱的 VLAN 交换机和主路由器旁的 VLAN 交换机只需要一根网线连接，但是却能够划分出两个 VLAN 来，图中的 VLAN2 用于连接光猫和主路由 WAN 口，VLAN3 用于连接主路由的 LAN 口和子路由的 WAN 口。</p><p><img src="/images/Home-Mesh-1/v2-02d1ba50ba96059fe345de8790661f25_r.jpg" alt="img"></p><h2 id="3-AP-Mesh"><a href="#3-AP-Mesh" class="headerlink" title="3. AP Mesh"></a>3. AP Mesh</h2><p>上述三种方法，要么浪费一个主路由，要么需要两个网线，要么需要复杂的 VLAN，来进行路由之间的串联，那么如果把路由之间并联，也就是每一个路由器都直接连接到光猫，能不能行得通呢？</p><p>答案是可以的，现在很多新路由器支持 AP Mesh 方式，来避免复杂的布线。</p><p>但是这样，又有一个缺点：路由器之间的 Mesh 数据交换都来到了光猫上，运营商送的小光猫很可能受不住负载，导致网络出问题。一些万兆光猫如中兴 g7615 系列可以胜任 AP Mesh 的数据交换，但是换光猫又是一项成本和复杂度很高的任务。</p><p><img src="/images/Home-Mesh-1/v2-18116bfe8d841f4dd76702b5bb04553b_r.jpg" alt="img"></p><p>另一个方式是在光猫后面接一个软路由来分担光猫<strong>拨号上网</strong>的任务，但是这玩意好像又是一个新的大坑了…</p><p><img src="/images/Home-Mesh-1/v2-b8618e750faf6b8d3482274e22cd9d44_720w.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> Mesh </tag>
            
            <tag> 无线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 电源键功能修改</title>
      <link href="/2024/07/05/Linux-%E7%94%B5%E6%BA%90%E9%94%AE%E5%8A%9F%E8%83%BD%E4%BF%AE%E6%94%B9/"/>
      <url>/2024/07/05/Linux-%E7%94%B5%E6%BA%90%E9%94%AE%E5%8A%9F%E8%83%BD%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<p>最近有远程办公的需求，而**的 ToDesk 在换了 6.8 Kernel 的 Ubuntu 上老崩溃，所以买了一个米家只能开关，在手机上操控开关。</p><p>正常来说强制关机需要长按四五秒的样子，但是这个沟槽的开关只能短按，而不能长按。Ubuntu 20.04 LTS 的短按电源键是弹出一个询问窗口，等待 60s 以后才关机，非常的折磨。所以文本例举和尝试了网上的集中修改按下电源键反应的方法，最终找到了一种由于的方法。</p><ol><li><p>修改 systemd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">DefaultTimeoutStopSec=90s</span></span><br><span class="line">改为</span><br><span class="line">DefaultTimeoutStopSec=5s</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><ul><li>经过测试，无效</li></ul></li><li><p>修改 gnome settings 的 button-power</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.settings-daemon.plugins.power button-power &#x27;shutdown&#x27;</span><br><span class="line">或者还有人说</span><br><span class="line">gsettings set org.gnome.settings-daemon.plugins.power power-button-action &#x27;shutdown&#x27;</span><br></pre></td></tr></table></figure><ul><li>尝试了两种方法都没有用，而且我的版本的 gnome 中 power-button-action 根本没有 ‘shutdown’ 这个值</li></ul></li><li><p>修改 systemd-logind</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/logind.conf</span><br><span class="line"></span><br><span class="line">修改如下三行</span><br><span class="line">PowerKeyIgnoreInhibited=no</span><br><span class="line">HandlePowerKey=poweroff</span><br><span class="line">PowerKeyAction=poweroff</span><br><span class="line"></span><br><span class="line">sudo systemctl restart systemd-logind</span><br></pre></td></tr></table></figure><ul><li>无效，而且 restart systemd-logind 会重启电脑，吓我一跳</li></ul></li><li><p>修改 ACPI</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/acpi/events/powerbtn</span><br><span class="line"></span><br><span class="line">添加</span><br><span class="line">event=button/power</span><br><span class="line">action=/sbin/shutdown -h now</span><br><span class="line"></span><br><span class="line">sudo systemctl restart acpid</span><br></pre></td></tr></table></figure><ul><li>测试有效，短按电源键直接关机</li><li>如果你想重启的话，可以把 <code>action=/sbin/shutdown -h now</code> 改为 <code>action=/sbin/reboot</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> Linux </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Network 2: 以太网驱动收包</title>
      <link href="/2024/07/01/Linux-Network-2-%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%A9%B1%E5%8A%A8%E6%94%B6%E5%8C%85/"/>
      <url>/2024/07/01/Linux-Network-2-%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%A9%B1%E5%8A%A8%E6%94%B6%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/wangquan1992/article/details/112129162">linux网络报文接收发送浅析_netif tx netif rx-CSDN博客</a></p><p><a href="https://blog.51cto.com/yaoyang/1269713">链路层和网络层的接口 （linux网络子系统学习 第五节 ） _51CTO博客_linux链路层编程</a></p><h2 id="1-以太网驱动收包处理流程"><a href="#1-以太网驱动收包处理流程" class="headerlink" title="1. 以太网驱动收包处理流程"></a>1. 以太网驱动收包处理流程</h2><p>以 ne2k_pci 驱动为例，介绍 linux 中以太网设备驱动是怎么从设备读取数据、构造 skb、并上传到上层的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((pkt_stat &amp; <span class="number">0x0F</span>) == ENRSR_RXOK) &#123;</span><br><span class="line">    <span class="keyword">struct</span> sk_buff *skb;</span><br><span class="line"></span><br><span class="line">    skb = netdev_alloc_skb(dev, pkt_len + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (skb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        netif_err(ei_local, rx_err, dev,</span><br><span class="line">                  <span class="string">&quot;Couldn&#x27;t allocate a sk_buff of size %d\n&quot;</span>,</span><br><span class="line">                  pkt_len);</span><br><span class="line">        dev-&gt;stats.rx_dropped++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        skb_reserve(skb, <span class="number">2</span>);    <span class="comment">/* IP headers on 16 byte boundaries */</span></span><br><span class="line">        skb_put(skb, pkt_len);  <span class="comment">/* Make room */</span></span><br><span class="line">        ei_block_input(dev, pkt_len, skb, current_offset + <span class="keyword">sizeof</span>(rx_frame));</span><br><span class="line">        skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">        <span class="keyword">if</span> (!skb_defer_rx_timestamp(skb))</span><br><span class="line">            netif_rx(skb);</span><br><span class="line">        dev-&gt;stats.rx_packets++;</span><br><span class="line">        dev-&gt;stats.rx_bytes += pkt_len;</span><br><span class="line">        <span class="keyword">if</span> (pkt_stat &amp; ENRSR_PHY)</span><br><span class="line">            dev-&gt;stats.multicast++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-分配-skb-和预留空间"><a href="#1-1-分配-skb-和预留空间" class="headerlink" title="1.1 分配 skb 和预留空间"></a>1.1 分配 skb 和预留空间</h3><p>如果要从设备接收 <code>pkt_len</code> 大小的数据，首先会从设备中分配 <code>pkt_len + 2</code> 大小的内存。</p><p>然后 <code>skb_reverse(skb, 2)</code>，这个函数很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">skb_reserve</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">         skb-&gt;data += len;  </span><br><span class="line">         skb-&gt;tail += len;  </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>也就是把 data 和 tail 都向后移动 2 位。</p><p>而 <code>skb_put(skb, pkt_len)</code> 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_put</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">         <span class="type">unsigned</span> <span class="type">char</span> *tmp = skb-&gt;tail;  </span><br><span class="line">         SKB_LINEAR_ASSERT(skb);            </span><br><span class="line">         skb-&gt;tail += len;                 <span class="comment">// 移动指针  </span></span><br><span class="line">         skb-&gt;len  += len;                 <span class="comment">// 数据空间增大len  </span></span><br><span class="line">         <span class="keyword">if</span> (unlikely(skb-&gt;tail&gt;skb-&gt;end)) <span class="comment">// 空间不够</span></span><br><span class="line">                 skb_over_panic(skb, len, current_text_addr());  </span><br><span class="line">         <span class="keyword">return</span> tmp;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>则是把 tail 向后移动 <code>pkt_len</code> 位，让线性数据的真实长度变为 <code>pkt_len</code>。</p><h3 id="1-2-读取数据"><a href="#1-2-读取数据" class="headerlink" title="1.2 读取数据"></a>1.2 读取数据</h3><p><code>ei_block_input(dev, pkt_len, skb, current_offset + sizeof(rx_frame));</code> 则是令 buf = skb-&gt;data，然后从硬件中 copy <code>pkt_len</code> 长度的数据到 buf 中。</p><h3 id="1-3-eth-type-trans"><a href="#1-3-eth-type-trans" class="headerlink" title="1.3 eth_type_trans"></a>1.3 eth_type_trans</h3><p>阅读有关源码，这个函数做了两件事情：</p><ul><li>将 mac_header 指向当前的 data 位置</li><li><code>skb_pull(ETH_HLEN)</code> 将 data 向后移动以太网帧头部长度，可以理解为丢弃了以太网帧头部</li><li>从 mac_header 读取网络层协议类型字段，并返回</li></ul><p>这个函数运行完成以后，skb 的以太网头部被丢弃了，并将返回的网络层协议类型赋值给了 protocol。</p><h3 id="1-4-上传-skb"><a href="#1-4-上传-skb" class="headerlink" title="1.4 上传 skb"></a>1.4 上传 skb</h3><p>调用 <code>netif_rx(skb);</code> 最终会调用到 <code>netif_receive_skb</code>，后者通过检查 skb-&gt;protocol 通过 ptype_base hash 表来上传给对应的上层协议栈处理。</p><h2 id="2-题外话"><a href="#2-题外话" class="headerlink" title="2. 题外话"></a>2. 题外话</h2><p>在第一章中说到，skb 除了线性部分，还有非线性部分，而从以太网驱动的处理流程中来看，数据全部都被放到了线性部分中。</p><p>而以太网头部在驱动就被处理掉了，传递给上层的包就只剩下 IP 往上层的包了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Network 1: SKB</title>
      <link href="/2024/07/01/Linux-Network-1-SKB/"/>
      <url>/2024/07/01/Linux-Network-1-SKB/</url>
      
        <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/tzh36/p/5424564.html">Linux内核：sk_buff解析 - 唐稚骅 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.jianshu.com/p/3c5d5fa339fc">skb结构和相关操作函数 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/x_wukong/p/6650056.html">Linux 内核网络协议栈 ———sk_buff 结构体 以及 完全解释 （2.6.16） - 明明是悟空 - 博客园 (cnblogs.com)</a></p><h2 id="1-SKB-结构概览"><a href="#1-SKB-结构概览" class="headerlink" title="1. SKB 结构概览"></a>1. SKB 结构概览</h2><p>SKB 的结构是这样一个很复杂的图，可以看到 skb 分为三部分：控制（<code>struct sk_buff</code> 本身）、线性数据、非线性数据（skb_shared_info）</p><p><img src="/images/Linux-Network-1-SKB/SouthEast.png" alt="img"></p><h2 id="2-SKB-线性数据部分"><a href="#2-SKB-线性数据部分" class="headerlink" title="2. SKB 线性数据部分"></a>2. SKB 线性数据部分</h2><p>SKB 的线性数据部分是用于存放数据包的<strong>连续内存空间</strong>，所以称为是线性的，主要有 head, end, data, tail 四个指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">__u16 transport_header; <span class="comment">//传输头相对于skb-&gt;head的偏移</span></span><br><span class="line"></span><br><span class="line">__u16 network_header;<span class="comment">//网络头相对于skb-&gt;head的偏移</span></span><br><span class="line"></span><br><span class="line">__u16 mac_header;<span class="comment">//以太网头相对于skb-&gt;head的偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These elements must be at the end, see alloc_skb() for details. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">sk_buff_data_t</span> tail;</span><br><span class="line"></span><br><span class="line"><span class="type">sk_buff_data_t</span> end;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *head, *data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>head 和 end 指向数据趋于的头部和尾部，是分配的时候就固定的</li><li>data 和 tail 是真正数据的开头和结尾</li><li>head 与 data 之间的趋于被称为 headroom，data 和 tail 之间的区域被称为 tailroom。刚刚分配的时候，headroom 大小为 0，tailroom 大小为 size，后续的操作通过移动 data 和 tail 来完成。</li></ul><p>四者的关系在这个图里面很清楚：</p><p><img src="/images/Linux-Network-1-SKB/941007-20160423142022179-2013851116.jpg" alt="img"></p><h2 id="3-SKB-非线性数据部分"><a href="#3-SKB-非线性数据部分" class="headerlink" title="3. SKB 非线性数据部分"></a>3. SKB 非线性数据部分</h2><p>对于大型或者是分片的数据包，其数据无法存储到连续的内存块也就是 data 中，所以需要非线性的数据存储。</p><p>skb 中有一个叫做 skb_shared_info 的结构来管理非线性部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> dataref;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> nr_frags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gso_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gso_segs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gso_type;</span><br><span class="line">    __be32 ip6_frag_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag_list</span>;</span></span><br><span class="line">    <span class="type">skb_frag_t</span> frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>nr_frags：非线性部分的片段数量</li><li>frags：片段</li></ul><p>每一个片段 skb_frag_t 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct skb_frag_struct &#123;</span><br><span class="line">    struct page *page;</span><br><span class="line">    __u32 page_offset;</span><br><span class="line">    __u32 size;</span><br><span class="line">&#125; skb_frag_t;</span><br></pre></td></tr></table></figure><p>这个结构体记录了片段在内存中的位置和大小。</p><h3 id="3-1-非线性部分的用途"><a href="#3-1-非线性部分的用途" class="headerlink" title="3.1 非线性部分的用途"></a>3.1 非线性部分的用途</h3><p>非线性部分的用途主要有：</p><ul><li>数据包过大，难以分配连续内存</li><li>IP 分片和重组</li></ul><h2 id="4-skb-gt-len-与-skb-gt-data-len"><a href="#4-skb-gt-len-与-skb-gt-data-len" class="headerlink" title="4. skb-&gt;len 与 skb-&gt;data_len"></a>4. skb-&gt;len 与 skb-&gt;data_len</h2><p>len 指的是数据包的总长度，也就是线性和非线性长度之和。</p><p>data_len 虽然带有 data 字样，但<strong>不是</strong>线性部分 data 的长度，<strong>而是</strong>非线性部分的长度。</p><p>而线性部分 skb_headlen(skb) = skb-&gt;len - skb-&gt;data_len。</p>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tailscale: 在你的远程设备之间搭建局域网</title>
      <link href="/2024/06/18/tailscale-%E5%9C%A8%E4%BD%A0%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E4%B9%8B%E9%97%B4%E6%90%AD%E5%BB%BA%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
      <url>/2024/06/18/tailscale-%E5%9C%A8%E4%BD%A0%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E4%B9%8B%E9%97%B4%E6%90%AD%E5%BB%BA%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设想如何在外部远程连接你在校园网或实验室内网中的设备：</p><ul><li>采用 ToDesk 等远程桌面软件，缺点是卡、清晰度低、而且在 Linux 系统中的兼容性做的不是很好，容易崩溃。</li><li>采用系统自带的远程软件如：SSH、RDP、VNC。</li></ul><p>后者的性能和稳定性更好，但是一般都是直接通过 <code>ip:port</code> 连接。而对于局域网（如校园网、实验室内网）内的设备，是没有公网 IP 的，只能在局域网的出口路由处做端口映射，比较麻烦。</p><p>而已知解决办法是通过 FTP 进行内网穿透，将你的内网设备映射到一个外部 IP 例如 <code>your-id.ftp.com</code>，但是在很多学校中，这种内网直接映射公网 IP 的方法是非法的，有潜在的威胁。</p><p>而本文介绍的 tailscale 则会在你的设备之间组件个人虚拟局域网，而不是直接把你的设备暴露在公网上，更加安全，且可以达到同样的效果。</p><p>而要配置 tailscale，其实流程非常简单，在你的不同设备上安装 tailscale 软件，然后登陆同一个账号就可以互相访问了。但比较恶心的是这个软件非常难装，尤其是在 windows 上面。</p><h2 id="Windows-安装"><a href="#Windows-安装" class="headerlink" title="Windows 安装"></a>Windows 安装</h2><p>当你访问 tailscale 官方下载页下载 Windows 安装包的时候，会下载一个几百 kb 的 exe 包来安装，这个安装过程非常缓慢，而且大概率进行到一半报错失败了。下面是一个成功率更高的解决办法：</p><ol><li>关闭防火墙&amp;杀毒软件，<strong>这个很重要！！！</strong></li><li>在官方下载页下载 msi 安装包，大概有二十多 mb，可以有效防止 exe 包安装的时候下载到一半失败了。</li></ol><p>​        <a href="https://pkgs.tailscale.com/stable/#windows">pkgs.tailscale.com/stable/#windows</a></p><p>​        一般的 64 位 PC 下载 <code>tailscale-setup-x.y.z-amd64.msi</code> 即可。</p><p>然后，从 msi 安装，打开软件登录即可。</p><h2 id="Ubuntu-安装"><a href="#Ubuntu-安装" class="headerlink" title="Ubuntu 安装"></a>Ubuntu 安装</h2><p>官方给的安装方法也是运行一个脚本，然后和 windows 一样，脚本运行到一半容易因为网络问题报错。所以，直接下载其 deb 包安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkgs.tailscale.com/stable/ubuntu/pool/tailscale_x.y.z_amd64.deb</span><br><span class="line">sudo dpkt -i tailscale_x.y.z_amd64.deb</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>都安装和登陆好以后，就可以互相 ping 同对方的虚拟地址了，然后就可以直接通过 IP 进行 SSH、VNC 等连接了。</p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程连接 </tag>
            
            <tag> 虚拟局域网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu编译Linux6.8内核</title>
      <link href="/2024/06/04/Ubuntu%E7%BC%96%E8%AF%91Linux6-8%E5%86%85%E6%A0%B8/"/>
      <url>/2024/06/04/Ubuntu%E7%BC%96%E8%AF%91Linux6-8%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<p>记录一下踩的坑</p><h2 id="1-编译前准备"><a href="#1-编译前准备" class="headerlink" title="1. 编译前准备"></a>1. 编译前准备</h2><h3 id="1-1-下载源码"><a href="#1-1-下载源码" class="headerlink" title="1.1 下载源码"></a>1.1 下载源码</h3><p>请在 kernel.org 下载 tar 包并解压到 <code>~/linux-x.y.z</code> 目录。</p><h3 id="1-2-安装编译工具链"><a href="#1-2-安装编译工具链" class="headerlink" title="1.2 安装编译工具链"></a>1.2 安装编译工具链</h3><p>正常来说，需要安装的编译工具链为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libncurses5-dev build-essential openssl flex bison libssl-dev libelf-dev</span><br></pre></td></tr></table></figure><p>其次，6.8 版本还需要安装如下两个工具来支持对应特性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install dwarves # 支持 BTF 选项</span><br><span class="line">sudo apt install zstd # 支持 zstd 压缩内核镜像</span><br></pre></td></tr></table></figure><p>当然，这里我用的是 Clang-12 编译的，而不是 gcc。Linux 6.8 以后<strong>不推荐</strong>使用 Clang-12 而是 Clang-13 以上版本，但是用 Clang-12 也不会报错，Linux 6.9 就会直接报错了。</p><h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h2><h3 id="2-1-config-阶段"><a href="#2-1-config-阶段" class="headerlink" title="2.1 config 阶段"></a>2.1 config 阶段</h3><p>最重要的，把 Ubuntu 的 config 复制过来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/src/linux-headers-5.15.0-107-generic/.config ~/linux-x.y.z/.config</span><br></pre></td></tr></table></figure><p>由于 5.15 和 6.8 版本内核的选项有很多变化，后面编译的时候会弹出很多问题要确认，建议一路回车，这么多也看不过来…</p><p>然后，<code>make menuconfig</code> 修改你自己想要的选项。</p><h3 id="2-2-编译镜像"><a href="#2-2-编译镜像" class="headerlink" title="2.2 编译镜像"></a>2.2 编译镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(nproc) CC=clang-12</span><br></pre></td></tr></table></figure><p>报错过程中有很多坑，下面列出一些常见的：</p><ol><li><p>BTF 与 zstd 报错，缺少第一章中提到的 dwarves 与 zstd 工具，或者关掉 BTF 与 zstd 选项也可以。</p></li><li><p>certs 有关报错：Debian 系都会验证签名，修改 <code>.config</code> 文件中的如下选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot;</span><br><span class="line">CONFIG_SYSTEM_REVOVATION_KEYS=&quot;&quot;</span><br></pre></td></tr></table></figure></li><li><p>栈溢出 <code>error: the frame size of xxxx bytes is larger than 1024 bytes</code>。在 <code>.config</code> 中调整栈大小即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FRAME_WARN=XXXX # 4096 或者 8192</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-安装"><a href="#2-3-安装" class="headerlink" title="2.3 安装"></a>2.3 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>没报错的话直接重启即可选择系统</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程桌面</title>
      <link href="/2023/11/09/Linux%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"/>
      <url>/2023/11/09/Linux%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近因为跑蓝牙 Fuzz 的原因，想要不在实验室的时候也能够远程看一下代码的运行情况，做出修改。所以需要配置一个远程环境。</p><p>单纯的配一个 Linux 远程环境是很简单的，ToDesk 软件就官方支持 Linux；但还有一个需求——重启，重启以后需要自动进行：</p><ul><li>选择规定的内核</li><li>自动进入桌面</li><li>自动运行 ToDesk</li></ul><p>那么设置步骤如下：</p><h2 id="一、选择默认内核"><a href="#一、选择默认内核" class="headerlink" title="一、选择默认内核"></a>一、选择默认内核</h2><p>编辑 grub 的默认选项：</p><p>例如，当我进入系统的时候，第一个界面是：</p><blockquote><p>Ubuntu</p><p>Advanced Options for Ubuntu</p><p>Windows Boot Manager</p></blockquote><p>在选择第二个选项以后，再次选择：</p><blockquote><p>Ubuntu, with Linux 6.5.0</p><p>Ubuntu, with Linux 6.5.0 (recovery mode)</p><p>Ubuntu, with Linux 6.2.0</p><p>Ubuntu, with Linux 6.2.0 (recovery mode)</p></blockquote><p>这里我想选择 6.2 的内核，那么选择的顺序是：第2个-&gt;第3个</p><p>就需要在 /etc/default/grub 中设置 <code>GRUB_DEFAULT=&quot;1&gt; 2&quot;</code></p><p>注意这里的选项编号是从 0 开始的，所以应该是 “1&gt; 2” 而不是 “2&gt; 3”</p><p>然后 <code>sudo update-grub</code> 以后重启就可以默认进入 6.2 内核了。</p><h2 id="二、自动进入桌面"><a href="#二、自动进入桌面" class="headerlink" title="二、自动进入桌面"></a>二、自动进入桌面</h2><p>打开设置，找到 “Users -&gt; Automatic Login” 这样开机以后就可以自己进入桌面。否则的话，即使 ToDesk 连上也无法显示任何东西。</p><h2 id="三、自动启动ToDesk"><a href="#三、自动启动ToDesk" class="headerlink" title="三、自动启动ToDesk"></a>三、自动启动ToDesk</h2><p>在 ToDesk 中设置开机启动，并且设置安全密码。因为重启以后临时密码会变（即使设置成manual重置密码也会变）。</p><p>同时，如果设置了代理的话，代理软件最好也提前打开防止上不了网，从而导致连不上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客制化之旅记录OvO</title>
      <link href="/2023/08/27/KBD/"/>
      <url>/2023/08/27/KBD/</url>
      
        <content type="html"><![CDATA[<h2 id="CX60"><a href="#CX60" class="headerlink" title="CX60"></a>CX60</h2><p>送个我家猪的w &amp; 入坑作</p><ul><li><strong>套件</strong>：CX60 <em>by 大星</em></li><li><strong>轴体</strong>：Outemu 静音白轴</li><li><strong>键帽</strong>：Menphis</li></ul><p><img src="/images/KBD/wx_camera_1629278155067.jpg" alt="wx_camera_1629278155067"></p><p>不上键帽似乎更好看(?</p><p><img src="/images/KBD/wx_camera_1629706693126.jpg" alt="wx_camera_1629706693126"></p><h2 id="Cheap68"><a href="#Cheap68" class="headerlink" title="Cheap68"></a>Cheap68</h2><p>自己的第一把客制化</p><ul><li><strong>PCB</strong>：KBD67焊接版 <em>by KBDfans怡科</em></li><li><strong>外壳</strong>：Cheap 68</li><li><strong>轴体</strong>：TTC 快银轴</li><li><strong>键帽</strong>：珊瑚海 / Olivia / 微光</li></ul><p><img src="/images/KBD/IMG_20210905_160642.jpg" alt="IMG_20210905_160642"></p><p><img src="/images/KBD/IMG_20210905_164343.jpg" alt="IMG_20210905_164343"></p><p><img src="/images/KBD/IMG_20211128_140753.jpg" alt="IMG_20211128_140753"></p><h2 id="Mr-Hat复刻"><a href="#Mr-Hat复刻" class="headerlink" title="Mr.Hat复刻"></a>Mr.Hat复刻</h2><p>3D打印，自喷漆，自己修改键线分离模块…可以说是付出很多了</p><ul><li><strong>PCB</strong>：KBD8x mk2 <em>by KBDfans怡科</em></li><li><strong>外壳</strong>：Mr.Hat by MatrixLAB 3D打印&amp;自喷漆复刻</li><li><strong>轴体</strong>：集贤 牛紫轴 <em>by 发狗</em></li><li><strong>键帽</strong>：德古拉伯爵 <em>by Akko</em></li></ul><p><img src="/images/KBD/IMG_20211114_135527.jpg" alt="IMG_20211114_135527"></p><p><img src="/images/KBD/wx_camera_1637036762216.jpg" alt="wx_camera_1637036762216"></p><p><img src="/images/KBD/IMG_20211111_131645.jpg" alt="IMG_20211111_131645"></p><p><img src="/images/KBD/IMG_20211111_172345.jpg" alt="IMG_20211111_172345"></p><h3 id="一些小小的改造过程记录…"><a href="#一些小小的改造过程记录…" class="headerlink" title="一些小小的改造过程记录…"></a>一些小小的改造过程记录…</h3><p><img src="/images/KBD/IMG_20211105_083114.jpg" alt="IMG_20211105_083114"></p><p><img src="/images/KBD/IMG_20211025_225444.jpg" alt="IMG_20211025_225444"></p><h2 id="Buff67-v2"><a href="#Buff67-v2" class="headerlink" title="Buff67 v2"></a>Buff67 v2</h2><p>第一把铝坨坨了…</p><ul><li><strong>套件</strong>：Buff67 v2 <em>by MDD</em></li><li><strong>轴体</strong>：Lumia&amp;MMD Cream / HyperGlide BLACK <em>by cherry</em> / KTT 白轴v3 / 草莓酒红</li><li><strong>键帽</strong>：Merlin / 袜子</li></ul><p><img src="/images/KBD/IMG_20211204_102325.jpg" alt="IMG_20211204_102325"></p><p><img src="/images/KBD/IMG_20220116_104041.jpg" alt="IMG_20220116_104041"></p><h2 id="Next-75"><a href="#Next-75" class="headerlink" title="Next 75"></a>Next 75</h2><p>一伯块捡来打游戏的垃圾^ ^</p><ul><li><strong>套件</strong>：Next75 <em>by 老薛</em></li><li><strong>轴体</strong>：RGB Speed Silver <em>by cherry</em></li><li><strong>键帽</strong>：古风仓颉字根</li></ul><p><img src="/images/KBD/IMG_20220716_190525.jpg" alt="IMG_20220716_190525"></p><p><img src="/images/KBD/IMG_20220121_213411.jpg" alt="IMG_20220121_213411"></p><h2 id="JINX-67-powered-by-ZUOER"><a href="#JINX-67-powered-by-ZUOER" class="headerlink" title="JINX 67 powered by ZUOER"></a>JINX 67 powered by ZUOER</h2><p>算是自己半设计了，话是很喜欢这把的</p><ul><li><strong>PCB</strong>：CIY 68</li><li><strong>外壳</strong>：JINX V1/V2 <em>by boulevard</em></li><li><strong>轴体</strong>：Outemu 水蜜桃轴</li><li><strong>键帽</strong>：PBOW <em>by 神婆</em></li></ul><h3 id="JINX-V1"><a href="#JINX-V1" class="headerlink" title="JINX V1"></a>JINX V1</h3><p>镭射版本的</p><p><img src="/images/KBD/IMG_20220327_101958.jpg" alt="IMG_20220327_101958"></p><h3 id="JINX-V2"><a href="#JINX-V2" class="headerlink" title="JINX V2"></a>JINX V2</h3><p>UV磨砂版本的（更耐用&amp;更贵）</p><p><img src="/images/KBD/wx_camera_1652506151486.jpg" alt="wx_camera_1652506151486"></p><p><img src="/images/KBD/IMG_20220427_100407.jpg" alt="IMG_20220427_100407"></p><h3 id="内胆改造"><a href="#内胆改造" class="headerlink" title="内胆改造"></a>内胆改造</h3><p>灰常软弹的自制硅胶粒~</p><p><img src="/images/KBD/IMG_20220815_103133.jpg" alt="IMG_20220815_103133"></p><p><img src="/images/KBD/-6e71f0d90a73400e.jpg" alt="-6e71f0d90a73400e"></p><h2 id="VAST75"><a href="#VAST75" class="headerlink" title="VAST75"></a>VAST75</h2><p>贵还折腾，只能说新人团慎重= =不过外观确实有一手</p><ul><li><strong>套件</strong>：VAST75 <em>by Monster Keith</em></li><li><strong>轴体</strong>：Carol Switch <em>by JWICK</em></li><li><strong>键帽</strong>：SODA <em>by XIAO Studio</em></li></ul><p><img src="/images/KBD/IMG_20220627_191055.jpg" alt="IMG_20220627_191055"></p><p><img src="/images/KBD/wx_camera_1656914188764.jpg" alt="wx_camera_1656914188764"></p><h2 id="Cherry-G80-11900"><a href="#Cherry-G80-11900" class="headerlink" title="Cherry G80-11900"></a>Cherry G80-11900</h2><p>年纪比我还大…但是长得真的好有感觉，老黑处理完也挺不错的</p><ul><li><strong>套件</strong>：Cherry G80-11900</li><li><strong>轴体</strong>：Cherry BLACK</li><li><strong>键帽</strong>：Cherry Original Keycaps</li></ul><p><strong>Old：</strong></p><p><img src="/images/KBD/wx_camera_1658556962286.jpg" alt="wx_camera_1658556962286"></p><p><strong>Brand New：</strong></p><p><img src="/images/KBD/IMG_20220814_190042.jpg" alt="IMG_20220814_190042"></p><p><img src="/images/KBD/IMG_20220814_163859.jpg" alt="IMG_20220814_163859"></p><h2 id="亚克力-Spring"><a href="#亚克力-Spring" class="headerlink" title="亚克力 Spring"></a>亚克力 Spring</h2><ul><li><strong>内胆</strong>：Spring <em>By OWLAB</em></li><li><strong>定位板</strong>：黑芯沉金FR4 <em>by HyperBoring</em></li><li><strong>外壳</strong>：亚克力（暂用）</li><li><strong>轴体</strong>：草莓奶昔缝合轴 / MM Switch <em>by Wuque Studio</em></li><li><strong>键帽</strong>：手稿</li></ul><p><img src="/images/KBD/亚克力spring1.jpg" alt="亚克力spring1"></p><p><img src="/images/KBD/亚克力spring2.jpg" alt="亚克力spring2"></p><h2 id="Spirit-Blossom-Powered-by-ZUOER"><a href="#Spirit-Blossom-Powered-by-ZUOER" class="headerlink" title="Spirit Blossom Powered by ZUOER"></a>Spirit Blossom Powered by ZUOER</h2><p>🐽的第二把也来咯</p><ul><li><strong>PCB</strong>：CIY 68</li><li><strong>外壳</strong>：Spirit Blossom <em>by 紫炁&amp;boulevard</em></li><li><strong>轴体</strong>：灰木V3 <em>by LEOBERG</em></li><li><strong>键帽</strong>：紫罗兰 <em>by SUO</em></li></ul><p><img src="/images/KBD/3d5b1ea20ac892343c1735544d0d0c8.jpg" alt="3d5b1ea20ac892343c1735544d0d0c8"></p><p><img src="/images/KBD/68528fbdfb4a49e0f5be105ca982e40.jpg" alt="68528fbdfb4a49e0f5be105ca982e40"></p><p><img src="/images/KBD/cadaf8beee015f6e757722742a6d04e.jpg" alt="cadaf8beee015f6e757722742a6d04e"></p><h2 id="0xCB-Static"><a href="#0xCB-Static" class="headerlink" title="0xCB Static"></a>0xCB Static</h2><p>主要是被外观、功能、价格吸引了</p><p>一百出头的价格，很独特的电子工业风格、自己焊接所有的元器件，屏幕和小旋钮都有</p><p>可惜学校这把被折腾坏了只能当摆件用了，等寒假把家里的那把组了再玩玩</p><ul><li><strong>套件：</strong>0xCB Static</li><li><strong>轴体：</strong>RK粉轴 <em>by 九紫电子&amp;RK</em></li><li><strong>键帽：</strong>不知名黑透键帽</li></ul><p><img src="/images/KBD/8631281945e7f92ff0a440345cd9e0b.jpg" alt="8631281945e7f92ff0a440345cd9e0b"></p><p><img src="/images/KBD/71914539c5e763c412c334240f05b0f.jpg" alt="71914539c5e763c412c334240f05b0f"></p><h2 id="AMX55木坨坨"><a href="#AMX55木坨坨" class="headerlink" title="AMX55木坨坨"></a>AMX55木坨坨</h2><p>老周送的枫木套件，据说定制一个得400？确实比黑胡桃木好看很多。</p><p>因为是不标准配列，所以自己设计了一张PCB，顺便学习了一下Vial固件的写法<a href="https://blog-boulevard.top/2022/10/24/qmk-vial/">QMK编译+Vial在线改键功能 | Boulevard’s Blog (blog-boulevard.top)</a>。</p><p>不过折腾完40%的Static和50%的这个以后，真的是再也不想碰未成年配列的，基本上用不了…所以就出了</p><ul><li><strong>外壳：</strong>老周定制枫木外壳</li><li><strong>PCB：</strong>amx55 <em>by boulevard</em></li><li><strong>轴体：</strong>集贤白轴V2(送测版) <em>by FaDog</em></li><li><strong>键帽：</strong>手稿 <em>by 锄头</em></li></ul><p><img src="/images/KBD/e4716b76d8ba44d195c30168b31259a.jpg" alt="e4716b76d8ba44d195c30168b31259a"></p><p><img src="/images/KBD/10ea33626ea2168b667ab417629d67f.jpg" alt="10ea33626ea2168b667ab417629d67f"></p><h2 id="Mr-Hat复刻-闪黑"><a href="#Mr-Hat复刻-闪黑" class="headerlink" title="Mr.Hat复刻 闪黑"></a>Mr.Hat复刻 闪黑</h2><p>自喷漆用了一年，表面的黑色部分实在是顶不住了，重新找人做了个闪黑：</p><p><img src="/images/KBD/c9ce15a0fb1e6944337c89d7dd316e5.jpg" alt="c9ce15a0fb1e6944337c89d7dd316e5"></p><p><img src="/images/KBD/04d78c5901a2c93382ea25a6819cd34.jpg" alt="04d78c5901a2c93382ea25a6819cd34"></p><p><img src="/images/KBD/0ecb3434ff9f6b9118079e048206867.jpg" alt="0ecb3434ff9f6b9118079e048206867"></p><p><img src="/images/KBD/ed374227e28d2b29331fbbee4c2456f.jpg" alt="ed374227e28d2b29331fbbee4c2456f"></p><h2 id="PaperPlane-65"><a href="#PaperPlane-65" class="headerlink" title="PaperPlane 65%"></a>PaperPlane 65%</h2><p>在外网看到的，很有工业风设计感，所以就打算自己复刻。</p><p><strong>外壳：</strong>铝合金阳极喷砂工艺，边缘质感比较糙。带有镜面不锈钢配重</p><p><strong>定位板：</strong>铝合金在这个厚度变形太严重，所以换成了Fr-4</p><p><strong>PCB：</strong>用QMK+电磁阀+蜂鸣器+USB HUB+Vial方案制作，由于经费问题，采用的是黄芯紫线</p><p><strong>轴体：</strong>HG红 <em>by Cherry</em></p><p><strong>键帽：</strong>黑同刻-克苏鲁字根 <em>by 星河山川</em></p><p><img src="/images/KBD/d98ffa70af6c528186f075da6cf3fd8.jpg" alt="d98ffa70af6c528186f075da6cf3fd8"></p><p><img src="/images/KBD/c04a35c83c27d8fcda0509dfb512afe.jpg" alt="c04a35c83c27d8fcda0509dfb512afe"></p><p><img src="/images/KBD/bcf87c3bbecd758ef98a4b2ee339f99.jpg" alt="bcf87c3bbecd758ef98a4b2ee339f99"></p><h2 id="QwertyKeys-QK75"><a href="#QwertyKeys-QK75" class="headerlink" title="QwertyKeys QK75"></a>QwertyKeys QK75</h2><p>现在的主力键盘了，虽然设计不多，但是配上这套键帽出奇的好看，硬GAS的手感和轴体也很搭。也算是圆满了我对奶白黑镜的执念。</p><p><strong>轴体：</strong>雪兰灰轴 <em>by AKKO&amp;KTT&amp;XCJZ</em></p><p><strong>定位板：</strong>Fr-4</p><p><strong>键帽：</strong> C64 Dark <em>by AlephKeys</em></p><p><img src="/images/KBD/44ec3c260603dede5d253e1a7f30565.jpg" alt="44ec3c260603dede5d253e1a7f30565"></p><p><img src="/images/KBD/0ce27189c83180c4275dd102136ce5f.jpg" alt="0ce27189c83180c4275dd102136ce5f"></p><p><img src="/images/KBD/543105293eea1bbe46d29ccb929e744.jpg" alt="543105293eea1bbe46d29ccb929e744"></p><p><img src="/images/KBD/5ccb1d877c0ce5480b54c19c4248aa7.jpg" alt="5ccb1d877c0ce5480b54c19c4248aa7"></p><h2 id="Apple-M0110-注塑复刻"><a href="#Apple-M0110-注塑复刻" class="headerlink" title="Apple M0110 注塑复刻"></a>Apple M0110 注塑复刻</h2><p>两百多的价格，HHKB配列复古造型、无钢、电磁阀，可以说是一把很合格的复古玩具了，无钢茶轴确实也很舒服。</p><p><strong>轴体：</strong>Cherry Brown</p><p><strong>填充：</strong>AB硅胶+Poron</p><p><strong>键帽：</strong>复古键帽 俄文字根  <em>by 星河山川</em> + Caps 9009灯帽 <em>by EPBT</em></p><p><strong>个性：</strong>麦金塔</p><p><img src="/images/KBD/402f5cf3cb2b92f4b4dffc92906533d.jpg" alt="402f5cf3cb2b92f4b4dffc92906533d"></p><p><img src="/images/KBD/5471860c321ad27df849d8a6214650e.jpg" alt="5471860c321ad27df849d8a6214650e"></p><p><img src="/images/KBD/62c99344a60316089300e5b77914fdf.jpg" alt="62c99344a60316089300e5b77914fdf"></p><h2 id="炁-65-PCB"><a href="#炁-65-PCB" class="headerlink" title="炁 65% PCB"></a>炁 65% PCB</h2><p>两把zuoer用的CIY68 pcb在无线方面实在是太差劲了，而且老是抽风，所以用假期时间又用优联方案制作了一套代替PCB。</p><p>主控采用的是罗技k580的主控，优点是便宜，缺点是不像k375s主控自带排线接口，很方便接线，需要自己设计转接板来接线。第一次弄转接板的时候焊盘嘎嘎掉，差点给我心态弄爆炸了。</p><p><img src="/images/KBD/9056240104e7f405c4e802dc2487de7.jpg" alt="9056240104e7f405c4e802dc2487de7"></p><p>还有一个缺点就是不能改键，68配列的F区都需要使用多路复用器来实现，真·物理切层（反正CIY也好不到哪去）。</p><p><img src="/images/KBD/9eeacb13aba905bb1815c4b7ca472ee.jpg" alt="9eeacb13aba905bb1815c4b7ca472ee"></p><p>做好的板子印上Logo还是很帅的，锂电池充放电模块转移到了PCB上面，节省键盘内部空间，当然为了保留兼容性，还是设计了外接电池模块的接口。</p><p>配列也做到了多佩列兼容，支持小门牙67、阶梯Caps和7回。</p><p>最大的优点还是罗技优联的强大功能，连接稳定性高的同时耗电量非常的低、同时休眠以后的唤醒完全无延迟。</p><h2 id="CIY-GAS67外壳"><a href="#CIY-GAS67外壳" class="headerlink" title="CIY-GAS67外壳"></a>CIY-GAS67外壳</h2><p>实在不忍心看战损的JINX zuoer在包里挤来挤去了，换一个外壳和键帽，没想到都是两位数的外壳和键帽还挺好看的，就是外壳开关位置有点不兼容，只能短接常开了…</p><p><strong>PCB：</strong>炁 65%</p><p><strong>轴体：</strong>Box冰淇淋Pro静音轴 <em>by 凯华</em></p><p><strong>键帽：</strong>pagy 红半透 <em>by 爱菲</em> </p><p><img src="/images/KBD/image-20230322170536696.png" alt="image-20230322170404605"></p><p><img src="/images/KBD/image-20230322170506883.png" alt="image-20230322170408098"></p><p><img src="/images/KBD/QQ图片20230322170623.jpg" alt="QQ图片20230322170623"></p><h3 id="爱菲Vior键帽"><a href="#爱菲Vior键帽" class="headerlink" title="爱菲Vior键帽"></a>爱菲Vior键帽</h3><p>三个月以后，ABSFans的键帽已经比我的脸还油了…于是换上了闪粉版本的</p><p><img src="/images/KBD/a395f6a93d53fe36423d6d01523b28b.jpg" alt="a395f6a93d53fe36423d6d01523b28b"></p><p><img src="/images/KBD/bcf79f5f9ca628f75616814a948c6ae.jpg" alt="bcf79f5f9ca628f75616814a948c6ae"></p><p>（但愿这次能用久一点…</p><h2 id="Sugar-80"><a href="#Sugar-80" class="headerlink" title="Sugar 80"></a>Sugar 80</h2><p>去年的老东西了，🐎宝说他喜欢这种简约外壳就给弄了…不得不说，配出来真的很妹妹风。灰木V4比V3可舒服太多了</p><p><strong>外壳：</strong>Tiger80 lite <em>by KBDFans</em></p><p><strong>PCB：</strong>Y&amp;R 80 黑芯绿油 水果湖复刻</p><p><strong>键帽：</strong></p><ul><li>主体：PBOW</li><li>淡紫色部分：素白增补 <em>by milkway</em></li><li>R1其他键位：薰衣草 <em>by 锄头</em></li></ul><p><strong>轴体：</strong>灰木V4</p><p><img src="/images/KBD/image-20230801200953456.jpg" alt="image-20230801200953456"></p><p><img src="/images/KBD/image-20230801201000491.jpg" alt="image-20230801201000491"></p><h2 id="VGN-S99"><a href="#VGN-S99" class="headerlink" title="VGN S99"></a>VGN S99</h2><p>给🐍÷的游戏键盘，看中了VGN的低延迟无线。现在的键圈真的是越来越卷了啊…319的成品能有这个设计和内胆</p><ul><li><strong>轴体：</strong>草莓奶昔 <em>by SaroKeys</em></li><li><strong>键帽：</strong>KCA柠七 <em>by 森美</em></li></ul><p><img src="/images/KBD/image-20230827213720670.jpg" alt="image-20230827213720670"></p><p><img src="/images/KBD/image-20230827213834842.jpg" alt="image-20230827213834842"></p><p><img src="/images/KBD/image-20230827213829714.jpg" alt="image-20230827213829714"></p><p><img src="/images/KBD/image-20230827213823455.jpg" alt="image-20230827213823455"></p><h2 id="究极无敌复古缝合（半成品）"><a href="#究极无敌复古缝合（半成品）" class="headerlink" title="究极无敌复古缝合（半成品）"></a>究极无敌复古缝合（半成品）</h2><p>缝合了Hans80的正面与Class80的背面、还有Suit80内胆（<del>三个原版都买不起</del>），属于是究极缝合</p><p>打印出来的外壳有误差很大用不了，暂且搁置了。·        `</p><p><img src="/images/KBD/5ef4dc1c17fa0028dfcfc1f7bc2ee2b.jpg" alt="5ef4dc1c17fa0028dfcfc1f7bc2ee2b"></p><p><img src="/images/KBD/ffa4cd21c9724fef3998dae3d0448b2.jpg" alt="ffa4cd21c9724fef3998dae3d0448b2"></p><h2 id="INFI-75-Keepout"><a href="#INFI-75-Keepout" class="headerlink" title="INFI 75 Keepout"></a>INFI 75 Keepout</h2><p>实验室买的量产，键帽配色不错，设计也不错，就是屏幕是败笔、以及外壳质量不太好。</p><ul><li>换 EPDM 底棉 &amp; FR4 定位板</li><li><strong>轴体：</strong>心海轴 <em>by HMX</em></li></ul><p><img src="/images/KBD/image-20240618161314596.jpg" alt="image-20240618161314596"></p><p><img src="/images/KBD/image-20240618161329599.jpg" alt="image-20240618161329599"></p><h2 id="Yu75"><a href="#Yu75" class="headerlink" title="Yu75"></a>Yu75</h2><p>挺好看的一把黑胡桃木坨坨，去掉底棉声音不差的同时手感很弹，可惜乌拉的三模 PCB 太拉了。</p><ul><li><strong>轴体：</strong>鲸落轴 <em>by 狼蛛&amp;SWK</em></li><li><strong>键帽：</strong>宇航员 <em>by KeyBye Lab</em></li></ul><p><img src="/images/KBD/image-20240618161534633.jpg" alt="image-20240618161534633"></p><p><img src="/images/KBD/image-20240618161549252.jpg" alt="image-20240618161549252"></p><h2 id="YuPad-amp-Yu65"><a href="#YuPad-amp-Yu65" class="headerlink" title="YuPad  &amp; Yu65"></a>YuPad  &amp; Yu65</h2><p>参与开团的两把键盘，虽然只做了 PCB 但也算是圆满了，捞到了自己在键圈的第一桶金（估计也是最后一桶了）</p><p><img src="/images/KBD/image-20240618161717869.jpg" alt="image-20240618161717869"></p><p><img src="/images/KBD/image-20240618161738697.jpg" alt="image-20240618161738697"></p><p><img src="/images/KBD/image-20240618161800578.jpg" alt="image-20240618161800578"></p><h2 id="Neo-80"><a href="#Neo-80" class="headerlink" title="Neo 80"></a>Neo 80</h2><p>进入 Neo 时代咯，OG 的内胆和亚麻喷涂白真的很让人喜欢。</p><ul><li><strong>轴体：</strong>HG Black <em>by Cherry</em></li><li><strong>键帽1：</strong>C64 Dark <em>by AlephKeys</em></li><li><strong>键帽2</strong>：Game1989 <em>by TUTKeys</em></li></ul><p><img src="/images/KBD/image-20240618162058033.jpg" alt="image-20240618162058033"></p><p><img src="/images/KBD/image-20240618162109595.jpg" alt="image-20240618162109595"></p><p><img src="/images/KBD/image-20240618162130858.jpg" alt="image-20240618162130858"></p><p><img src="/images/KBD/image-20240618162141605.jpg" alt="image-20240618162141605"></p><p><img src="/images/KBD/image-20240618162149648.jpg" alt="image-20240618162149648"></p><h2 id="Purest-75"><a href="#Purest-75" class="headerlink" title="Purest 75"></a>Purest 75</h2><p>典🐶的恶心人巨制，买到老赖的键盘了…不过氪总的结构设计还是有手的。</p><p><strong>轴体：</strong>紫薇轴 <em>by WOB&amp;HMX</em></p><p><strong>键帽：</strong>无刻混灯 <em>by 爱菲</em></p><p><img src="/images/KBD/image-20240619100206110.png" alt="image-20240619100206110"></p><h2 id="Crush-80"><a href="#Crush-80" class="headerlink" title="Crush 80"></a>Crush 80</h2><p>量产铝坨坨，不得不说619成品的价格，这个设计和质感都非常超模，可惜就是营销和售后都太过恶心…</p><p><img src="/images/KBD/image-20240618162254159.jpg" alt="image-20240618162254159"></p><p><img src="/images/KBD/image-20240618162302566.jpg" alt="image-20240618162302566"></p><h2 id="Neo-Ergo"><a href="#Neo-Ergo" class="headerlink" title="Neo Ergo"></a>Neo Ergo</h2><p>亚克力 spring 以后再次尝试 alice 配列，指法进步了用起来还挺顺手。Neo 一贯的简约质感外观真的很讨喜，手机拍不出来这个深空灰的美，只好借舍友的相机来拍了。</p><ul><li>轴体：HG雪松轴 <em>by 7min Lab&amp;地瓜外设&amp;力驰创新</em></li><li>键帽：宇航员 <em>by KeyBye Lab</em></li></ul><p><img src="/images/KBD/image-20240618162552127.jpg" alt="image-20240618162552127"></p><p><img src="/images/KBD/image-20240618162649520.jpg" alt="image-20240618162649520"></p><h2 id="Mad60HE"><a href="#Mad60HE" class="headerlink" title="Mad60HE"></a>Mad60HE</h2><p>成为瓦批以后，发现在松手急停这块磁轴还是非常有用的，于是入了一把入门级别的磁轴 Mad60HE。</p><ul><li>轴体：磁珀轴pro</li><li>键帽：爱菲百灯拼的黑灯</li></ul><p><img src="/images/KBD/image-20241118124717470.png" alt="image-20241118124717470"></p><h3 id="改Null64外壳"><a href="#改Null64外壳" class="headerlink" title="改Null64外壳"></a>改Null64外壳</h3><p>这个仿wooting的飘带+斜坡设计外壳实在是受不了（至今无法理解wooting的价格和外观，可能是我不够潮吧^ ^），而这套pcb是标准GH60孔位的，所以就物色了很久外壳，最后意外发现之前用过的NULL64支持，然后在闲鱼收了一个巴西花梨木的套件。</p><p><img src="/images/KBD/image-20241118125709699.png" alt="image-20241118125709699"></p><p><img src="/images/KBD/image-20241118125714965.png" alt="image-20241118125714965"></p><p>键帽就没换了，只能说勉勉强强不是很搭也不丑，附上一张牢钊的NULL64的搭配：</p><p><img src="/images/KBD/image-20241118125749067.png" alt="image-20241118125749067"></p><h2 id="QK80mk2"><a href="#QK80mk2" class="headerlink" title="QK80mk2"></a>QK80mk2</h2><p>qk在QK65v2、QK75N、QK100等键盘中对屏幕像是魔怔了，强行把质感和设计与量产无异的屏幕加到键盘上，显得很廉价和生硬。所以本来买的是Taku65 reboot，打算玩一玩小屏幕的。结果过程中出了个QK80mk2，感觉屏幕的设计和功能性完爆之前的QK，再加上Taku的发货时间、补偿方案不合理、以及可以zf官方转单等，出掉了taku65上小黄鱼收了吧QK80mk2。</p><ul><li>轴体：心海轴 <em>by hmx</em></li><li>键帽：百灯 <em>by amk</em></li></ul><p><img src="/images/KBD/image-20241118130300153.png" alt="image-20241118130300153"></p><p><img src="/images/KBD/image-20241118130313959.png" alt="image-20241118130313959"></p><p><img src="/images/KBD/image-20241118130321259.png" alt="image-20241118130321259"></p><p><img src="/images/KBD/image-20241118130341327.png" alt="image-20241118130341327"></p><h2 id="nano68"><a href="#nano68" class="headerlink" title="nano68"></a>nano68</h2><p>在入了磁轴而且打瓦越来越熟练以后，打算把Mad60HE送给某🐷，然后自己入一把其他的磁轴。</p><p>一开始考虑的是小蜜蜂的Made68，但是塑料外壳卖899的价格，以及最难绷的是：灯带只支持单色光，想要其他颜色的灯光需要79块钱买一个半透明灯罩？只能说小蜜蜂还是那个1000块钱买一个Mojo的小蜜蜂。</p><p>然后在小蜜蜂没有什么用的律师函下，nano68诞生了，光是不用换灯罩可以自定义RGB色彩、甚至还能有彩虹流光效果这一点就薄纱前者了。</p><ul><li>轴体：封底磁银轴 &amp; 少数万磁王轴</li><li>键帽：C64 Dark <em>by alephkeys</em></li></ul><p><img src="/images/KBD/image-20241118130813272.png" alt="image-20241118130813272"></p><p>一开始一位这样一把主打RGB灯箱外观的键盘需要搭配科技风键帽，没想到尝试性的换上了我的传家宝C64Dark以后居然有种莫名的高级感。</p><p><img src="/images/KBD/image-20241118130739582.png" alt="image-20241118130739582"></p><p><img src="/images/KBD/image-20241118130748171.png" alt="image-20241118130748171"></p><h2 id="lucky65v2"><a href="#lucky65v2" class="headerlink" title="lucky65v2"></a>lucky65v2</h2><p>200出头的快拆铝，海棠紫的颜色在量产里面算比较好看的</p><ul><li>轴体：hg雪松轴 &amp; hmx雪花轴</li><li>键帽：薄荷糖紫色希腊文</li></ul><p><img src="/images/KBD/301736338021_.pic_hd.jpg" alt="301736338021_.pic_hd"></p><p><img src="/images/KBD/311736338023_.pic_hd.jpg" alt="311736338023_.pic_hd"></p><p><img src="/images/KBD/321736338030_.pic_hd.jpg" alt="321736338030_.pic_hd"></p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客制化键盘 </tag>
            
            <tag> DIY </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOL台服代挂</title>
      <link href="/2023/06/30/LOL%E5%8F%B0%E6%9C%8D%E4%BB%A3%E6%8C%82/"/>
      <url>/2023/06/30/LOL%E5%8F%B0%E6%9C%8D%E4%BB%A3%E6%8C%82/</url>
      
        <content type="html"><![CDATA[<p>众所周知，除了<del>没</del>马服以外，拳头的自营服会在观赛直播间送出<strong>观赛引擎</strong>，而观赛引擎开多了就会出现很多重复的头像/表情，可以分解为橙色精粹。</p><p>于是小黄鱼上就出现了很多代挂，低至5元/月，高到30/月。</p><p>由于小黄鱼的卖家要么不太靠谱，要么收费太贵，于是决定根据他们的截图顺藤摸瓜去找找有没有开源的代挂，果不其然找到了两个：</p><ul><li><a href="https://github.com/LeagueOfPoro/CapsuleFarmerEvolved">LeagueOfPoro/CapsuleFarmerEvolved</a></li><li><a href="https://github.com/Yudaotor/EsportsHelper">Yudaotor/EsportsHelper</a></li></ul><p>第一个是一个老外做的，但是在2023年3月的时候被Riot律师函了，所以现在已经停止维护了。</p><p>第二个是国人做的，截至目前（2023-7）还在维护，而且可用性也相对较好，所以用这个。</p><h2 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h2><p>首先考虑的肯定是在宿舍的笔记本上配置，Github上可以直接从releases下载exe包，到config里面配置一下就可以跑，很方便。只不过是外服的观赛，所以需要先挂个梯子。</p><p>但是一天下来就发现了不对劲，直接跑了3G流量，VPN+校园网流量的双重收费实在是顶不住这么造。</p><p>所以考虑不如直接租一个海外的高带宽服务器。</p><p>于是在tx云上买了一个 2核4G 30m带宽每月1000G流量的服务器，地址在新加坡，耗费42元/月。先观察一下这个月的情况，再决定是否要修改配置。</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>这个库是经典的selenium + chrome_driver的web脚本，所以需要先配置好环境，作者自己写的教程：</p><p><a href="https://github.com/Yudaotor/EsportsHelper/wiki/如何在linux环境运行（run-in-linux）">如何在linux环境运行（run in linux） · Yudaotor/EsportsHelper Wiki (github.com)</a></p><p>大差不差，但是这个教程用的是pipenv虚拟环境，而这个环境在ubuntu上真的是巨容易报错，所以稍微修改和完善了流程，用conda。</p><h3 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h3><p>服务器的Ubuntu是纯命令行，但这并不代表其不能安装浏览器，chrome支持headless模式，不在前端运行。</p><p><code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code>下载最新的chrome包，此时运行<code>sudo dpkg -i google-chrome-stable_current_amd64.deb</code>会有依赖报错，下面是解决方法：</p><p>先<code>sudo apt -f -y install</code>安装依赖，然后再次<code>sudo dpkg -i google-chrome-stable_current_amd64.deb</code>即可安装完成。</p><p>完成以后输入<code>google-chrome --version</code>，应该是可以看到的。此时Chrome就安装好了。</p><h3 id="配置python环境"><a href="#配置python环境" class="headerlink" title="配置python环境"></a>配置python环境</h3><p>万恶的pipenv全是bug，推荐使用conda，这里建议安装miniconda即可，没必要用那么臃肿的anaconda。安装方法自行百度，非常多。</p><p>然后创建一个新的python虚拟环境，需要指定python版本，3.6版本太低依赖装不上，目前用的是3.9：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda ceate -n esHelper python=3.9</span><br></pre></td></tr></table></figure><p>安装好以后，activate进入环境，克隆Github库并进入，然后安装python依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="配置config"><a href="#配置config" class="headerlink" title="配置config"></a>配置config</h2><p>config文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">delay:</span> <span class="number">600</span>                <span class="comment"># 每次检查的时间间隔，单位为秒(默认为600秒)(每次检测时间会在你设置的时延0.8-1.5倍之间随机波动) / Time interval for each check in seconds (600 seconds by default). Each check time will randomly range between 0.8 and 1.5 times the time delay you set</span></span><br><span class="line"><span class="attr">headless:</span> <span class="literal">True</span>           <span class="comment"># 设置为True时，程序会在后台运行，否则会打开浏览器窗口(默认为False) / # When set to True, the program will run in the background; otherwise it will open a browser window (set False by default)</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">&quot;账号&quot;</span>     <span class="comment"># 必填，账号 / Required field, username</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">&quot;密码&quot;</span>          <span class="comment"># 必填，密码 / Required field, passward</span></span><br><span class="line"><span class="attr">nickName:</span> <span class="string">&quot;&quot;</span>              <span class="comment"># 绰号, 不填即为用户名. / NickName. default is username.</span></span><br><span class="line"><span class="attr">maxStream:</span> <span class="number">3</span>              <span class="comment"># 最大同时观看比赛数.默认为3 / Maximum number of matches to be watched simultaneously. Default is 3.</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">&quot;zh_CN&quot;</span>         <span class="comment"># 语言选择，zh_CN是简体中文，en_US是英文, zh_TW是繁体中文 / Language selection, zh_CN for Chinese (Simplified), en_US for English,zh_TW for Chinese (Traditional)</span></span><br><span class="line"><span class="attr">autoSleep:</span> <span class="literal">False</span>          <span class="comment"># 是否自动休眠,即没比赛时自动休眠，有比赛时自动唤醒(默认为False) / Whether to sleep automatically, that is, to sleep automatically when there is no match, and to wake up automatically when there is a match (default is False)</span></span><br><span class="line"><span class="attr">onlyWatchMatches:</span> [<span class="string">&quot;lcs&quot;</span>,<span class="string">&quot;lla&quot;</span>,<span class="string">&quot;lpl&quot;</span>,<span class="string">&quot;lck&quot;</span>,<span class="string">&quot;ljl-japan&quot;</span>,<span class="string">&quot;lco&quot;</span>,<span class="string">&quot;lec&quot;</span>,<span class="string">&quot;cblol-brazil&quot;</span>,<span class="string">&quot;pcs&quot;</span>,<span class="string">&quot;tft_esports&quot;</span>]   <span class="comment"># 只观看的赛区名称,小写. / # The name of the league to be watched only, lowercase.</span></span><br><span class="line"><span class="attr">platForm:</span> <span class="string">&quot;linux&quot;</span></span><br><span class="line"><span class="attr">connectorDropsUrl:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>主要需要修改如下几项：</p><ol><li>headless：设置为True，也就是chrome不显示前端运行，一方面是服务器纯命令行没法展示前端，另一方面是减少CPU占用。关于这个模式会不会更容易被封号，在issue中提问作者说问题不大</li><li>username、password</li><li>platForm：默认是windows，改为linux</li><li>connectorDropsUrl：这个是掉落提醒的链接，钉钉、Discord等软件中都有机器人，将机器人的Webhook填入以后，只要掉落了，机器人就会提醒。</li></ol><p>配置好以后<code>python main.py</code>运行即可</p><h2 id="设置webhook"><a href="#设置webhook" class="headerlink" title="设置webhook"></a>设置webhook</h2><p>在discord和钉钉群聊中都可以添加机器人，然后复制其Webhook填入到上面的config就可以了。</p><p>要注意的是钉钉的机器人需要配置安全认证，这里配置按照IP地址认证，填入服务器公网IP即可</p><h2 id="tmux后台"><a href="#tmux后台" class="headerlink" title="tmux后台"></a>tmux后台</h2><p>服务器上运行这种后台长时间待机任务都要用tmux，使用apt安装以后，创建一个tmux回话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s esHelper</span><br></pre></td></tr></table></figure><p>到会话中激活conda环境，运行main.py，然后就可以挂起到后台运行了：首先按一下<code>ctrl + b</code>，然后按一下<code>d</code>即可。</p><p>如果想要重新进去看看情况，可以用<code>tmux attach -t esHelper</code>进入查看和操作。</p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置esp-idf环境</title>
      <link href="/2023/04/25/%E9%85%8D%E7%BD%AEesp-idf%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/04/25/%E9%85%8D%E7%BD%AEesp-idf%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>esp32开发环境主流有三种：esp-idf、micropython、arduino：</p><ul><li>esp-idf：官方出品，使用C语言编辑，环境比较难装，不过集成了很多库还是不错。</li><li>micropython：没了解太多，不过python语法比C还是友好很多。</li><li>arduino：arduino的类C开发语言，比直接用嵌入式C开发简单，而且有巨大的arduino生态支持。</li></ul><p>虽然怎么看micropython和arduino都很香，但是无奈这次需要用到SM2椭圆曲线，看到的几个esp32上跑ecc的代码主要都在esp-idf上。本来就是刚入门，要是开发环境还和网上资料不一样的话感觉要寄…所以<strong>最终选择了ESP-IDF</strong>。</p><h2 id="（已放弃）Windows配置ESP-IDF"><a href="#（已放弃）Windows配置ESP-IDF" class="headerlink" title="（已放弃）Windows配置ESP-IDF"></a>（已放弃）Windows配置ESP-IDF</h2><h3 id="直接安装本地ESP-IDF-VSCode"><a href="#直接安装本地ESP-IDF-VSCode" class="headerlink" title="直接安装本地ESP-IDF + VSCode"></a>直接安装本地ESP-IDF + VSCode</h3><p><a href="https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/install.md">vscode-esp-idf-extension/install.md at master · espressif/vscode-esp-idf-extension · GitHub</a></p><p>看似很简单，直接在VSCode中下载插件，插件可以自动安装好环境（当然也可以先安装ESP-IDF，然后到VSCode中识别已有环境），然后就可以在VSCode里面进行编译/调试。</p><p>但是实际上ESP-IDF本并不适合在Windows本地装，编译速度比Linux慢5倍左右且不说。在Windows本地安装了好几遍不同版本的IDF，到最后编译HelloWorld工程的时候都会编译失败。</p><p>上网一查，很多人都遇到这个问题，可能是因为IDF的主程序是IDF.py，而Windows上面之前配过的python环境产生了一些冲突。在全新的Windows或者Linux系统下配置IDF编译就都没问题。</p><p>故放弃Windows本地的ESP-IDF</p><h3 id="Docker-WSL2-VSCode-Remote-WSL2串口工具"><a href="#Docker-WSL2-VSCode-Remote-WSL2串口工具" class="headerlink" title="Docker+WSL2+VSCode Remote+WSL2串口工具"></a>Docker+WSL2+VSCode Remote+WSL2串口工具</h3><p>然后就看到有人说WSL2+Docker+VSCode Remote+WSL2串口工具可以很方便的配置环境。</p><p>看了一下例子，不是那么方便…不过本地实在是配不好了，就考虑去试试。</p><p>然后最脑瘫的来了^ ^：</p><p>一打开我多年未动的WSL2和Docker Desktop居然发现他们寄了。仔细一想好像是这学期初装VBox的时候把Hyper-V虚拟化关掉了，然后一顿操作打开Hyper-V复活WSL2和Docker，我的VBox与VMWare又寄了…没办法这学期要做实验，只能老老实实删了WSL2和Docker，关闭Hyper-V，配了半天恢复原样</p><p>只能说和Hyper-V沾点的东西还是少去碰…</p><h2 id="Ubuntu虚拟机配置ESP-IDF-VSCode"><a href="#Ubuntu虚拟机配置ESP-IDF-VSCode" class="headerlink" title="Ubuntu虚拟机配置ESP-IDF+VSCode"></a>Ubuntu虚拟机配置ESP-IDF+VSCode</h2><h3 id="安装ESP-IDF"><a href="#安装ESP-IDF" class="headerlink" title="安装ESP-IDF"></a>安装ESP-IDF</h3><p>之前不是有人说在没配过Python环境的系统上随便配吗，既然到Windows上面跑是彻底泡汤了，那就直接开一个Ubuntu虚拟开装吧：</p><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.0.1/esp32/get-started/linux-macos-setup.html#get-started-prerequisites">Linux 和 macOS 平台工具链的标准设置 - ESP32 - — ESP-IDF 编程指南 v5.0.1 文档 (espressif.com)</a></p><p>由于是全新的虚拟机环境，装的过程还是很顺利地，开个连GitHub很稳定的加速器，跟着上文一顿输入脚本就行。</p><p>需要注意的是，ESP-IDF有很多环境变量，需要运行<code>$HOME/esp/esp-idf/export.sh</code>来导入配置。由于这些环境变量实在是太多了，所以写入到<code>~/.bashrc</code>里面又不是很合适，于是可以到<code>~/.bashrc</code>中加入一个运行<code>export.sh</code>的快捷命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias get_idf=&#x27;. $HOME/esp/esp-idf/export.sh&#x27;</span><br></pre></td></tr></table></figure><p>这样每次打开终端，只需要输入一句<code>get_idf</code>就激活idf环境了。</p><h3 id="简单使用IDF"><a href="#简单使用IDF" class="headerlink" title="简单使用IDF"></a>简单使用IDF</h3><p>随便搞一个工程，比如<code>hello_world</code>，进入到终端激活idf环境，首先可以设置目标芯片：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/esp/hello_world</span><br><span class="line">idf.py set-target esp32</span><br><span class="line">idf.py menuconfig</span><br></pre></td></tr></table></figure><p>menuconfig中会弹出来一个和电脑BIOS一样简陋的界面，可以到里面配置ESP32的一些设置，比如WIFI配置、处理器速度等等。</p><p>配置好以后，运行<code>idf.py build</code>即可编译出bin文件，总之，如果没有VSCode等IDE，就需要在终端中使用<code>idf.py</code>对工程操作。</p><h3 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h3><p>这个和在Windows上大差不差，安装插件，配置插件的时候选择之前安装好的IDF即可。</p><h3 id="烧录ESP32"><a href="#烧录ESP32" class="headerlink" title="烧录ESP32"></a>烧录ESP32</h3><p>虽然是在虚拟机上面，但是实际上和直接烧录大差不差（夸一夸VMWare做的还是挺好的，不像垃圾VBox^ ^）</p><p>注：如下设置方法仅支持ESP32 DevKitC v4通过USB烧录</p><ol><li>不插入ESP32，首先在终端输入<code>ls /dev/tty*</code></li><li>插入ESP32，VMWare会提示要把USB设备放在主机还是虚拟机使用，选择虚拟机</li><li>再次输入<code>ls /dev/tty*</code>，比第一次多出来的的就是你选的设备（我这里叫ttyUSB0）</li><li>使用<code>sudo code .</code>打开VSCode；或者<code>sudo chmod 777 /dev/ttyUSB0</code>（这一步是为了防止没有权限访问串口）</li><li>在VSCode左下角修改串口，选择步骤3中确定的串口</li><li>VSCode左下角第二个esp32，选择型号，我这里选择<code>esp32 &gt; esp32 with USB bridge</code>，也就是通过USB通信的esp32开发板</li><li>点击<code>编译-烧录-监视</code>（也就是一个火苗的图标）。第一次执行编译完毕以后，会让你选择烧录方式，选<code>UART</code>，然后开始烧录，按一下ESP32上面的<code>BOOT按键</code>，出现烧录进度。烧录完毕以后会自动打开监视界面。</li></ol><p>如果你没有开发板，而想要验证程序，可以在<a href="https://wokwi.com/projects/305457271083631168">esp32-bin-file.ino - Wokwi Arduino and ESP32 Simulator</a>上传bin文件仿真。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>监听HTTPS加密流量</title>
      <link href="/2023/04/23/%E7%9B%91%E5%90%ACHTTPS%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F/"/>
      <url>/2023/04/23/%E7%9B%91%E5%90%ACHTTPS%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Charles抓包软件"><a href="#安装Charles抓包软件" class="headerlink" title="安装Charles抓包软件"></a>安装Charles抓包软件</h2><p><a href="https://www.52pojie.cn/thread-1600964-1-1.html">网络抓包工具Charles 4.5.6 中文版(Windows便携免安装) - 『逆向资源区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p>安装破解即可</p><h2 id="启用SSL代理"><a href="#启用SSL代理" class="headerlink" title="启用SSL代理"></a>启用SSL代理</h2><h3 id="安装根证书"><a href="#安装根证书" class="headerlink" title="安装根证书"></a>安装根证书</h3><p><code>帮助 &gt; SSL代理 &gt; 安装Charles根证书</code>：</p><p>点击安装证书（I）：</p><p><img src="/images/charlesHTTPS/image-20230423201826079.png" alt="image-20230423201826079"></p><p>选择当前计算机，下一页，将证书存储到受信任的根证书颁发机构：</p><p><img src="/images/charlesHTTPS/image-20230423201921773.png" alt="image-20230423201921773"></p><p>安装完成</p><h3 id="安装浏览器证书"><a href="#安装浏览器证书" class="headerlink" title="安装浏览器证书"></a>安装浏览器证书</h3><p><code>帮助 &gt; SSL代理 &gt; 在移动设备或远程浏览器上安装Charles根证书</code>，会弹出一个保存页面，随便找个位置保存。</p><p>浏览器设置中搜索“证书”，进入证书添加页面加入保存的证书即可。</p><h2 id="测试HTTPS抓包"><a href="#测试HTTPS抓包" class="headerlink" title="测试HTTPS抓包"></a>测试HTTPS抓包</h2><p><code>代理 &gt; SSL代理设置 &gt; 包括</code>加入一条<code>*:*</code></p><p>然后开启SSL，访问一个HTTPS网页，发现可以抓包并解密：</p><p><img src="/images/charlesHTTPS/image-20230423202307163.png" alt="image-20230423202307163"></p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win11引导丢失翻车记录</title>
      <link href="/2023/03/24/Win11%E5%BC%95%E5%AF%BC%E4%B8%A2%E5%A4%B1%E7%BF%BB%E8%BD%A6%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/03/24/Win11%E5%BC%95%E5%AF%BC%E4%B8%A2%E5%A4%B1%E7%BF%BB%E8%BD%A6%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>随意记录一下一次翻车过程</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>双硬盘，一个为基本磁盘，一个为动态磁盘，但是装Ubuntu双系统的时候好像识别不到动态磁盘，所以就用傲梅把动态转为了基本，结果开机直接丢失引导</p><h2 id="尝试过程"><a href="#尝试过程" class="headerlink" title="尝试过程"></a>尝试过程</h2><p>既然没有引导，那肯定就只能先弄个PE启动盘了</p><h3 id="老毛桃PE"><a href="#老毛桃PE" class="headerlink" title="老毛桃PE"></a>老毛桃PE</h3><p>做一个老毛桃PE，进去以后有MBR修复，修复完成以后重启还是不行</p><h3 id="Win11PE"><a href="#Win11PE" class="headerlink" title="Win11PE"></a>Win11PE</h3><p>做一个Win11安装PE，进去以后有引导修复，提示无法修复</p><p>那么打开PE的命令提示符工具，依次输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class"><span class="title">chkdsk</span> /<span class="title">r</span></span></span><br><span class="line"><span class="class"><span class="title">SFC</span> /<span class="title">SCANNOW</span></span></span><br><span class="line"><span class="class"><span class="title">BOOTREC</span> /<span class="title">SCANOS</span></span></span><br><span class="line"><span class="class"><span class="title">BOOTREC</span> /<span class="title">FIXMBR</span></span></span><br><span class="line"><span class="class"><span class="title">BOOTREC</span> /<span class="title">FIXBOOT</span></span></span><br><span class="line"><span class="class"><span class="title">BOOTREC</span> /<span class="title">REBUILDBCD</span></span></span><br></pre></td></tr></table></figure><p>结果还是不行…事实上，事情远不是丢失引导这么简单</p><h3 id="万能的TB"><a href="#万能的TB" class="headerlink" title="万能的TB"></a>万能的TB</h3><p>TB找了好几家店，几家都不能修说只能操作系统，直到遇到了一家高手给我解释原因：动态磁盘类似组了RAID，两个磁盘是关联的，那么，关闭到以后自然无法读取到很多信息，包括引导</p><p>然后根据我发过去的，坏之前我的硬盘分区，老板远程用diskgenius扫描分区，对于扫描出来的分区有的采纳、有的忽略（我也不知道怎么判断的），最后把所有分区都恢复了出来并重建了引导</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ol><li>动态、raid等不要乱改动</li><li>作死之前，先备份分区表和引导</li></ol>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻车 </tag>
            
            <tag> 引导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暴力破解压缩包密码--John the Ripper/HashCat</title>
      <link href="/2023/03/24/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%86%E7%A0%81-John-the-Ripper-HashCat/"/>
      <url>/2023/03/24/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%86%E7%A0%81-John-the-Ripper-HashCat/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>某实验课程，四节课要啰嗦大概两节课的时间，且实验指导书设置了”Cst.******“（*为0-9/a-z/A-Z）的密码，网上随便下一个密码破解工具会很难破解（显示时间&gt;一年），所以想寻求一些高效的破解方法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>John the Ripper（以下简称JtR）：此工具有John和file2john两种子工具<ul><li>file2john会识别文件特征，提取出一串哈希值，如：运行<code>zip2john test.zip</code>会得到类似<script type="math/tex">pkzip2$1*1*...d*$/pkzip2</script>，虽然是哈希值，但是这玩意可以很大（比如我提取出来6M的哈希值文件），具体原理未知</li><li>John主程序会对上面的哈希值进行密码爆破，计算密码的哈希与其比对</li></ul></li><li>HashCat：此工具类似JtR的John，可以爆破密码哈希值与输入的哈希值比对，但是不能单独用于密码破解，需要用file2john提取特征哈希以后才可以破解</li></ul><p>两种工具都有尝试，且成功配好，但是都有其应用上的限制，建议两个都准备好，以备不时之需）</p><h2 id="HashCat"><a href="#HashCat" class="headerlink" title="HashCat"></a>HashCat</h2><p>配置环境为：</p><ul><li>Ubuntu 20.04 </li><li>NVIDIA Tesla A100-32GB with CUDA</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>参考：<a href="https://github.com/hashcat/hashcat">hashcat/hashcat: World’s fastest and most advanced password recovery utility (github.com)</a></p><p>需要已经安装好NVIDIA Driver和CUDA Toolkit，注意这玩意有点讲究，有详细的版本对应表，可以上网查一下</p><p>直接在上面的hashcat GitHub repo中下载最新release的7z包，<code>7z x</code>解压</p><h4 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h4><p>安装好以后需要测试hashcat能否使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -a 0 -m 500 example500.hash example.dict</span><br></pre></td></tr></table></figure><p>除了要注意是否可以跑通外，还需要注意输出的Device Info里面有没有GPU</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="准备哈希文件"><a href="#准备哈希文件" class="headerlink" title="准备哈希文件"></a>准备哈希文件</h4><p>之前说过，Hashcat爆破之前要准备好hash文件，还是要用到JtR。JtR可以在Kali虚拟机上面直接使用（只不过无法调用GPU），如果没有kali的话，可以参考下一节JtR的内容在Windows安装并编译JtR</p><p>安装好以后，使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip2john test.zip &gt; hash.txt</span><br></pre></td></tr></table></figure><p>此处需要注意：</p><ul><li>hash.txt一定要是<strong>UTF-8</strong>格式存储的，如果不是，请用vscode等工具将其用UTF-8编码保存</li><li>hash.txt的格式是 <code>test.zip:test.pdf:$pkzip2$1*1...d*$/pkzip2$:test.pdf:test.zip</code>，请掐头去尾，只保留<script type="math/tex">pkzip2$1*1...d*$/pkzip2</script>的内容</li><li>hash.txt不能有<strong>空格、不可见字符</strong>等</li></ul><h4 id="设置密码范围"><a href="#设置密码范围" class="headerlink" title="设置密码范围"></a>设置密码范围</h4><p>我们使用mask_attack模式<code>-a 3</code>来自定义密码，具体如下：</p><p>以下是mask_attack的字符集：</p><blockquote><ul><li>?l = abcdefghijklmnopqrstuvwxyz</li><li>?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ</li><li>?d = 0123456789</li><li>?h = 0123456789abcdef</li><li>?H = 0123456789ABCDEF</li><li>?s = «space»!”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~</li><li>?a = ?l?u?d?s</li><li>?b = 0x00 - 0xff</li></ul></blockquote><p>那么假设我要爆破的密码范围是”boulebard”+3位数字，就可以用<code>-a 3 boulevard?d?d?d</code> 来规定</p><p>如果是自定义字符集呢？可以用<code>-1 字符集1内容, -2 字符集2内容</code>自定义字符集，然后用<code>?1?2</code>使用字符集</p><p>例如，对于”Cst.******“（*为0-9/a-z/A-Z），需要定义数字+大小写字母的字符集：<code>-1 ?l?u?d</code></p><p>然后，密码则表达为<code>Cst.?1?1?1?1?1?1</code></p><h4 id="设置爆破模式"><a href="#设置爆破模式" class="headerlink" title="设置爆破模式"></a>设置爆破模式</h4><p>对于不同文件类型有不同的爆破模式<code>-m mode_num</code>，需要根据被爆破文件的格式和hash.txt的内容来在<a href="https://hashcat.net/wiki/doku.php?id=example_hashes">example_hashes [hashcat wiki\]</a>中查询到模式码，如：</p><p><img src="/images/john/image-20230324093110247.png" alt="image-20230324093110247"></p><p>对于上面的hash.txt，就只需要尝试<code>-m 17200/17210/17220/17225/17230</code></p><p>所以，最后的调用代码为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hashcat.bin -a 3 -m 17200 -1 ?l?u?d hash.txt Cst.?1?1?1?1?1?1</span><br></pre></td></tr></table></figure><h3 id="问题-amp-缺点"><a href="#问题-amp-缺点" class="headerlink" title="问题&amp;缺点"></a>问题&amp;缺点</h3><p>我遇到的两个问题都在<a href="https://hashcat.net/forum/thread-11358-post-57870.html#pid57870">Signature unmatched No hashed loaded. (hashcat.net)</a>提出</p><ul><li>第一个问题是之前提到的，hash.txt没有用UTF-8保存，注意以下即可解决</li><li>第二个问题就要看运气了，某些文件提取出的hash很大，导致hashcat无法处理，这种情况就只能去用JtR破解了</li></ul><h2 id="John-the-Ripper"><a href="#John-the-Ripper" class="headerlink" title="John the Ripper"></a>John the Ripper</h2><p>配置环境为</p><ul><li>Windows11 22H2</li><li>RTX2070-8GB</li></ul><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>参考：<a href="https://github.com/openwall/john/blob/bleeding-jumbo/doc/INSTALL-WINDOWS">john/INSTALL-WINDOWS at bleeding-jumbo · openwall/john (github.com)</a></p><p>在Windows下，需要用到CryWin安装，到<a href="https://cygwin.com/install.html">Cygwin Installation</a>下载<code>setup-x86_64.exe</code>，放到<code>C:/crywin64/</code>目录下，然后在Windows PowerShell执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\cygwin64\setup-x86_64.exe -q -P gcc-core -P libgcc1 -P make -P perl</span><br><span class="line">C:\cygwin64\setup-x86_64.exe -q -P libssl-devel -P libbz2-devel</span><br><span class="line">C:\cygwin64\setup-x86_64.exe -q -P libgmp-devel -P zlib-devel</span><br><span class="line">C:\cygwin64\setup-x86_64.exe -q -P libOpenCL-devel -P libcrypt-devel</span><br></pre></td></tr></table></figure><p>输入命令以后安装的过程基本上是自动的，只不过第一次安装的时候会要你选源，选一个国内的即可</p><p>然后下载<a href="https://github.com/openwall/john/archive/bleeding-jumbo.zip">https://github.com/openwall/john/archive/bleeding-jumbo.zip</a>，解压放到<code>C:/crywin64/home/[用户名]</code>目录</p><p>打开crywin64 terminal（点击图标即可），进入上面解压的目录，开始编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure &amp;&amp; make -s clean &amp;&amp; make -sj4</span><br><span class="line">make windows-package</span><br></pre></td></tr></table></figure><p>编译好以后，测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..\run\john --test=0</span><br></pre></td></tr></table></figure><p>然后查看你的OpenCL设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..\run\john --list=opencl-devices                                               </span><br></pre></td></tr></table></figure><p>但是有时候，很不幸，你可能<strong>只能看到CPU而看不到GPU</strong></p><p>这时候，参考<a href="https://miloserdov.org/?p=4961#131">Comprehensive Guide to John the Ripper. Part 1: Introducing and Installing John the Ripper - Ethical hacking and penetration testing (miloserdov.org)</a>中的方法：</p><ol><li>在<code>C:\cygwin64\bin\</code>中找到<code>cygOpenCL-1.dll</code>，重命名为<code>cygOpenCL-1.dll.bac</code></li><li>把<code>C:\Windows\System32\OpenCL.dll</code>复制到<code>C:\cygwin64\bin\</code>，重命名为<code>cygOpenCL-1.dll</code></li></ol><p>这时再次查看设备，就可以查看到显卡了</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>同样的，我们使用mask模式来爆破密码，其语法参考<a href="https://github.com/openwall/john/blob/bleeding-jumbo/doc/MASK">john/MASK at bleeding-jumbo · openwall/john (github.com)</a></p><p>语法和hashcat类似，自定义字符集可以用<code>-1=?l?u</code>表示，对于Cst.那个密码，爆破命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run/john/ -1=?d?l?u --mask=Cst.?1?1?1?1?1?1 hast.txt</span><br></pre></td></tr></table></figure><p>但是需要注意的是，即使查看到了GPU，JtR也会默认使用CPU，需要用<code>--format=wpapsk-opencl -dev=1</code>来设置使用OpenCL与GPU，但是，很遗憾，根据<a href="https://github.com/openwall/john/issues/4070">Issue #4070 · openwall/john (github.com)</a><em>**</em>的内容，zip文件并不支持OpenCL GPU破解，不过亲测对于上面的6位大小写+数字密码，即使是i5-10400也只需要20分钟就可以成功装好</p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl配置zsh</title>
      <link href="/2023/03/22/wsl%E9%85%8D%E7%BD%AEzsh/"/>
      <url>/2023/03/22/wsl%E9%85%8D%E7%BD%AEzsh/</url>
      
        <content type="html"><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>请在科学上网环境执行</p><p>参考：<a href="https://ohmyz.sh/#install">Oh My Zsh - a delightful &amp; open source framework for Zsh</a></p><h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><p>执行<code>sudo apt install zsh</code>即可</p><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure><p>自动执行，中途会提示是否设置zsh为默认shell，输入yes回车即可</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>在<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">Themes · ohmyzsh/ohmyzsh Wiki · GitHub</a>中选择心仪的主题，在<code>~/.zshrc</code>中设置<code>ZSH_THEME=&quot;主题名&quot;</code>然后执行<code>source ~/.zshrc</code>即可</p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
            <tag> zsh </tag>
            
            <tag> Linux美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh环境变量缺失问题解决</title>
      <link href="/2023/03/22/ssh%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/03/22/ssh%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zhenyuyaodidiao/p/9287497.html">解决SSH远程执行命令找不到环境变量的问题 - 振宇要低调 - 博客园 (cnblogs.com)</a></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在Linux Shell登录的时候会执行<code>/etc/profile</code>文件，但是ssh登入会执行<code>~/.bashrc</code>文件</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在<code>~./bashrc</code>中加入环境变量</p><p>方法为，添加一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;路径:$PATH&quot;</span><br></pre></td></tr></table></figure><p>保存后执行<code>source /etc/profile</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2配置Cuda</title>
      <link href="/2023/03/22/WSL2%E9%85%8D%E7%BD%AECuda/"/>
      <url>/2023/03/22/WSL2%E9%85%8D%E7%BD%AECuda/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-Ubuntu&amp;target_version=2.0&amp;target_type=deb_local">CUDA Toolkit 12.1 Downloads | NVIDIA Developer</a></p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="在Windows中安装显卡驱动"><a href="#在Windows中安装显卡驱动" class="headerlink" title="在Windows中安装显卡驱动"></a>在Windows中安装显卡驱动</h3><p>注意是在Windows而不是WSL中安装驱动，安装的是游戏驱动即可</p><p>如果已经安装（毕竟打游戏的一般都提前安装好了），只需要在Windows powershell中输入<code>nvidia-smi</code>即可验证</p><h3 id="在WSL2中配置"><a href="#在WSL2中配置" class="headerlink" title="在WSL2中配置"></a>在WSL2中配置</h3><p>参考开头给出的链接，只需要输入图中的这些命令就可以配置完成</p><p><img src="/images/wsl-cuda/image-20230322164339279.png" alt="image-20230322164339279"></p><p>然后到wsl里面再输入一遍<code>nvidia-smi</code>即可验证</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>显卡驱动是最新的Game Driver即可，安装在Windows而不是WSL</li><li>WSL版本需要为WSL2，WSL1不支持</li><li>不支持Maxwell架构显卡（截至博客发布时间</li><li>如果是SSH登录WSL，可能会提示没有<code>nvidia-smi</code>命令，可能是环境变量的问题，输入绝对路径<code>/usr/lib/wsl/lib/nvidia-smi</code>运行即可。方便起见，可以添加一个环境变量</li></ol>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2配置SSH局域网访问</title>
      <link href="/2023/03/22/WSL2%E9%85%8D%E7%BD%AESSH%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE/"/>
      <url>/2023/03/22/WSL2%E9%85%8D%E7%BD%AESSH%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="配置思路"><a href="#配置思路" class="headerlink" title="配置思路"></a>配置思路</h2><ul><li>和普通Linux一样，WSL也是通过OpenSSH配置SSH server</li><li>但是WSL是Windows的子系统，同一个局域网内的其他主机无法访问，所以要在Windows上面配置端口映射</li></ul><p>参考：</p><p><a href="https://blog.csdn.net/qq_24211837/article/details/117386077">wsl2 远程登陆ssh<em>_刘文凯</em>的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_42727710/article/details/122495314">Windows11，银河麒麟：如何打开端口<em>麒麟系统开放端口</em>全栈开发与测试的博客-CSDN博客</a></p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="配置OpenSSH"><a href="#配置OpenSSH" class="headerlink" title="配置OpenSSH"></a>配置OpenSSH</h3><p>过程比较基础，不再赘述，/etc/ssh/sshd_config如下所示：</p><p><img src="/images/wsl-ssh/image-20230322162125318.png" alt="image-20230322162125318"></p><p>打开以后在Windows powershell中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@localhost -p 2111</span><br></pre></td></tr></table></figure><p>即可在本地Windows系统访问WSL的SSH服务</p><h3 id="配置端口映射"><a href="#配置端口映射" class="headerlink" title="配置端口映射"></a>配置端口映射</h3><p>在Windows中使用netsh配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy set v4tov4 listenport=2233 listenaddress=0.0.0.0 connectport=2111 connectaddress=&#123;ip_wsl&#125;</span><br></pre></td></tr></table></figure><p>前面的port和ip表示Windows监听的ip和端口，后面的是wsl的ip和端口</p><p>此外，还要再Windows防火墙中打开2233端口，请参考第二篇博客</p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT QQ机器人快速配置</title>
      <link href="/2023/03/21/ChatGPT-QQ%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/03/21/ChatGPT-QQ%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ol><li><p>ChatGPT-mirai-QQ-bot</p><p><a href="https://github.com/lss233/chatgpt-mirai-qq-bot">GitHub - lss233/chatgpt-mirai-qq-bot: 🚀 一键部署！真正的 ChatGPT QQ 聊天机器人！支持ChatGPT API、 ChatGPT Plus、新版 Bing，多账号负载均衡，人设调教，敏感词检测，虚拟女仆、对话上下文，图片渲染，代理加速 (内有视频教程）</a></p><p>在GitHub下载最新Release压缩包即可</p></li><li><p>手机滑块验证码工具</p><p><a href="https://pan.baidu.com/s/1Ij-CCHgY7S16cZo584RvsA">https://pan.baidu.com/s/1Ij-CCHgY7S16cZo584RvsA</a> </p><p>提取码：7qjk</p></li></ol><h2 id="配置思路"><a href="#配置思路" class="headerlink" title="配置思路"></a>配置思路</h2><p>本项目由mirai和chatgpt两个模块组成，mirai负责与QQ通信，将信息转发到chatpgt，然后把chatgpt的回复发送到QQ</p><p>只要在两个模块上分别登录好QQ和ChatGPT账户即可</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="初始化-amp-配置ChatGPT账户"><a href="#初始化-amp-配置ChatGPT账户" class="headerlink" title="初始化&amp;配置ChatGPT账户"></a>初始化&amp;配置ChatGPT账户</h3><p>解压缩安装包，会有一个<code>初始化.bat脚本</code>，直接运行，完毕以后会弹出一个cfg配置文件，在其中配置ChatGPT账户：</p><ul><li>配置QQ号</li></ul><p><img src="/images/ChatGPT-Mirai/image-20230322163044228.png" alt="image-20230322163044228"></p><ul><li>配置梯子<img src="/images/ChatGPT-Mirai/image-20230322163126537.png" alt="image-20230322163126537"></li><li>配置OpenAI API密钥<img src="/images/ChatGPT-Mirai/image-20230322163141324.png" alt="image-20230322163141324"></li></ul><p>当然，提供了很多的OpenAI登陆账号，这里选择除了贵没有缺点的API方式（反正有免费额度</p><h3 id="配置Mirai"><a href="#配置Mirai" class="headerlink" title="配置Mirai"></a>配置Mirai</h3><p>这玩意配置bug很多，出问题了建议多上GitHub看看issue（毕竟是“非法”登陆腾讯的东西^ ^</p><p>点击<code>启动Mirai.bat</code>，然后等待Mirai初始化完成，输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Login qq号 qq密码 设备类型</span><br></pre></td></tr></table></figure><p>设备类型等于是模拟在什么设备上面登录，一开始选择的是ANDROID_WATCH也就是安卓手表，出现了error，查询了<a href="https://mirai.mamoe.net/topic/223/无法登录的临时处理方案?lang=zh-CN">Mirai官方的解决方案</a>，把设备改为了MACOS就行了</p><p>然后，如果是第一次登陆的话，会要进行验证，如下图所示：</p><p><img src="/images/ChatGPT-Mirai/image-20230322163737380.png" alt="image-20230322163737380"></p><p>复制这个captcha链接，在滑动验证码app中输入并完成验证：</p><p><img src="/images/ChatGPT-Mirai/image-20230322163809239.png" alt="image-20230322163809239"></p><p>会得到一串TX值，赋值TX值，直接输入到Mirai终端就可以完成登录</p><h3 id="启动ChatGPT"><a href="#启动ChatGPT" class="headerlink" title="启动ChatGPT"></a>启动ChatGPT</h3><p>然后点击<code>启动ChatGPT.bat</code>，如下图就是登陆成功：</p><p><img src="/images/ChatGPT-Mirai/image-20230322163918590.png" alt="image-20230322163918590"></p><p>到私聊或者到群里@进行对话测试</p>]]></content>
      
      
      <categories>
          
          <category> 不务正业の小玩意 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥网课C++进阶实验</title>
      <link href="/2023/03/21/cplusplus/"/>
      <url>/2023/03/21/cplusplus/</url>
      
        <content type="html"><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="初识类与对象"><a href="#初识类与对象" class="headerlink" title="初识类与对象"></a>初识类与对象</h3><h4 id="类的有关函数"><a href="#类的有关函数" class="headerlink" title="类的有关函数"></a>类的有关函数</h4><div class="table-container"><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>构造函数</td><td>类的构造函数是一种特殊的函数，在<strong>创建</strong>一个新的对象时自动调用</td></tr><tr><td>析构函数</td><td>类的析构函数也是一种特殊的函数，在<strong>删除</strong>所创建的对象时自动调用</td></tr><tr><td>拷贝构造函数</td><td>拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中<strong>之前创建的对象来初始化新创建的对象</strong></td></tr><tr><td>友元函数</td><td>友元函数可以访问类的 <strong>private 和 protected</strong> 成员</td></tr><tr><td>内联函数</td><td>通过内联函数，编译器试图在调用函数的地方<strong>扩展函数体中的代码</strong></td></tr><tr><td>类成员函数</td><td>类的成员函数是指那些把定义和原型<strong>写在类定义内部的函数</strong>，就像类定义中的其他变量一样</td></tr><tr><td>类访问修饰符</td><td>类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private</td></tr><tr><td>this 指针</td><td>每个对象都有一个特殊的指针 this，它指向对象本身</td></tr><tr><td>静态成员</td><td>类的数据成员和成员函数都可以被声明为静态的</td></tr></tbody></table></div><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>e.g.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class 类关键字、Student 类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 访问限制符 - 公有属性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>() &#123;&#125;    <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;&#125;    <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123; <span class="keyword">this</span>-&gt;name = name; &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; <span class="keyword">this</span>-&gt;age = age; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="comment">// 访问限制符 - 私有属性</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>对于上述定义需要注意几点：</p><ul><li>可以没有解析和析构函数，系统自动生成</li><li>除了private和public还有protected</li><li>private的数据成员，不能够直接访问，需要使用成员函数访问（比如这里的getAge()）</li></ul><h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><p>实例化有<strong>栈上和堆上</strong>两种：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 栈上实例化</span></span><br><span class="line">    Student stu1;</span><br><span class="line">    stu1.<span class="built_in">setName</span>(<span class="string">&quot;jake&quot;</span>);</span><br><span class="line">    stu1.<span class="built_in">setAge</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; stu1.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;, I&#x27;m &quot;</span> &lt;&lt; stu1.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆上实例化</span></span><br><span class="line">    Student *stu2 = <span class="keyword">new</span> Student;</span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    stu2-&gt;<span class="built_in">setName</span>(<span class="string">&quot;Siri&quot;</span>);</span><br><span class="line">    stu2-&gt;<span class="built_in">setAge</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; stu2-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;, I&#x27;m &quot;</span> &lt;&lt; stu2-&gt;<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> stu2;</span><br><span class="line">    stu2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于两种实例化，需要注意下面几点：</p><ul><li>栈上实例化的对象，超出定义域的资源会被自动回收</li><li>堆上实例化的对象，需要手动回收(delete)</li><li>delete释放堆上资源后，需要置空指针</li><li>栈上对象使用”.”访问，堆上对象使用”-&gt;”访问</li></ul><h4 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h4><p>string类在namespace std中，常用操作如下：<br>|操作|解释|<br>|—-|—-|<br>|s.empty()|判断是否为空|<br>|s.size()|同s.length()|<br>|s1 + s2|拼接|<br>|s.at(i)|同s[i]|<br>|s.c_str()|返回char*，同s.data()，注意返回的指针不能操作，只读|<br>|stoi()|转int，类似的还有stol()，stoll()|<br>|stof()|字符串转 float, 还有 stod()，stold()|<br>|s.find(substr, begin)|从begin位置开始查找子串|<br>|s.rfind(substr)|反向查找子串|</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>在函数定义之前加上inline关键字，标识编译器在编译的时候，在每个调用了这个函数的地方都编译一遍这个函数，从而节省运行时调用函数的时间。<br>一般来说，内联函数是比较简单的函数，如果函数比较复杂，编译器会自动取消内联。</p><h5 id="类内联函数"><a href="#类内联函数" class="headerlink" title="类内联函数"></a>类内联函数</h5><p>在类内，与上述一致，也可以加入inline关键字。<br>即使没有inline，编译器也会自动尝试对简单的成员函数作为内联函数编译。</p><h4 id="类的定义与实例化"><a href="#类的定义与实例化" class="headerlink" title="类的定义与实例化"></a>类的定义与实例化</h4><h5 id="类内定义"><a href="#类内定义" class="headerlink" title="类内定义"></a>类内定义</h5><p>也就是在之前的例子中，在类里边定义的函数。</p><h5 id="类外定义"><a href="#类外定义" class="headerlink" title="类外定义"></a>类外定义</h5><p>e.g.<br>在同一个文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student::~<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Student::getName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setAge</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::getAge</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    stu.<span class="built_in">setName</span>(<span class="string">&quot;jake&quot;</span>);</span><br><span class="line">    stu.<span class="built_in">setAge</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; stu.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;, I&#x27;m &quot;</span> &lt;&lt; stu.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意这里getName()和getAge()两个函数后面都加了const，意思是这两个函数<strong>不允许修改类数据成员的值</strong>。</p><p>除此之外，函数还可以定义在不同文件中。其中，类定义可以放在.h文件中，类内函数定义可以放在.cpp文件中，然后在其他文件中，通过<code>include&lt;xxx.h&gt;</code>就可以调用这个类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.h 文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STUDENT__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STUDENT__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __STUDENT__</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.cpp 文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span>    <span class="comment">// 记得添加类头文件</span></span></span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student::~<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Student::getName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setAge</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::getAge</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp 文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    stu.<span class="built_in">setName</span>(<span class="string">&quot;jake&quot;</span>);</span><br><span class="line">    stu.<span class="built_in">setAge</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; stu.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;, I&#x27;m &quot;</span> &lt;&lt; stu.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时，需要使用如下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp Student.cpp -o main</span><br></pre></td></tr></table></figure></p><h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><p>官方定义：封装是将数据和处理数据的程序组合起来，仅对外公开接口，达到信息隐藏的功能。<br>类封装以后，用户就只能通过给定的接口操作private数据，且不知道数据处理过程。举一个例子，用户不知道芯片内部结构，只对引脚操作。</p><h4 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h4><p>之前说过，类的关键字有public，protected，private：</p><ul><li>public用户可以直接访问</li><li>protected用户需要继承类后访问</li><li>private用户不能直接访问<br>（类的继承：一个类在已经存在的类（基类）基础上，添加自己的函数与数据。如，动物类有eat，sleep函数，还可以派送一个狗类，继承自动物类并添加bark函数）</li></ul><h3 id="对象的生离死别"><a href="#对象的生离死别" class="headerlink" title="对象的生离死别"></a>对象的生离死别</h3><p>一个对象从实例化到销毁的历程为：申请内存-&gt;初始化列表-&gt;构造函数-&gt;参与计算-&gt;析构函数-&gt;释放内存</p><h4 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h4><div class="table-container"><table><thead><tr><th>内存区</th><th>用途</th></tr></thead><tbody><tr><td>栈</td><td>函数参数、局部变量</td></tr><tr><td>堆</td><td>程序员分配、释放</td></tr><tr><td>全局</td><td>全局和静态变量</td></tr><tr><td>常量</td><td>常量</td></tr><tr><td>代码</td><td>逻辑代码的二进制</td></tr></tbody></table></div><p><strong>栈与堆对比：</strong>栈由编译器自动分配回收，空间比较小，申请效率快；堆由程序员分配（C：malloc-free；C++：new-delete），空间很大，申请比较慢；</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>函数与类同名，可以有多个重载形式，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1. 无参构造函数</span></span><br><span class="line">    <span class="built_in">Teacher</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 2. 有参构造函数</span></span><br><span class="line">    <span class="built_in">Teacher</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 有参构造函数--全部有默认参数--&gt;默认构造函数</span></span><br><span class="line">    <span class="comment">/*Teacher(string name = &quot;jake&quot;, int age = 15) &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;name = name;</span></span><br><span class="line"><span class="comment">        this-&gt;age = age;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>注意：</p><ul><li>根据重载函数的规则，例如示例代码 2 中有参构造函数与缺省构造函数不能同时使用，因为参数的个数和类型都是相同的。</li><li>示例代码 2 中无参构造函数与缺省构造函数也不能同时使用，因为编译器无法识别是使用无参构造函数还是使用缺省函数。</li><li>如果实例化对象不需要传递参数的构造函数统称默认构造函数。</li></ul><p>注：C++函数重载需要形式参数不同</p><h4 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h4><p>explicit关键字用于类内构造函数之前，表示不允许隐式转换，具体可以看下面的示例代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认 implicit（隐式转换）</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>) &#123; &#125;      <span class="comment">// 转换构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>, <span class="type">int</span>) &#123; &#125; <span class="comment">// 转换构造函数 (C++11)</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 申明构造函数使用显示声明，不能隐式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1 = <span class="number">1</span>;      <span class="comment">// OK赋值初始化选择 A::A(int)</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK：直接初始化选择 A::A(int)</span></span><br><span class="line">    A a3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK：直接列表初始化选择 A::A(int, int)</span></span><br><span class="line">    A a4 = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// OK赋值列表初始化选择 A::A(int, int)</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;   <span class="comment">// OK：显式转型进行 static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (a1) ;      <span class="comment">// OK：A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na1 = a1; <span class="comment">// OK赋值初始化选择 A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(a1); <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  B b1 = 1;      // err赋值初始化不考虑 B::B(int)</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK：直接初始化选择 B::B(int)</span></span><br><span class="line">    B b3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK：直接列表初始化选择 B::B(int, int)</span></span><br><span class="line"><span class="comment">//  B b4 = &#123;4, 5&#125;; // err赋值列表初始化不考虑 B::B(int,int)</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;   <span class="comment">// OK：显式转型进行 static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (b2) ;      <span class="comment">// OK：B::operator bool()</span></span><br><span class="line"><span class="comment">//  bool nb1 = b2; // err赋值初始化不考虑 B::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> nb2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b2); <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>class A没有explicit，所以可以使用<code>A a1 = 1</code>，<code>A a4 = &#123;4,5&#125;</code>这样的初始化方式，而class B可以。</p><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>语法<code>类名(const 类名 &amp;变量)</code><br>用法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1. 无参构造函数</span></span><br><span class="line">    <span class="built_in">Teacher</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 2. 有参构造函数</span></span><br><span class="line">    <span class="built_in">Teacher</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Teacher</span>(<span class="type">const</span> Teacher &amp;tea) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = tea.name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = tea.age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行默认构造函数</span></span><br><span class="line">    Teacher tea1;</span><br><span class="line">    <span class="comment">// 执行拷贝构造函数</span></span><br><span class="line">    Teacher tea2 = tea1;</span><br><span class="line">    Teacher tea3 = <span class="built_in">Teacher</span>(tea1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>有的时候类中会有const常量，是不允许被函数修改的，所以有了初始化列表这个方法，在构造函数之前执行，const常量必须要用初始化列表初始化。语法为<code>类名() 数据成员(参数), ... &#123;&#125;</code>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>() : <span class="built_in">Pi</span>(<span class="number">3.14</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 错误：Circle() &#123; Pi = 3.14; &#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> Pi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在这里,Pi作为const double常量，只能够用初始化列表执行。</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>销毁对象的时候调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>() : <span class="built_in">buffer</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">16</span>]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;</span><br><span class="line">        <span class="comment">// 析构函数释放内存</span></span><br><span class="line">        <span class="keyword">delete</span> [] buffer;</span><br><span class="line">        buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="对象与对象数组"><a href="#对象与对象数组" class="headerlink" title="对象与对象数组"></a>对象与对象数组</h3><p>提示：为了方便课程讲解，示例代码使用类内定义的方式实现，如果自己动手做实验的时候希望能够使用分文件类外定义的方式来编写代码。<br>本节教程使用class Point实例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用带参数默认构造函数，并使用初始化列表初始化 x，y</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;Point(double x = 0, double y = 0)&quot; &lt;&lt; endl;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Point(double x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, double y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">const</span> Point &amp; p) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;Point(const Point &amp;p)&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 打印点的值</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Point(const Point &amp;p:(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = p.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = p.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数，由于没有申请内存，析构函数中不需要做什么</span></span><br><span class="line">    ~<span class="built_in">Point</span>() &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;~Point()&quot; &lt;&lt; endl;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Point():(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// x, y 绑定的成成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPoint</span><span class="params">(<span class="type">const</span> Point &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = p.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = p.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPoint</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">this</span>-&gt;x = x; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123; <span class="keyword">this</span>-&gt;y = y; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="栈上实例化"><a href="#栈上实例化" class="headerlink" title="栈上实例化"></a>栈上实例化</h4><p>和普通数据类型一样，直接按照数组栈上申请方式来就行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈上实例化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stackInstantiation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化对象数组</span></span><br><span class="line">    Point point[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数组操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p[0]: (&quot;</span> &lt;&lt; point[<span class="number">0</span>].<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point[<span class="number">0</span>].<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p[1]: (&quot;</span> &lt;&lt; point[<span class="number">1</span>].<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point[<span class="number">1</span>].<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p[2]: (&quot;</span> &lt;&lt; point[<span class="number">2</span>].<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point[<span class="number">2</span>].<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    point[<span class="number">0</span>].<span class="built_in">setPoint</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p[0]: (&quot;</span> &lt;&lt; point[<span class="number">0</span>].<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point[<span class="number">0</span>].<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stackInstantiation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在运行stackInstantiation()后，虽然函数中没有调用析构函数，但是由于数组是申请在栈上面的，所以会自动执行析构函数。</p><h4 id="堆上实例化"><a href="#堆上实例化" class="headerlink" title="堆上实例化"></a>堆上实例化</h4><p>数据量较大建议在堆上实例化，注意需要手动释放内存（语法为<code>delete [] point</code>）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">// 堆上实例化对象数组</span></span><br><span class="line">    Point *point = <span class="keyword">new</span> Point[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p[0]: (&quot;</span> &lt;&lt; point[<span class="number">0</span>].<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point[<span class="number">0</span>].<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p[1]: (&quot;</span> &lt;&lt; point[<span class="number">1</span>].<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point[<span class="number">1</span>].<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p[2]: (&quot;</span> &lt;&lt; point[<span class="number">2</span>].<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point[<span class="number">2</span>].<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    point[<span class="number">0</span>].<span class="built_in">setPoint</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p[0]: (&quot;</span> &lt;&lt; point[<span class="number">0</span>].<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point[<span class="number">0</span>].<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> [] point;</span><br><span class="line">    point = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除了<code>array[x].function()</code>这样的访问方式外，还可以使用<code>(array+x)-&gt;function()</code>指针的方式访问。</p><h4 id="对象成员"><a href="#对象成员" class="headerlink" title="对象成员"></a>对象成员</h4><p>构造一个class Line，由两个点组成：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="type">const</span> Point &amp; pA, <span class="type">const</span> Point &amp;pB) : <span class="built_in">pointA</span>(pA), <span class="built_in">pointB</span>(pB) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Line(const Point &amp; pA, const Point &amp;pB)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Line</span>(<span class="type">double</span> aX, <span class="type">double</span> aY, <span class="type">double</span> bX, <span class="type">double</span> bY) : <span class="built_in">pointA</span>(aX, aY), <span class="built_in">pointB</span>(bX, bY) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Line(double aX, double aY, double bX, double bY)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Line</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Line()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point pointA;</span><br><span class="line">    Point pointB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化</span></span><br><span class="line">    Line *line = <span class="keyword">new</span> <span class="built_in">Line</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> line;</span><br><span class="line">    line = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实例化Line时，会先实例化两个Point；而析构Line时，Point的析构函数会在后面执行。<br>如果使用析构函数的第一个重载（Point*参数传入），如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化</span></span><br><span class="line">    Line *line = <span class="keyword">new</span> <span class="built_in">Line</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> line;</span><br><span class="line">    line = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这种情况下，传入的Point（1, 2）,Point(3, 5)会被实例化为常数，然后再初始化完成以后自动销毁。</p><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><ul><li>浅拷贝：对象A的数据成员赋值给对象B的数据成员</li><li>深拷贝：对象B先为数据成员申请和A中数据成员一样大的内存，然后再赋值</li><li><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4>浅拷贝示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> count) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Array()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array &amp; arr) &#123;</span><br><span class="line">        <span class="comment">// 浅拷贝</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;count = arr.count;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Array(const Array &amp; arr)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Array(): &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCount</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123; <span class="keyword">this</span>-&gt;count = count; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈上实例化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stackInstantiation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Array arr2 = arr1;</span><br><span class="line">    arr2.<span class="built_in">setCount</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function">Array <span class="title">arr3</span><span class="params">(arr2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stackInstantiation</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但是，浅拷贝有时候会出现错误，比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> count) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Array()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array &amp; arr) &#123;</span><br><span class="line">        <span class="comment">// 浅拷贝</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;count = arr.count;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Array(const Array &amp; arr)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Array(): &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCount</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123; <span class="keyword">this</span>-&gt;count = count; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈上实例化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stackInstantiation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Array arr2 = arr1;</span><br><span class="line">    arr2.<span class="built_in">setCount</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function">Array <span class="title">arr3</span><span class="params">(arr2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stackInstantiation</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这段代码里，Array有int<em>类型的成员Arr，在拷贝的时候仅仅拷贝了Arr指针，而析构函数中会释放这个指针。这样，在析构arr1、arr2的时候，就会把同一片内存释放两次。<br>如果我们不去写这个浅拷贝构造函数，而是让编译器自动生成会怎么样呢？答案是编译器自动生成的依旧是这样，只会进行浅拷贝。<br>所以，遇到对象成员有指针等情况，一定要<em>*手动写一个深拷贝构造函数</em></em>。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="type">const</span> Array &amp; arr) &#123;</span><br><span class="line">    <span class="comment">// 浅拷贝</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;count = arr.count;</span><br><span class="line">    <span class="comment">// 深拷贝正确用法</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Arr = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; count; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     this-&gt;Arr[i] = arr.Arr[i];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Arr, arr.Arr, count*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array(const Array &amp; arr)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SKY-UPSI</title>
      <link href="/2023/03/01/SKY-UPSI/"/>
      <url>/2023/03/01/SKY-UPSI/</url>
      
        <content type="html"><![CDATA[<p>本文主要是对基于<a href="https://github.com/peihanmiao/OPRF-PSI">OPRF-PSI</a>的SKY-PSI进行了UPSI框架适配，以及更换<a href="[GitHub - FastFilter/xor_singleheader: Header-only binary fuse and xor filter library](https://github.com/FastFilter/xor_singleheader/">BinaryFuseFilter</a>)进行OPRF值传递。</p><h2 id="修改BinaryFuseFilter"><a href="#修改BinaryFuseFilter" class="headerlink" title="修改BinaryFuseFilter"></a>修改BinaryFuseFilter</h2><p>在OPRF-PSI中，计算出来的OPRF值是直接发送过去的，我们的优化思路是把值放到过滤器中存储起来，然后发送过滤器参数给对方，让对方重构过滤器然后查询OPRF值。</p><h2 id="TBC"><a href="#TBC" class="headerlink" title="TBC"></a>TBC</h2><p>后面的忘了…妈妈生的^ ^</p>]]></content>
      
      
      <categories>
          
          <category> 隐私计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSI </tag>
            
            <tag> UPSI </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VOLE-UPSI</title>
      <link href="/2023/03/01/VOLE-UPSI/"/>
      <url>/2023/03/01/VOLE-UPSI/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了<a href="https://github.com/Visa-Research/volepsi">volePSI</a>的build，以及用其构造UPSI的过程。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>部署在腾讯云上的Ubuntu22.04LTS系统，使用IDE为code-server </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要安装libOTe，按照之前的经验，使用比较好的vpn（如pigcha），连接美国节点，开启全局（网卡）代理，即可比较顺利的克隆libOTe。</p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>首先使用的是<code>python3 build.py --install</code></p><p>但是这样是最小化安装，虽然可以运行单元测试，但不能够使用fileBasedPSI。</p><p>后续查看了fileBasedPSI.cpp的源码报错信息发现需要启用Coproto的BOOST组件，所以采用<code>python3 build.py -DCOPROTO_ENABLE_BOOST=ON -DCOPROTO_ENABLE_OPENSSL=ON</code>编译。</p><p>但是这样做又出现一个编译bug，提示找不到libOTe，提交<a href="https://github.com/Visa-Research/volepsi/issues/20">issue#20</a>后发现是找不到OpenSSL的原因，尝试了一下安装OpenSSL并添加到PATH和G++编译路径后无果，所以干脆取消对于OpenSSL的启用，最终使用如下命令编译成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 build.py -DCOPROTO_ENABLE_BOOST=ON -DCOPROTO_ENABLE_OPENSSL=OFF</span><br></pre></td></tr></table></figure><h2 id="构造UPSI"><a href="#构造UPSI" class="headerlink" title="构造UPSI"></a>构造UPSI</h2><p>与之前的<a href="[GitHub - peihanmiao/OPRF-PSI: Private Set Intersection in the Internet Setting From Lightweight Oblivious PRF](https://github.com/peihanmiao/OPRF-PSI">OPRF-PSI</a>)需要大量修改API来支持std::thread调用不同，VOLE-PSI有File Based模式：只要在命令行输入调用参数，即可自动读取文件求交，然后将结果输出到文件。这样的调用方式非常方便实现UPSI，根本不需要修改API。</p><h3 id="实现单次调用"><a href="#实现单次调用" class="headerlink" title="实现单次调用"></a>实现单次调用</h3><p>这里只需要使用stdlib.h自带的<code>system(const char *command)</code>即可。</p><p>使用string类完成调用命令的构造，然后用<code>sting.c_str()</code>方法转为const char *即可完成单次PSI命令行调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callPSI</span><span class="params">(std::string role, std::string inputName, std::string port, <span class="type">bool</span> *FinSig)</span> </span>&#123;</span><br><span class="line">    std::string callPSI = <span class="string">&quot;../volepsi/out/build/linux/frontend/frontend -bin -receiverSize 8192 -senderSize 8192 -useSilver &quot;</span>;</span><br><span class="line">    callPSI = callPSI + <span class="string">&quot;-r &quot;</span> + role + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    callPSI = callPSI + <span class="string">&quot;-in &quot;</span> + inputName + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    callPSI = callPSI + <span class="string">&quot;-ip 127.0.0.1:&quot;</span> + port + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; callPSI &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(callPSI.<span class="built_in">c_str</span>());</span><br><span class="line">    *FinSig = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程调用"><a href="#多线程调用" class="headerlink" title="多线程调用"></a>多线程调用</h3><p>这里使用的是<code>std::thread</code>库来完成多线程，这个库比<code>pthread</code>要新。</p><p>首先创建线程对象<code>std::thread tr(function, params)</code>，由于callPSI函数非常简单，所以没有什么好说的。之前的OPRF-PSI就不一样，要调用非常复杂的API，涉及到函数名前面需要加<code>&amp;</code>、部分参数需要<code>std::ref</code>修饰等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t30</span><span class="params">(callPSI,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;X3.bin&quot;</span>,<span class="string">&quot;1212&quot;</span>,&amp;Sig30)</span></span>;</span><br></pre></td></tr></table></figure><p>然后使用<code>detach()</code>方法调用，这个方法是<strong>非阻塞</strong>的。如果使用<code>join()</code>的话，子线程会阻塞父线程，那么就会导致不发同时调用多个PSI，而是按顺序执行。但是用<code>detach()</code>又会有一个问题：父线程会在子线程之前终止，导致出现<strong>孤儿进程</strong>。所以需要给callPSI加入一个<code>bool*</code>的参数传入，作为子线程结束的标志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t30.<span class="built_in">detach</span>();t31.<span class="built_in">detach</span>();t32.<span class="built_in">detach</span>();</span><br><span class="line">t03.<span class="built_in">detach</span>();t13.<span class="built_in">detach</span>();t23.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!(Sig30&amp;&amp;Sig31&amp;&amp;Sig32&amp;&amp;Sig03&amp;&amp;Sig13&amp;&amp;Sig23))&#123;</span><br><span class="line">     <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还需要注意一点：Linux系统的sleep单位是秒，这里需要用usleep。</p><h3 id="添加计时器"><a href="#添加计时器" class="headerlink" title="添加计时器"></a>添加计时器</h3><p>开始打算使用ctime标准库的<code>clock()</code>计算运行时间，但是不知道为什么测出来不准，所以改用<a href="https://github.com/ladnir/cryptoTools">cryptoTools</a>库的Timer。</p><h4 id="安装cryptoTools库"><a href="#安装cryptoTools库" class="headerlink" title="安装cryptoTools库"></a>安装cryptoTools库</h4><p>这个比较好装，clone然后python执行build脚本，期间挂梯子保障git clone不出问题就好。</p><h4 id="cmake链接cryptoTools库"><a href="#cmake链接cryptoTools库" class="headerlink" title="cmake链接cryptoTools库"></a>cmake链接cryptoTools库</h4><p>头文件加入<code>#include&lt;cryptoTools/Common/Timer.h&gt;</code></p><p>编写cmake文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name</span></span><br><span class="line"><span class="keyword">project</span>(UPSI_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_PREFIX_PATH <span class="string">&quot;cryptoTools/&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(cryptoTools REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(UPSI_test main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(UPSI_test cryptoTools)</span><br></pre></td></tr></table></figure><p>这里要注意几点：</p><ul><li><p>find_package、target_link_libraries是根据cryptoTools官方说明来的</p></li><li><p>直接find_package会找不到，所以需要把库路径添加到CMAKE_PREFIX_PATH里面</p></li><li><p>如果遇到报错：</p><p><code>Cannot specify link libraries for target &quot;XXX&quot; which is not built by this project.</code></p><p>那么需要检查两点：</p><ul><li>add_executable生成的文件需要是你的工程名</li><li>add_executable要在target_link_libraries前面</li></ul></li><li><p>有时候cmake明明写对了，但是还是会报错。这可能是之前执行过错误的CMake导致的，删掉<code>CMakeCache.txt</code>、<code>CMakeFiles</code>再试试</p></li></ul><h4 id="使用Timer计时器"><a href="#使用Timer计时器" class="headerlink" title="使用Timer计时器"></a>使用Timer计时器</h4><p>这个就很简单了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">osuCrypto::Timer timer;</span><br><span class="line">timer.<span class="built_in">setTimePoint</span>(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line"><span class="built_in">testbench</span>();</span><br><span class="line">timer.<span class="built_in">setTimePoint</span>(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; timer;</span><br></pre></td></tr></table></figure><p>打印的结果美观又准确，不得不说osuCrypto做的这些密码学库（CryptoTools、libOTe、libPSI…）都非常强大，就是C++大工程实在是有点折磨人…</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Label    Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">End          90.8     90.759  **********</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 隐私计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSI </tag>
            
            <tag> UPSI </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓查看电池寿命</title>
      <link href="/2022/12/26/%E5%AE%89%E5%8D%93%E6%9F%A5%E7%9C%8B%E7%94%B5%E6%B1%A0%E5%AF%BF%E5%91%BD/"/>
      <url>/2022/12/26/%E5%AE%89%E5%8D%93%E6%9F%A5%E7%9C%8B%E7%94%B5%E6%B1%A0%E5%AF%BF%E5%91%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>查看系统内的uevent文件可以查找到电池容量</p><p>这个文件，按照网上大多数的说法，在：<code>/sys/class/power_supply/bms/uevent</code>，不过我的路径略有出入，建议进入到<code>/sys/class/power_supply</code>以后自己找一找</p><h2 id="读取uevent文件"><a href="#读取uevent文件" class="headerlink" title="读取uevent文件"></a>读取uevent文件</h2><p>那么难点就在怎么获得这个文件了</p><h3 id="方法一：termux（需要root）"><a href="#方法一：termux（需要root）" class="headerlink" title="方法一：termux（需要root）"></a>方法一：termux（需要root）</h3><h4 id="安装termux"><a href="#安装termux" class="headerlink" title="安装termux"></a>安装termux</h4><p>在此下载：<a href="https://github.com/termux/termux-app/releases">Releases · termux/termux-app (github.com)</a></p><p>里面有很多版本，需要下载和你的手机CPU架构一致的。所以需要查看CPU架构，方法可以选择：</p><ul><li>搜索你的CPU型号是什么架构</li><li>使用ADB命令：<code>adb shell getprop ro.product.cpu.abi</code></li></ul><p>我的手机CPU是865，ADB返回的架构是arm64-v8a</p><p>所以下载后面标注arm64-v8a的apk包</p><h4 id="获取文件"><a href="#获取文件" class="headerlink" title="获取文件"></a>获取文件</h4><p>安装好以后，termux就等于在你的手机里面运行了一个Linux Shell，直接cat就好</p><p>不过我cat不到，估计是没有root导致的</p><h3 id="方法二：adb（还是需要root）"><a href="#方法二：adb（还是需要root）" class="headerlink" title="方法二：adb（还是需要root）"></a>方法二：adb（还是需要root）</h3><p>同样的，adb其实也是Linux shell，能访问的话cat就好，但是普通的adb是没有root权限的。</p><p>adb root的方法有两种，第一个是直接 adb root访问，第二个是装adbd insecure</p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓卸载自带应用</title>
      <link href="/2022/12/25/%E5%AE%89%E5%8D%93%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8/"/>
      <url>/2022/12/25/%E5%AE%89%E5%8D%93%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>电脑：ADB工具</p><p>手机：ES文件浏览器、打开USB调试</p><h2 id="查找包名"><a href="#查找包名" class="headerlink" title="查找包名"></a>查找包名</h2><p>在<code>ES文件浏览器 -&gt; 应用 -&gt; 系统应用</code>中找到想要卸载的应用，点开的属性中回显示包名</p><p>比如这里我想卸载的是Oxygen13自带的Netflix，其包名为<code>com.netflix.mediaclient</code></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>在输入<code>adb devices</code>可以找到设备以后，输入<code>adb shell</code></p><p>然后输入<code>pm uninstall --user 0 包名</code>即可卸载</p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一加8T9008救砖</title>
      <link href="/2022/12/24/%E4%B8%80%E5%8A%A08T9008%E6%95%91%E7%A0%96/"/>
      <url>/2022/12/24/%E4%B8%80%E5%8A%A08T9008%E6%95%91%E7%A0%96/</url>
      
        <content type="html"><![CDATA[<p>在折腾8T各种系统的道路上，已经翻车过两次了（变砖），每次变砖以后临时上网查教程就还是挺急的，所以写一篇救砖的博客</p><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>软件：救砖包+9008驱动</p><p>我是从一加社区找过来的<a href="https://bbs.oneplus.com/thread/5689136?mod=viewthread&amp;tid=5689136">OnePlus8T 官方ROM+9008救砖包</a></p><p>最终下载的版本如下：</p><p><img src="/images/8T/image-20221224103300683.png" alt="image-20221224103300683"></p><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>点击上面第二个exe文件，会弹出一个网络下载驱动（要你选择什么Ethernet之类的），不选这个，点击Cancel-&gt;是。你会发现把这个窗口关掉以后下面还会有一个本地安装的选项，这个才是需要的，然后一路next/accept安装即可。</p><h3 id="解决和windows的冲突"><a href="#解决和windows的冲突" class="headerlink" title="解决和windows的冲突"></a>解决和windows的冲突</h3><p>第一次安装驱动已经过了好久了，当时好像是和windows有点冲突，只安装好还用不了，解决办法如下：</p><p>windows设置-&gt;恢复-&gt;高级启动（重启）-&gt;疑难解答-&gt;高级选择-&gt;启动设置-&gt;重启-&gt;“7”禁用驱动程序强制签名-&gt;进系统</p><h2 id="救砖"><a href="#救砖" class="headerlink" title="救砖"></a>救砖</h2><p>采用各种办法让你的手机关机：</p><ol><li>音量加和电源键不松，强制关机</li><li>可以进recovery的话到rec关机也行</li><li>可以连接fastboot的话，从命令行fastboot restart recovery，然后再到rec关机</li></ol><p>反正从上面的方法找到一个可以关机的</p><p>关机以后，解压下载的9008线刷包，里面有一个<code>MsmDownloadTool V4.0.exe</code></p><p>打开，选择other然后login进入界面</p><p>界面里面，取消勾选sha256chesum、target选择H2（或者O2）</p><p>手机<strong>断开连接</strong>的情况下，按住音量上下不松手，然后接入电脑</p><p>这时软件里面会显示串口连接，这时候点击start，然后再松手</p><p>然后就会自动救砖，等待自动进入新系统就行</p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓刷机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一加8T提取image底包 &amp; namelssOS刷氧OS13踩坑</title>
      <link href="/2022/12/24/%E4%B8%80%E5%8A%A08T%E6%8F%90%E5%8F%96image%E5%BA%95%E5%B1%82/"/>
      <url>/2022/12/24/%E4%B8%80%E5%8A%A08T%E6%8F%90%E5%8F%96image%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前因为不满ColorOS的臃肿刷入了原生的nameless A13：<a href="https://blog-boulevard.top/2022/12/19/一加8t刷入namelessos/">一加8T刷入namelessOS | Boulevard’s Blog (blog-boulevard.top)</a></p><p>但是nameless的功能实在太少，bug实在太多，堪比从MI10搬运过来的MIUI13包。所以继续折腾一下，从nameless A13刷入到大氢的亲兄弟——国外测试已经更新到了安卓13的OxygenOS</p><p><strong>附：一加8系，9R，9RT，10R的OxygenOS13 Full OTA包地址</strong><a href="https://www.xda-developers.com/oneplus-8-series-9r-9rt-10r-oxygenos-13-stable/">Stable Android 13 update rolls out to the OnePlus 8 series and more (xda-developers.com)</a></p><h2 id="提取images"><a href="#提取images" class="headerlink" title="提取images"></a>提取images</h2><p>一加8T的底层可能比较多样化（低情商：混乱）。刷系统ROM包之前，如果你搞不清现在的系统底层和目标系统的底层是否是一致的，最好先刷入目标系统的四个img文件<code>boot.img,vbmeta.img,vbmeta_system.img,recovery.img</code></p><p>良心的安装包提供者会把这四个文件的下载连接也给你，当然如果他没给的话，也可以从Full OTA包里面提取出来，只需要<strong>payload dumper</strong>这个工具。</p><p>首先下载payload dumper，这个工具有Go和Py的源码可以自己build，但是懒人还是选择大佬做好了的exe包，点击即可使用：<a href="https://yun.daxiaamu.com/files/tool/payload.bin解包工具/payload dumper_go_大侠阿木重制/">tool/payload.bin解包工具/payload dumper<em>go</em>大侠阿木重制 - 其他文件 - 一加手机官方ROM下载 (daxiaamu.com)</a></p><p>下载好以后，解压Full OTA的zip包，可以看到一个payload.bin文件，把这个文件图标拖动到payload dumper图标上就会自动出现一个终端黑框，开始提取。提取完毕以后，会在payload.bin同目录下出现一个extraced_xxx文件夹，点进去就可以看到很多img文件，从中找到我们需要的四个image即可。</p><p><img src="/images/8T/image-20221224092710542.png" alt="image-20221224092710542"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>虽然提取img是成功的，但是从一个第三方刷到OOS13对我来说还是有点困难了，在刷入四个image以后再从recovery sideload失败变砖了</p><p>然后就只好开始9008救砖会H2OS，再从H2OS卡刷回OOS</p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓刷机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第十一章 并发控制</title>
      <link href="/2022/12/20/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/12/20/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>（终于写完了= =</p><p>数据库中可能有多个用户同时执行事务，为了保证这些事务不会互相影响，需要进行并发控制来保障数据的<strong>一致性和隔离性</strong>。</p><p>数据库对于多个事务的执行又如下方式：</p><ol><li>串行执行：T1-&gt;T2-&gt;…，一个一个排队完成</li><li>交叉并发：在事务间来回切换</li><li>同时并发：多处理机系统，真正的并发</li></ol><p>在本章中，1作为我们的判断标杆，是个并发处理策略是否是合格的需要看其结果是否能与某种串行执行一致。2是我们主要的讨论情况。</p><h2 id="并发控制概述"><a href="#并发控制概述" class="headerlink" title="并发控制概述"></a>并发控制概述</h2><p>下面三类并发操作可能导致数据的不一致性：</p><ul><li><p>丢失修改：两个事务同时写入一个数据，导致先写入的这个结果丢失</p><p><img src="/images/oneplusnameless/image-20221220103455549.png" alt="image-20221220103455549"></p></li><li><p>不可重复读：T1读取数据以后，T2更新数据，导致T1无法再现前一次结果</p><p>具体根据<strong>T2更新的类型</strong>又分为三种情况：</p><ul><li>T1读-&gt;T2<strong>修改</strong>-&gt;T1再次读，得到了不一样的值</li><li>T1读-&gt;T2<strong>删除</strong>-&gt;T1再次读，读不到某些数据</li><li>T1读-&gt;T2<strong>插入</strong>-&gt;T1再次读，多读了某些数据</li></ul><p>后两者又叫<strong>幻读</strong></p></li><li><p>读“脏”数据：T1修改了某些数据，T2读了这些数据，但是T1最终因为某些原因<strong>ROLLBACK</strong>了，T2读的这些数据处在一个不正确的状态</p></li></ul><p>总的来说，可以总结为这个表：</p><p><img src="/images/oneplusnameless/image-20221220104143739.png" alt="image-20221220104143739"></p><h2 id="封锁（Locking）"><a href="#封锁（Locking）" class="headerlink" title="封锁（Locking）"></a>封锁（Locking）</h2><p>对一个数据对象操作之前添加锁，限制其他事务对其操作，分为：</p><ul><li><p>排它锁（Exclusive Locks），又叫X锁、写锁</p><p>​    施加排它锁以后，其他事务<strong>不能写也不能读</strong></p></li><li><p>共享锁（Share Locks），又叫S锁、读锁</p><p>​    施加共享锁以后，其他事务<strong>可以读但是不能写</strong></p></li></ul><p>锁相容矩阵如下：</p><p><img src="/images/oneplusnameless/image-20221220113829540.png" alt="image-20221220113829540"></p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>封锁协议，就是对于事务在什么时候加锁、释放锁的规则。</p><p>典型的封锁协议是<strong>三级协议</strong>，随着等级升高，避免并发错误的能力越强，当然，数据库的并发性能也会降低。</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>一级封锁协议只包含写锁：</p><p>事务修改数据R之前必须加X锁，等到事务结束才释放</p><p>由于其只有X锁，所以<strong>只能防止丢失修改，不能防止不可重复读和脏数据</strong></p><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><p>在一级封锁协议的基础上，二级封锁协议增加了读锁：</p><p>事务T在读取数据R之前需要加S锁，在读取完毕之后释放</p><p>在一级协议的基础上，二级封锁协议添加了S锁，只不过S锁的持续时间很短，所以<strong>只能预防读脏数据，而不能够预防不可重复读</strong></p><p>关于为什么读不到脏数据：</p><p>当一个事务修改R的时候，为其上了X锁，所以在其COMMIT或者ROLLBACK之前，别的事物都上不了S锁，自然也就不能读没有COMMIT的R</p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p>在一级协议的基础上，三级封锁不仅加了读锁，还将读锁释放的时间也推迟到了事务结束</p><p>即：事务T在读取数据R之前需要加S锁，事务结束释放</p><p>三级封锁协议可以<strong>防止丢失修改、读脏数据和不可重复度三种情况</strong></p><h2 id="活锁和死锁"><a href="#活锁和死锁" class="headerlink" title="活锁和死锁"></a>活锁和死锁</h2><p>在操作的资源调度中，也学过类似的概念</p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>所谓活锁，并不是真的锁，而是调度政策导致某个事物<strong>无限等待</strong>的情况</p><p>避免活锁很简单，一般采用<strong>先来先服务FCFS</strong>调度策略</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在OS中已经了解过，死锁产生的条件是：</p><ul><li>请求互斥的共享资源</li><li>占有的资源不可被剥夺</li><li>持续占有并等待</li><li>相互循环等待</li></ul><h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h4><p>死锁的预防就是要<strong>破坏死锁产生的必要条件</strong>，有如下方法：</p><ul><li>一次封锁法：一次性把事务需要的数据全部加锁<ul><li>但是这样会导致系统的并发度很低</li><li>而且很难一次确定需要用到哪些数据</li></ul></li><li>顺序封锁法：上锁必须有个公共顺序，前面的数据没上、后面的数据就不能上<ul><li>这个公共顺序的维护很难</li><li>难以强制按照规定顺序加锁</li></ul></li></ul><p>总结：上面两种方法都是cjb，数据库的死锁问题不像OS，应该重在判断并解除而不是预防。</p><h4 id="死锁的诊断和解除"><a href="#死锁的诊断和解除" class="headerlink" title="死锁的诊断和解除"></a>死锁的诊断和解除</h4><p>死锁的判断主要有超时法和等待图法</p><ul><li>超时法：设定一个等待时限，如果事务等待超过这个时间就认为死锁了<ul><li>缺点：数据库事务运行时间各不一样，差别很大，时间设置很难</li></ul></li><li>等待图法：节点是事务，有向边T1-&gt;T2表示T1正在等待T2释放某个锁。如果在等待图中发现存在回路，就表示系统中出现了死锁。</li></ul><p>出现死锁以后，解除方法比较简单：选择代价最小的事务撤销即可</p><h2 id="并发调度的可串行性"><a href="#并发调度的可串行性" class="headerlink" title="并发调度的可串行性"></a>并发调度的可串行性</h2><p>之前说过，串行调度虽然实用性不高，但是可以作为并发调度的一个准则来说</p><h3 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h3><p>如果一个并发调度算法的结果和<strong>某一种</strong>（串行也可以排列组合）串行运行的结果是一致的，就称之为可串行化</p><h3 id="冲突可串行化"><a href="#冲突可串行化" class="headerlink" title="冲突可串行化"></a>冲突可串行化</h3><p>这是一种更严格的概念</p><p><strong>冲突</strong>：指一对<strong>连续</strong>动作，满足：<strong>交换顺序</strong>以后，涉及的事务中至少有一个<strong>事务行为改变</strong></p><p>冲突的情况：</p><ul><li>同一事务：任何一对连续操作都是冲突的</li><li>不同事务对同一元素的写</li><li>不同事务对同一元素的一读一写</li></ul><p>不冲突的情况：</p><ul><li>不同事务对同一元素的读</li><li>不同事务对不同元素操作</li></ul><p><strong>冲突可串行化：</strong>指一个调度，可以只进行一系列不冲突动作的交换来转化为串行调度</p><h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>指一个事务分为上锁（扩展阶段）和释放锁（收缩阶段）两个阶段，一旦开始释放锁，就不允许上锁了</p><p><strong>两段锁协议可以保证调度是可串行化的</strong></p><p>但是两段锁协议的扩展阶段也不是一次性上完所有锁，不能够预防死锁</p><h2 id="封锁的粒度"><a href="#封锁的粒度" class="headerlink" title="封锁的粒度"></a>封锁的粒度</h2><p>封锁的对象可以是逻辑单元（属性值、元组、关系、索引等）、也可以是物理单元（页、物理记录）</p><p>封锁粒度越大，系统开销越小，并发度也小。</p><h3 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h3><p>对于不同事务，封锁粒度不一致，需要处理大量元组的事务就封锁关系、需处理少量元组的事务就只需要封锁相应元组</p><h3 id="多粒度树"><a href="#多粒度树" class="headerlink" title="多粒度树"></a>多粒度树</h3><p>用树结构表示数据库的逻辑单元，根是数据库，叶是最小的数据粒度。</p><p>常用的是<strong>三级粒度树</strong>：</p><p><img src="/images/oneplusnameless/image-20221220164444763.png" alt="image-20221220164444763"></p><p>对于一个数据对象节点，封锁有两种：</p><ul><li>显式封锁：在这个节点加锁</li><li>隐式封锁：在上级节点加了锁，这个节点自然也被锁了</li></ul><p>所以在上锁的时候，除了检查本节点，还要检查其所有祖先节点和子节点：</p><ul><li>本对象当然不能够有锁</li><li>上级节点也不能够有锁，因为这会导致本节点有隐式锁</li><li>下级节点也不能够被上锁，因为本节点会对下级节点上隐式锁</li></ul><p>所以这个过程其实是很麻烦的，要检查所有上下级节点</p><p>为了这个检查过程的方便，就引入了意向锁</p><h3 id="意向锁Intent-Lock"><a href="#意向锁Intent-Lock" class="headerlink" title="意向锁Intent Lock"></a>意向锁Intent Lock</h3><p>当给一个节点上锁的时候，要对其<strong>所有上节点加意向锁</strong>，这样就不必要在加锁的时候检查大量下节点了</p><p>由于锁分为共享锁和排它锁，所以意向锁也有分类：</p><ul><li>意向共享锁（IS锁）：说明这个节点的某子节点加了S锁</li><li>意向排它锁（IX锁）：说明这个节点的某子节点加了X锁</li><li>共享意向排它锁（SIX锁）：SIX=S+IX，即这个节点自身加了S锁，某子节点加了X锁</li></ul><p>一个5*5的锁相容矩阵就来了：</p><p><img src="/images/oneplusnameless/image-20221220171115002.png" alt="image-20221220171115002"></p><p>锁的强度：</p><p><img src="/images/oneplusnameless/image-20221220172108647.png" alt="image-20221220172108647"></p><p><strong>申请封锁应该自上而下、释放封锁应该自下而上</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章首先抛出的交叉并发可能导致的问题：丢失修改、不可重复读、读脏数据</p><p>数据库是围绕锁来进行并发控制的</p><p>首先介绍了最基础的锁：共享锁和排它锁。</p><p>有了基本的两种锁还不行，需要统一规定一个上锁的策略，根据上锁策略严格程度分为三级封锁协议：</p><ul><li>一级：写之前上排它锁，事务结束释放</li><li>二级：一级 + 读之前上共享锁，读完释放</li><li>三级：一级 + 读之前上共享锁，事务结束释放</li></ul><p>有了锁，就有等待，进而可能出现活锁和死锁：</p><ul><li>活锁指因为调度问题，某个事物等待非常久</li><li>死锁指进入了一个死循环</li></ul><p>死锁的条件是</p><ul><li>请求互斥的共享资源</li><li>占有的资源不可被剥夺</li><li>持续占有并等待</li><li>相互循环等待</li></ul><p>死锁的预防手段有：一次封锁和顺序封锁法</p><p>DB的死锁处理一般倾向于诊断后解除而不是预防</p><p>死锁的诊断方法有：超时法和等待图法</p><p>死锁的解除比较简单：选择代价小的UNDO</p><p>为了判断一个调度的正确性，可以按照其结果是否与串行结果中的一个一致，这样的调度叫做可串行化调度</p><p>冲突可串行化则是更加严苛的概念，表示一个调度在一系列非冲突操作对的对换以后，可以变换成串行调度</p><p>两段锁协议是保障可串行化的方法，但是其不能预防死锁</p><p>最后还介绍了多粒度封锁，可以依据事务的不同，决定封锁的级别，多粒度封锁一般用多粒度树表示</p><p>上级节点封锁会给下级节点上隐式锁，在给一个节点上锁的时候，还需要判断上级有没有给其上隐式锁，以及本节点需要对下级节点上显式锁，这会导致本节点无法对下级节点上隐式锁</p><p>上述的检查过程是非常麻烦的，尤其是检查数量繁多的下级节点，所以引入了意向锁，表示被上意向锁的下级节点中有被上锁的</p><p>根据锁类型的不同，意向锁又分为IS/IX/SIX锁，再加上S/X锁，五种锁之间有了一个5*5的锁相容矩阵</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第十章 数据库恢复技术</title>
      <link href="/2022/12/19/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
      <url>/2022/12/19/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><p>想要学好这一章的恢复技术以及下一章的并发控制，首先需要了解这两个技术考虑的基本单位：事务（Transaction）</p><h3 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h3><p><strong>事务</strong>是数据库操作的序列，这些操作不可分割</p><p>事务不等于程序，一个程序往往有多个事务</p><p>事务在恢复和并发控制中是基本单位</p><h4 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h4><p>事务可以显式定义，在一串SQL语句最后加上：</p><ul><li>COMMIT：表示事务结束、提交操作结果</li><li>ROLLBACK：事务异常、回滚到事务执行前的状态</li></ul><p>当然没有用上面的显示方法定义的话，系统会自动划分</p><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>概括为ACID：</p><ul><li>原子性Atomicity：事务的操作要么全做、要么全不做</li><li>一致性Consistency：事务不能够运行到一半终止且不回滚</li><li>隔离性Isolation：并发事务互不干扰</li><li>持续性Durability：事务对DB的改变是永久性的，不会被其他操作或者故障干扰</li></ul><h2 id="数据库恢复概述"><a href="#数据库恢复概述" class="headerlink" title="数据库恢复概述"></a>数据库恢复概述</h2><p>DBS在完整执行一个事务以后，会从一个一致状态（或正确状态）转变到另一个一致状态。而如果执行过程中发生了某些错误，就会导致DB停留在不一致的状态，<strong>恢复的目的就是把DB从不一致状态恢复到一致状态。</strong></p><h2 id="故障种类"><a href="#故障种类" class="headerlink" title="故障种类"></a>故障种类</h2><h3 id="事务内部故障"><a href="#事务内部故障" class="headerlink" title="事务内部故障"></a>事务内部故障</h3><ul><li><p>可预期故障：比如转账事务余额不足等，比较好解决，在程序里面ROLLBACK就行</p></li><li><p>不可预期故障：</p><ul><li>运算溢出</li><li>并发死锁</li><li>违法完整性</li></ul><p>这类故障较难考虑周到，没办法在程序里面写好处理</p></li></ul><p>这时就需要DBMS强制ROLLBACK（UNDO处理）</p><h3 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h3><p>又叫软故障，整个系统都停止了运作，比如断电。此时执行的所有事物都异常终止了。</p><p>恢复策略：</p><ul><li>对于部分已经写入物理数据库的事务：强行撤销回滚（UNDO）</li><li>对于已经完成但是没有COMMIT的事务：重做（REDO）</li></ul><h3 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h3><p>硬盘寄了</p><h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><p>没啥好说的</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总的来说，数据库破坏分为两种：</p><ul><li>数据库本身被破坏（介质故障、病毒）</li><li>数据不正确（事务故障、系统故障）</li></ul><p>我们主要讨论第二种</p><p>主要使用<strong>冗余</strong>来帮助恢复和重建</p><h2 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h2><p>主要有转储、日志文件两种方法</p><h3 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h3><p>指定期的为整个数据库中的文件创建一个<strong>后备副本</strong>，遭到破坏以后需要重新装入，可以<strong>恢复到转储时的状态</strong></p><p>如果想要将事务恢复到故障发生状态的话，还需要重新运行转储以后的所有事务</p><h3 id="转储分类"><a href="#转储分类" class="headerlink" title="转储分类"></a>转储分类</h3><h4 id="动态与静态"><a href="#动态与静态" class="headerlink" title="动态与静态"></a>动态与静态</h4><p>转储不是一个瞬间过程，需要持续一段时间，根据转储的时候是否可以继续操作DB分为动态和静态转储</p><p><strong>静态转储</strong>实现很简单，但是降低了数据库的可用性</p><p><strong>动态转储</strong>可用性更高，但是需要一定技术来保证副本是有效的，这时就需要用到<strong>日志文件</strong>，记录转储过程中又有一些什么操作</p><h4 id="海量和增量"><a href="#海量和增量" class="headerlink" title="海量和增量"></a>海量和增量</h4><p>熟悉手机刷机的对这个应该比较熟悉，海量更新就是每次都转储数据库的全部数据，增量更新就是只转储更新过的数据</p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><h4 id="日志的格式和内容"><a href="#日志的格式和内容" class="headerlink" title="日志的格式和内容"></a>日志的格式和内容</h4><p>日志文件有以记录为单位的也有以块为单位的</p><p><strong>以记录为单位的日志文件：</strong></p><ol><li>事务开始的标记</li><li>事务结束的标记</li><li>事务包含的所有更新操作</li></ol><p><strong>具体每条记录的内容：</strong></p><ul><li>事务表示</li><li>操作类型</li><li>操作对象</li><li>旧值</li><li>新值</li></ul><p><strong>以数据块为单位的日志文件：</strong></p><ol><li>事务标识</li><li>更新前后的数据块</li></ol><h3 id="日志文件的作用"><a href="#日志文件的作用" class="headerlink" title="日志文件的作用"></a>日志文件的作用</h3><ul><li>可以用于事务故障和系统故障的恢复</li><li>按照之前所说，可以协助后备副本恢复</li></ul><h3 id="登记日志文件"><a href="#登记日志文件" class="headerlink" title="登记日志文件"></a>登记日志文件</h3><p>登记日志文件的时候需要严格遵守如下两条原则：</p><ul><li>严格按照时间顺序等级</li><li>先写日志再写数据库</li></ul><h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><h3 id="事务故障的恢复"><a href="#事务故障的恢复" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h3><p>直接UNDO即可：</p><ol><li>反向扫描日志文件</li><li>对于事务的更新做反向操作</li></ol><h3 id="系统故障的恢复"><a href="#系统故障的恢复" class="headerlink" title="系统故障的恢复"></a>系统故障的恢复</h3><p>系统故障导致的故障事务有两种：</p><ul><li>未完成的事务</li><li>已经提交但是还留在buffer未写入数据库的事务（<strong>有commit</strong>）</li></ul><p>对于第一条·未完成的事务，和上面一样UNDO即可</p><p>对于已完成在buffer中的事务，采用REDO做法</p><h3 id="介质故障的恢复"><a href="#介质故障的恢复" class="headerlink" title="介质故障的恢复"></a>介质故障的恢复</h3><ol><li>装入最近的副本<ul><li>静态的直接装</li><li>动态的配合日志</li></ul></li><li>redo副本完成-故障期间的事务</li></ol><h2 id="具有检查点的恢复技术"><a href="#具有检查点的恢复技术" class="headerlink" title="具有检查点的恢复技术"></a>具有检查点的恢复技术</h2><p>前面说的搜索日志实在是太费时间了，所以在日志文件中添加了检查点记录（check point）和一个重新开始文件，可以动态的维护日志</p><p>检查点的内容：</p><ul><li>建立检查点时，正在执行的事务</li><li>这些事务最近日志记录的地址</li></ul><p>重新开始文件的内容：</p><ul><li>各个检查点记录在日志文件中的地址</li></ul><p>可以理解为，检查点指向记录，重新开始文件指向检查点</p><h3 id="利用检查点的恢复策略"><a href="#利用检查点的恢复策略" class="headerlink" title="利用检查点的恢复策略"></a>利用检查点的恢复策略</h3><p><img src="E:\Blog\source\images\oneplusnameless\image-20221219203258683.png" alt="image-20221219203258683"></p><p><strong>只看完成时间，不看开始时间</strong></p><ul><li>在检查点之前完成的：不用管</li><li>在检查点之后、系统故障之前完成的：重做</li><li>在故障时还没完成的：撤销</li></ul><h2 id="数据库镜像"><a href="#数据库镜像" class="headerlink" title="数据库镜像"></a>数据库镜像</h2><p>数据库镜像是针对介质故障的方法</p><p>数据库会把其<strong>全部或部分</strong>复制一个镜像，DBMS会自动维护其一致性，出现故障的时候就可以使用镜像并从镜像恢复</p><p>一般来说只会对<strong>关键数据和日志文件镜像</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章讲的是数据库在发生数据不一致或者错误之后的恢复技术，首先介绍了数据库恢复和并发控制的基本单位——事务，以及事务的ACID四大特性</p><p>考虑数据库的恢复，先要考虑数据库运行过程中可能的故障：事务内部故障、系统故障、介质故障和计算机病毒。本课程着重考察前两者。</p><p>数据库的恢复主要依靠两个技术——转储和日志。</p><p>转储，即把数据库复制一个后备副本，在需要的时候可以用副本来恢复。</p><p>转储根据是否可以在转储时工作分为动态和静态，同时还有海量和增量之分。动态转储需要配合日志使用。</p><p>日志有以记录为单位和以数据块为单位的，这里主要讨论以记录为单位的。日志可以单独用于恢复，也可以协助动态转储恢复。</p><p>记录日志的时候，一定要先写日志再写数据库。</p><p>对于事务故障，一般采用UNDO也就是系统强制ROLLBACK</p><p>对于系统故障，一般根据事务是执行到一半被终止还是执行完了在buffer没来得及写入。前者和事务故障一样需要UNDO、后者需要REDO。</p><p>介质故障必须要日志+转储强制使用。</p><p>检查点其实是日志的一种升级，检查点记录了当前事务和事务最近活动的记录位置，可以方便查找事务，而所有的检查点又被存到了重新开始文件中。</p><p>数据库镜像主要是针对介质故障的，镜像可以是部分关键数据和日志文件的，在从镜像恢复数据库的过程中，镜像可以运行开保障数据库的可用性。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一加8T刷入namelessOS</title>
      <link href="/2022/12/19/%E4%B8%80%E5%8A%A08T%E5%88%B7%E5%85%A5namelessOS/"/>
      <url>/2022/12/19/%E4%B8%80%E5%8A%A08T%E5%88%B7%E5%85%A5namelessOS/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>一台一加8/9手机（废话）</p><ul><li>本教程使用一加8T、ColorOS13</li></ul></li><li><p><a href="https://nameless.wiki/category/download">Download | Nameless AOSP</a>下载如下软件：</p><ul><li><p>最新刷机包：</p><p><img src="/images/oneplusnameless/image-20221219110803199.png" alt="image-20221219110803199"></p></li><li><p>四个image镜像：</p><p><img src="/images/oneplusnameless/image-20221219110826171.png" alt="image-20221219110826171"></p></li></ul></li><li><p><a href="https://nameless.wiki/getting-started/install/for_8_9R">For OnePlus 8/8 Pro &amp; 8T/9R | Nameless AOSP</a>下载工具：</p><ul><li><p>platform-tools：</p><p><img src="/images/oneplusnameless/image-20221219111008416.png" alt="image-20221219111008416"></p></li><li><p>Google USB driver：</p><p><img src="/images/oneplusnameless/image-20221219111028900.png" alt="image-20221219111028900"></p></li></ul></li></ul><h2 id="系统内解锁"><a href="#系统内解锁" class="headerlink" title="系统内解锁"></a>系统内解锁</h2><p>下面的操作在手机系统内完成：</p><h3 id="解锁开发者模式"><a href="#解锁开发者模式" class="headerlink" title="解锁开发者模式"></a>解锁开发者模式</h3><p>设置-关于本机-版本信息，快速连续点击十次版本号，然后就会提示输入锁屏密码进入开发者模式</p><p><img src="/images/oneplusnameless/50e68c266b5449ff106a54535127cf3.jpg" alt="50e68c266b5449ff106a54535127cf3"></p><h3 id="开启USB调试与OEM解锁"><a href="#开启USB调试与OEM解锁" class="headerlink" title="开启USB调试与OEM解锁"></a>开启USB调试与OEM解锁</h3><p>打开了开发者模式中，可以在设置-系统设置中找到开发者选项，开启其中的OEM解锁和USB调试：</p><p><img src="/images/oneplusnameless/7cda331d6b562b1b9ad338d2ff14b6c.jpg" alt="7cda331d6b562b1b9ad338d2ff14b6c"></p><h2 id="解锁Bootloader"><a href="#解锁Bootloader" class="headerlink" title="解锁Bootloader"></a>解锁Bootloader</h2><p><strong>注意：解锁BL会格式化手机、做好备份</strong></p><p>手机开机状态下连接电脑，会弹出USB调试信息，同意即可。</p><p>在之前下载的platform-tools文件夹打开命令行，输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./adb.exe devices</span><br></pre></td></tr></table></figure><p>就可以看到设备了：</p><p><img src="/images/oneplusnameless/image-20221219112346386.png" alt="image-20221219112346386"></p><p>然后输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./adb.exe reboot bootloader</span><br></pre></td></tr></table></figure><p>这时手机会自动重启到这个界面（图是网上随便找的）：</p><p><img src="/images/oneplusnameless/image-20221219112200025.png" alt="image-20221219112200025"></p><p>然后输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fastboot.exe flashing unlock</span><br></pre></td></tr></table></figure><p>你的手机会提示你是否要解锁bl：</p><p><img src="/images/oneplusnameless/image-20221219112628704.png" alt="image-20221219112628704"></p><p>按音量上下可以选择，选第二个，然后按电源键确认。</p><p>然后手机格式化并解锁BL，等待一会以后，重新进入系统。</p><p>由于系统被格式化了，所以需要重复第一步打开USB调试和OEM解锁。</p><h2 id="刷入四个image"><a href="#刷入四个image" class="headerlink" title="刷入四个image"></a>刷入四个image</h2><p>在plateform-tools目录下使用cmd（注意是cmd命令提示符，而不是windows powershell）</p><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb.exe reboot fastboot</span><br></pre></td></tr></table></figure><p>手机会进入fastboot模式：</p><p><img src="/images/oneplusnameless/image-20221219115434920.png" alt="image-20221219115434920"></p><p>把四个img文件放入到platform-tools/images文件夹，然后依次执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash boot images/boot.img</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash --disable-verity --disable-verification vbmeta images/vbmeta.img</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash --disable-verity --disable-verification vbmeta_system images/vbmeta_system.img</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash recovery images/recovery.img</span><br></pre></td></tr></table></figure><p><img src="/images/oneplusnameless/image-20221219113849951.png" alt="image-20221219113849951"></p><h2 id="刷入系统"><a href="#刷入系统" class="headerlink" title="刷入系统"></a>刷入系统</h2><p>上一步四个image都刷入完毕以后，在手机上选择：高级-重启到恢复模式：</p><p>然后如图所示手机会进入恢复模式（注意恢复模式是可以直接触屏操作的哦）：</p><p><img src="/images/oneplusnameless/image-20221219115529504.png" alt="image-20221219115529504"></p><p>选择Install update - ADB Sideload</p><p>然后把刷机包的zip文件也放到platform-tools文件夹，cmd输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb sideload 刷机包名字.zip</span><br></pre></td></tr></table></figure><p>然后你的手机就会开始刷入新系统了…</p><p><img src="/images/oneplusnameless/image-20221219114930221.png" alt="image-20221219114930221"></p><h2 id="刷入完毕"><a href="#刷入完毕" class="headerlink" title="刷入完毕"></a>刷入完毕</h2><p>上面的windows进度条会有一些bug，刷入完成后进度条大概只在50%左右</p><p>所以以手机显示的进度为准，完成时如下图，手机最下面会有一个Step2/2：</p><p><img src="/images/oneplusnameless/image-20221219115635311.png" alt="image-20221219115635311"></p><p>然后点击左上角的返回键，回到recovery首页，选择”Factory reset”-&gt;”Format data/factory reset”-&gt;”Format data”</p><p>然后Format data结束以后，返回到recovery首页点击reboot to system就可以进入新系统了。</p><p><img src="/images/oneplusnameless/image-20221219115943950.png" alt="image-20221219115943950"></p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓刷机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第九章 查询优化</title>
      <link href="/2022/12/18/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2022/12/18/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>本章大体介绍了一个查询语句是怎么在DBMS中运作的，并且给出了几种经典情况的代数、物理优化方法。</p><h2 id="DBMS的查询处理"><a href="#DBMS的查询处理" class="headerlink" title="DBMS的查询处理"></a>DBMS的查询处理</h2><p>DBMS的查询处理分为四个阶段：</p><ol><li><p>查询分析</p><ul><li>词法分析：分析SQL符号</li><li>语法分析：语法检查</li></ul></li><li><p>查询检查</p><ul><li>语义分析</li><li>符号转换</li><li>安全性、完整性检查</li></ul><p>查询检查后、会构建好查询树，针对查询树来进行代数优化</p></li><li><p>查询优化</p><ul><li>代数优化</li><li>物理优化</li></ul><p>优化以后，就可以生成一个查询执行计划</p></li><li><p>查询执行</p><ul><li>代码生成器会按照上一步的查询执行计划生成代码来执行</li></ul></li></ol><h3 id="查询算法的实例"><a href="#查询算法的实例" class="headerlink" title="查询算法的实例"></a>查询算法的实例</h3><h4 id="选择操作的实现"><a href="#选择操作的实现" class="headerlink" title="选择操作的实现"></a>选择操作的实现</h4><ul><li><strong>全表扫描</strong><ol><li>按照物理次序入读数据块到内存</li><li>检查元组，满足则输出</li><li>重复直到读完内存为止</li></ol></li><li><strong>索引扫描</strong><ol><li>使用索引得到符合条件的元组指针</li><li>通过制作检索</li></ol></li></ul><h4 id="连接操作的实现"><a href="#连接操作的实现" class="headerlink" title="连接操作的实现"></a>连接操作的实现</h4><ul><li><p><strong>嵌套循环算法nested loop join</strong></p><p>​    for 外层循环: (for 内层循环)</p></li><li><p><strong>排序-合并算法sort-merge join</strong></p><ol><li>两个表都对连接字段排序</li><li>也是两个循环，但是内层循环不需要每次都从0开始</li></ol></li><li><p><strong>索引连接算法index join</strong></p></li></ul><p>​        一个表索引、遍历另一个表，直接根据索引连接</p><ul><li><p><strong>Hash Join</strong></p><ol><li>划分阶段：选择元组较少的表，Hash到内存中对应的bucket</li><li>试探（连接）阶段：hash另一个表中的元组，找到bucket中对应的连接输出</li></ol><p>适用场景：一个表小（可以Hash散列到内存中）、一个表较大，只支持等值连接</p></li></ul><h2 id="关系数据库系统的查询优化"><a href="#关系数据库系统的查询优化" class="headerlink" title="关系数据库系统的查询优化"></a>关系数据库系统的查询优化</h2><p>RDBMS的查询路径是透明的，RDBMS可以考虑比程序员更多、更复杂的优化并从中选取代价最小的</p><p><strong>查询的代价 =</strong> <strong>I/O代价（最主要的）</strong>+ CPU代价 + 内存代价 + 通信代价</p><p>下面用一个例子来阐述查询优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sname</span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span> SC.Cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span>;</span><br></pre></td></tr></table></figure><p>假设Student表有1000条记录、SC表有10000条记录，其中有50条选2号课程的记录。</p><p>一个块可以装10条Student或者100条SC、内存中可以存放5块Student、1块SC</p><ul><li><p><strong>Q1 = </strong>$\pi<em>{\text {Sname }}\left(\sigma</em>{\text {Student.Sno }=\text { SC.Sno } \and \text { SC.Cno }=’2’}(\text { Student } \times \text { SC })\right)$</p><p>也就是先连接然后投影，下面分析其效率</p><ul><li>每次读取5块student表，然后遍历一次SC，一共$\frac{1000}{5\times10}\times \frac{10000}{100}=2000$块，Student表本身需要读$\frac{1000}{10}$块</li><li>连接以后的元组有1000×10000个，还是假设一个块可以装10条连接以后的元组，那么需要写入1000000块到中间文件</li><li>选择的时候，又要读入这1000000块，投影输出满足条件的50条</li></ul></li><li><p><strong>Q2 = </strong>$\pi<em>{\text {Sname }}\left(\sigma</em>{\text {SC.Cno }=’2’}(\text { Student } \bowtie \text { SC })\right)$</p><ul><li>执行自然连接，需要读取的还是2000+100=2100块</li><li>连接以后的元组就大大减少了，为10000个，所以只要写入1000块到中间文件</li><li>读入这1000块，投影输出满足条件的50条</li></ul></li><li><p><strong>Q3 = </strong>$\pi<em>{\text {Sname }}\left(\text { Student } \bowtie \sigma</em>{\text {SC.Cno }=’2’}(\mathrm{SC})\right)$</p><ul><li>读入SC，需要读入10000/100=100块，然后选择出其中的50条、不需要中间文件</li><li>与Student自然连接，需要读入100块</li><li>投影输出结果</li></ul></li></ul><p>优化到Q3以后，I/O就只要读写200块了。</p><p><strong>对于Q3的继续优化：</strong></p><ul><li>如果在SC.Cno有索引，那么就不需要读入SC，而是读入索引（占大概3-4块）</li><li>如果Student.Sno也有索引，那么连接时也不要读入所有的记录</li></ul><p>在上述过程中：从Q1优化为等价的关系代数表达式Q3，就是一种<strong>代数优化</strong>；上面的两个索引就是<strong>物理优化</strong>。</p><h2 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h2><h3 id="关系代数表达式的等价变换规则"><a href="#关系代数表达式的等价变换规则" class="headerlink" title="关系代数表达式的等价变换规则"></a>关系代数表达式的等价变换规则</h3><p>比较多， 不要死记硬背，能够分析改变以后会不会影响结果就行</p><ol><li>连接和笛卡尔积两边可交换</li><li>多重连接、笛卡尔积的结合律</li><li>投影串接：两次投影可以合并</li><li>选择串接：两次选择可以合并</li><li>投影与选择交换：若选择不涉及投影属性，可以先投影再选择</li><li>选择与笛卡尔积交换</li><li>选择与并/差/自然连接可以分配</li><li>投影与并/笛卡尔积可以分配，但是对差没有</li></ol><h3 id="查询树的启发式优化"><a href="#查询树的启发式优化" class="headerlink" title="查询树的启发式优化"></a>查询树的启发式优化</h3><p>前面说过，DBMS会把SQL转化成查询树结构，查询树的叶子节点是关系、非叶子节点是关系运算符，执行顺序是从叶子到根。</p><p><strong>典型的几条启发式规则：</strong></p><ul><li><strong>选择运算尽可能先做</strong>（最重要、可以很大量级的减少中间元组数量）</li><li>同时选择和投影：选择到元组输出的时候顺便做个投影</li><li>投影与其前后的双目运算结合</li><li>将 先笛卡尔积再选择 转化为 连接</li><li>找出公共子表达式：重复出现、元组不多的子表达式可以写入中间文件</li></ul><p><strong>利用规则得到一种启发式算法：</strong></p><ol><li><p>将$\sigma <em>{F_1 \and …\and F_n}(E)$转化为$\sigma</em>{F<em>1}(…(\sigma</em>{F_n}(E)))$</p><p>起初我在想，本来合并了选择条件，扫描表的次数变少了，为什么又要拆开呢？</p><p>实际上，多个条件并在一起的判断时间开销会很大，而单个单个执行，其实第一次得到的结果就减少了很多、然后再执行一个又减少很多，实际遍历并不多。</p></li><li><p>对于选择，尽量移动到叶端</p></li><li><p>对于投影，尽量移动到叶端</p></li><li><p>合并投影和附近其他运算</p></li><li><p>得到语法树的内节点分组：双目运算和其所有祖先为一组、如果后代所有节点都是单目的，也并入</p></li></ol><p>​    <img src="/images/DBSNote/image-20221218221623376.png" alt="image-20221218221623376"></p><h2 id="物理优化"><a href="#物理优化" class="headerlink" title="物理优化"></a>物理优化</h2><p>选择高效的算法和存取路径</p><p>物理优化算法主要分为两类：基于规则的启发式优化、基于代价估算的优化</p><p>一般是两者结合，启发式的找出若干方案，然后估算代价找出最优的</p><h3 id="基于启发式规则的存取路径选择优化"><a href="#基于启发式规则的存取路径选择优化" class="headerlink" title="基于启发式规则的存取路径选择优化"></a>基于启发式规则的存取路径选择优化</h3><h4 id="选择操作的启发式规则"><a href="#选择操作的启发式规则" class="headerlink" title="选择操作的启发式规则"></a>选择操作的启发式规则</h4><ul><li>小关系直接扫描</li><li>大关系<ul><li>”主码=？“：一般主码会索引</li><li>”非主属性=？“：结果比例较小可以索引，比例较大直接扫描</li><li>非等值：结果比例较小可以索引，比例较大直接扫描</li><li>and连接多个条件：<ul><li>有组合索引用组合索引</li><li>有一般索引可以求交</li><li>其他情况使用全表扫描</li></ul></li><li>or连接多个条件：一般直接扫描</li></ul></li></ul><h4 id="连接操作的启发式规则"><a href="#连接操作的启发式规则" class="headerlink" title="连接操作的启发式规则"></a>连接操作的启发式规则</h4><ul><li>两个表都已经排序：sort-merge join</li><li>在一个表索引：index join</li><li>一个表比较小一个表比较大：hash join</li><li>如果使用nested loop join，外层循环应该选择较小的表</li></ul><h3 id="基于代价的优化"><a href="#基于代价的优化" class="headerlink" title="基于代价的优化"></a>基于代价的优化</h3><p>DBMS对于一些信息进行了统计，比如：</p><ul><li>对于基本表<ul><li>元组长度、个数</li></ul></li><li>对于列<ul><li>值个数</li><li>最大最小值</li><li>是否索引</li><li>值分布</li></ul></li><li>对索引<ul><li>索引层数</li><li>不同索引值个数</li></ul></li><li>…</li></ul><p>根据这些信息，可以对算法得代价估算（数学期望），然后取最小的</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>（这一章说是不作为重点，只考概念，但是概念也有够多了…</p><p>要了解DBMS是怎么去优化查询语句的，首先要知道是怎么处理的查询：首先分析词法语法、然后进行安全性完整性等检查、然后转化为查询树来进行代数&amp;物理优化、最后生成代码执行</p><p>然后介绍了基础的选择、连接操作实现</p><p>对于优化，举了一个例子，指出了其中的代数优化和物理优化的步骤</p><p>对于代数优化的详细叙述，主要介绍了启发式优化：最重要的是先做选择运算，另外，投影可以尽量和其他运算合并、避免笛卡尔积、找出公共子表达式等</p><p>这里还介绍了语法树内节点分组的概念</p><p>物理优化方面，并用启发式和代价估算两种优化</p><p>选择算法的启发式物理优化，可以根据是否索引、结果占比、条件类型等具体判断</p><p>连接算法的启发式物理优化，其实在之前连接操作的实现部分已经涉及到了，四大连接算法有各自的适用情况</p><p>而基于代价的物理优化，是基于DBMS掌握的一些统计信息来估算的</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第八章 JDBC与SQL注入</title>
      <link href="/2022/12/17/%E7%AC%AC%E5%85%AB%E7%AB%A0%20JDBC%E4%B8%8ESQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/12/17/%E7%AC%AC%E5%85%AB%E7%AB%A0%20JDBC%E4%B8%8ESQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>本章前面介绍了嵌入式SQL、过程化SQL、存储过程和函数、ODBC编程等，但是考试不做要求，暂且略过。</p><h2 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h2><p>Java Database Connectivity，Java语言调用有关API来<strong>连接数据库、发送SQL语句、获取查询结果</strong>等。</p><p><strong>JDBC API可以访问任何RDBMS</strong>，包含：</p><ul><li>JDBC Driver：驱动程序</li><li>Connection：数据库连接</li><li>Statement：执行SQL增删查改</li><li>ResultSet：查询返回的结果集</li></ul><h3 id="JDBC编程的步骤"><a href="#JDBC编程的步骤" class="headerlink" title="JDBC编程的步骤"></a>JDBC编程的步骤</h3><ol><li>加载驱动（.jar包）</li><li>连接数据库Connection</li><li>创建Statement对象</li><li>构造SQL DML语句</li><li>适用Statement对象发送SQL</li><li>DB Server收到以后执行，返回ResultSet后，Client执行逻辑处理</li><li>执行相关异常处理</li><li>关闭Statement、Connection</li></ol><h3 id="JDBC-SQL执行调用方式"><a href="#JDBC-SQL执行调用方式" class="headerlink" title="JDBC SQL执行调用方式"></a>JDBC SQL执行调用方式</h3><ul><li>execute()：所有的DDL、DML通用</li><li>executeQuery()：SELECT</li><li>executeUpdate()：INSERT、DELETE、UPDATE</li></ul><h3 id="JDBC-Prepared-Statement语法"><a href="#JDBC-Prepared-Statement语法" class="headerlink" title="JDBC Prepared Statement语法"></a>JDBC Prepared Statement语法</h3><p>先设置statement的大致语句，然后补充细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pStmt</span> <span class="operator">=</span> conn.prepareStatement(</span><br><span class="line"><span class="string">&quot;insert into instructor values(?,?,?,?)&quot;</span>);</span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>);</span><br><span class="line">pStmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);</span><br><span class="line">pStmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);</span><br><span class="line">pStmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88878&quot;</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br></pre></td></tr></table></figure><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>原因：</p><p><img src="/images/DBSNote/image-20221217215732148.png" alt="image-20221217215732148"></p><h3 id="SQL注入测试"><a href="#SQL注入测试" class="headerlink" title="SQL注入测试"></a>SQL注入测试</h3><p>可以使用经典的单引号判断法：<code>http://xxx/abc.php?id=1&#39;</code>给服务器发送”1’”这个字符串，如果页面返回错误，那么一定有SQL注入存在。</p><h3 id="SQL注入的例子（JAVA）"><a href="#SQL注入的例子（JAVA）" class="headerlink" title="SQL注入的例子（JAVA）"></a>SQL注入的例子（JAVA）</h3><h4 id="单引号’"><a href="#单引号’" class="headerlink" title="单引号’"></a>单引号’</h4><p>假设JDBC编程时这样构造查询语句的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;select * deom instructor where name =&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span></span><br></pre></td></tr></table></figure><p>如果发送<code>?name =X&#39;or&#39;Y&#39;=&#39;Y</code> </p><p>那么服务器端得到的语句就变成了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> instructor <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;X&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;Y&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span></span><br></pre></td></tr></table></figure><p>这样一来判断条件就变成了永真</p><h4 id="SQL注释符—"><a href="#SQL注释符—" class="headerlink" title="SQL注释符—"></a>SQL注释符—</h4><p>假设程序逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;select * from users where username = &#x27;&quot;</span> + formusr + <span class="string">&quot;&#x27;and password =&#x27;&quot;</span> + formpwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果输入的user是<code>admin&#39;--</code>，password随便填（比如123），语句则为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span><span class="comment">--&#x27;and password = &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>那么<code>--</code>后面的都会被注释掉，直接得到了admin</p><h4 id="分号"><a href="#分号" class="headerlink" title="分号;"></a>分号;</h4><p>程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;select * from users where userid = &quot;</span> + userid;</span><br></pre></td></tr></table></figure><p>输入userid为<code>1;delete users;</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> userid <span class="operator">=</span> <span class="number">1</span>;<span class="keyword">delete</span> users;</span><br></pre></td></tr></table></figure><h4 id="SQL注释符"><a href="#SQL注释符" class="headerlink" title="SQL注释符"></a>SQL注释符</h4><p>同—</p><h4 id="常用SQL注入特殊字符总结"><a href="#常用SQL注入特殊字符总结" class="headerlink" title="常用SQL注入特殊字符总结"></a>常用SQL注入特殊字符总结</h4><p><img src="/images/DBSNote/image-20221217221644607.png" alt="image-20221217221644607"></p><h3 id="SQL注入的预防"><a href="#SQL注入的预防" class="headerlink" title="SQL注入的预防"></a>SQL注入的预防</h3><ul><li>使用之前提到的Prepared Statement，必须用参数化的传递方式setXXX()</li><li>使用存储过程</li><li>根本方法：检查用户输入，转义特殊字符</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一章内容比较少，一是JDBC、二是SQL注入及其防范</p><p>JDBC部分，介绍了其基本组件、使用JDBC操作数据库的基本流程、JDBC的三种调用函数、Prepared Statement</p><p>SQL注入方面，介绍了通过’、—、;、#等字符的注入构造，同时介绍了对于SQL注入的预防方法</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第七章 关系数据库设计</title>
      <link href="/2022/12/17/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/12/17/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>从名字就能看出来，这一章东西是比较多且杂的。</p><p>首先回顾一下第一章的数据模型：</p><ul><li>概念模型存在于信息世界，是用户和分析人员的交流工具，本章很重要的E-R图就是概念模型的一种</li><li>数据模型是计算机世界中的模型，前面大费周章讲的关系模型就是数据模型</li></ul><p>数据建模的过程是：<strong>理解-区分-命名-表达</strong>的过程</p><h2 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h2><h3 id="数据库设计的特点"><a href="#数据库设计的特点" class="headerlink" title="数据库设计的特点"></a>数据库设计的特点</h3><p>（这里屁话比较多，主要是有两个定义</p><p><strong>元数据：</strong>“数据的数据”，包括数据的来源、结构、编码规范、大小、格式等特征。</p><p><strong>主数据：</strong>反映核心业务实体状态属性的企业基础信息，充分共享、高度复用。</p><p>数据库设计中，结构设计和行为设计要结合，不能够和传统的软件设计一样只注重行为、也不能够和早期数据库一样忽略了行为设计。</p><h3 id="数据库的设计方法"><a href="#数据库的设计方法" class="headerlink" title="数据库的设计方法"></a>数据库的设计方法</h3><p>主要采用基于E-R模型和3NF的设计方法</p><h3 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h3><p>数据库设计的基本步骤分为如下六个阶段，但是要注意的是这六个阶段不是执行完就不管了，往往需要在实际中<strong>不断重复、迭代</strong></p><ol><li>需求分析：数据字典、数据结构、数据流…</li><li>概念结构设计：E-RD</li><li>逻辑结构设计：关系模型</li><li>物理结构设计：存取方法、存取路径</li><li>数据库实施：创Schema、载入数据、试运行</li><li>数据库运行和维护：性能检测、转储/恢复、重构</li></ol><p>其中逻辑和物理设计与选择的DBMS关系密切</p><p>在数据库的设计人员中，有：</p><ul><li>系统分析人员和数据库设计人员</li><li>DBA和用户代表</li><li>App开发人员</li></ul><h3 id="三个关键步骤的细粒度和内容"><a href="#三个关键步骤的细粒度和内容" class="headerlink" title="三个关键步骤的细粒度和内容"></a>三个关键步骤的细粒度和内容</h3><p>如下图所示，三种模型主要有如下区别：</p><ul><li>概念模型支持多对多，但是逻辑模型以后则不能够有多对多，需要找一个中间的关联实体</li><li>概念模型找出键和主要属性，逻辑模型和物理模型再进一步找细节属性</li></ul><p><img src="/images/DBSNote/image-20221216221541230.png" alt="image-20221216221541230"></p><p><img src="/images/DBSNote/image-20221216221742806.png" alt="image-20221216221742806"></p><h3 id="数据库设计的各级模式"><a href="#数据库设计的各级模式" class="headerlink" title="数据库设计的各级模式"></a>数据库设计的各级模式</h3><p><img src="/images/DBSNote/image-20221216203053565.png" alt="image-20221216203053565"></p><ul><li>如图所示，在需求分析阶段，综合分析各个要求，形成数据库的<strong>概念模式</strong>(E-R图)</li><li>然后将E-R图转化为关系模型等数据模型，成为<strong>逻辑模式</strong></li><li>为了安全性、方便性的考虑，在逻辑模式的基础上，需要设计<strong>外模式</strong></li><li>物理设计阶段，设计索引、存取路径等，也就是<strong>内模式</strong></li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>这个阶段实操性太强，在PPT和书本上面很难讲述完备</p><h3 id="需求分析的方法"><a href="#需求分析的方法" class="headerlink" title="需求分析的方法"></a>需求分析的方法</h3><p>调查步骤：</p><ul><li>组织机构情况</li><li>各部门业务活动</li><li>用户要求</li><li>系统边界</li></ul><p>调查方法：</p><ul><li>观察</li><li>访谈</li><li>介绍</li><li>询问</li><li>问卷</li><li>…</li></ul><p>分析方法：结构化分析方法SA，自顶向下逐层分解</p><h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><p><strong>内容：</strong>包含数据项、数据结构、数据流、数据存储、处理过程</p><ul><li>数据项：不可再分的数据单位</li><li>数据结构：若干个数据项、子数据结构组成</li><li>数据流：数据结构在系统内的传输路径</li><li>数据存储：数据流的来源和去向，数据结构停留存储的地方</li></ul><h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><p>将用户需求抽象为概念模型，这里主要采用E-R模型</p><h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p>注：本课程要求使用Crow’s Foot表示E-R图。</p><p>E-R模型是一种表示关系及其联系的方法，在Crow’s Foot方法中，使用矩形（圆角矩形）表示关系，并将关系的属性一并列在方框中。</p><p>Crow’s Foot表示不仅可以表达1:1、1:n、m:n关系，还可以精确的表示是否包含0（是否是<strong>完全参与</strong>联系）</p><p><img src="/images/DBSNote/image-20221216213911610.png" alt="image-20221216213911610"></p><h3 id="概念结构设计-1"><a href="#概念结构设计-1" class="headerlink" title="概念结构设计"></a>概念结构设计</h3><p><strong>1.实体和属性的划分原则</strong>：实体有一系列不同的描述信息，属性不可分割、不能与其他实体有联系。<strong>可以视为属性的尽量作为属性。</strong></p><p><strong>2.E-R图的合并：</strong></p><p>各个子系统的E-R图常常是分开设计，然后汇总到一起，难免存在冲突：</p><ul><li>属性冲突：属性类型、属性单位不一致</li><li>命名冲突：同名异义、异名同义</li><li>结构冲突：有的局部中的实体在别的局部变成了属性、同一个实体的属性及属性排列不同、联系的类型不同</li></ul><p><strong>3.消除冗余：</strong>冗余的数据就是可以由其他数据导出的，可以看情况删除：存储与效率的tradeoff</p><h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><p>按照第一节表格中的说明，逻辑结构设计在把E-R图转化为关系模式以后，将属性识别完整、依据范式分解理论消除冗余，一般达到3NF即可。</p><h3 id="E-R图向关系模型的转换"><a href="#E-R图向关系模型的转换" class="headerlink" title="E-R图向关系模型的转换"></a>E-R图向关系模型的转换</h3><p>逻辑结构设计的第一步就是把之前得到的E-R图转化为关系模型，转换原则如下：</p><ol><li><p>一个实体型转换为一个关系模式：</p><ul><li>一般的属性，稍作适应计算机系统的变化就可以了</li><li>多值属性应该变成一个新的关系</li></ul></li><li><p>联系的转换：</p><ul><li><p>1:1联系，可以用外键表示、也可以用单独关系、<strong>甚至可以合并关系</strong>，具体选择方案需要看<strong>强制性</strong>：</p><p><img src="/images/DBSNote/image-20221217114457014.png" alt="image-20221217114457014"></p><ul><li>如果两端都是强制性的：如果<strong>根据实际应用需求</strong>可以合并则合并；否则使用外键，外键可以在任意一端。</li><li>如果一端强制、一端选择，那么一般将强制端作为选择端的外键，这样可以避免NULL外键的出现。</li><li>如果两端都是选择，那么为了避免NULL出现，最好是把联系作为单独关系。</li></ul></li><li><p>1:n联系：一般情况下倾向于采用把1端作为n端的一个外键。</p></li><li><p>m:n联系：只能够转化为一个独立关系</p></li><li><p>多元联系：也只能转化为一个独立关系</p></li></ul><p><strong>注：</strong>后面还有一些概念，如弱实体、特化、概化、常见DB设计模式、编码设计等，似乎不是很会考</p></li></ol><h3 id="数据模型的优化"><a href="#数据模型的优化" class="headerlink" title="数据模型的优化"></a>数据模型的优化</h3><p>在初步得到了关系模型以后，需要根据具体DBMS、3NF规则等来进行优化。</p><p>优化方法：</p><ol><li>确定数据依赖</li><li>对于各个关系模式之间的数据依赖进行极小化处理，消除冗余联系</li><li>确定各个关系模式是第几范式</li><li>按需求合并/分解范式，并不是规范程度越高就越好</li><li>对关系模式进行必要分解，提高操作、存储效率：<ul><li>水平分解：将有不同特征的元组分开存，如经常使用的数据存在一个表、不经常使用的存在一个表。</li><li>垂直分解：不常用、较大的属性拆分到另外一个表。</li></ul></li></ol><h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><p>在第一节就讲过，设计好了模式以后，需要在模式上面设计外模式，主要包含：</p><ul><li>使用别名，更符合用户的专业术语习惯</li><li>创建不同安全级别的视图</li><li>简化查询等用户操作</li></ul><h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><p>确定存储结构、存取方法等，优化时空效率。</p><h3 id="内容与方法"><a href="#内容与方法" class="headerlink" title="内容与方法"></a>内容与方法</h3><p><strong>准备：</strong>了解应用环境、事务、DBMS特性</p><p><strong>选择参数：</strong>查询的关系、属性、连接、投影的属性，更新的关系、属性等，以及各个事务的频率、性能要求等</p><p><strong>关系数据库设计中需要注意：</strong>存取路径，关系、索引等的物理存储结构</p><h3 id="存取方法的选择"><a href="#存取方法的选择" class="headerlink" title="存取方法的选择"></a>存取方法的选择</h3><p>常用的存取方法有：</p><ul><li>B+树索引存取</li><li>Hash索引存取</li><li>聚簇存取</li></ul><h4 id="B-树索引存取"><a href="#B-树索引存取" class="headerlink" title="B+树索引存取"></a>B+树索引存取</h4><p>适用条件：</p><ul><li>常常作为MAX、MIN的参数</li><li>作为连接条件</li><li>常需要排序</li></ul><h4 id="Hash索引存取"><a href="#Hash索引存取" class="headerlink" title="Hash索引存取"></a>Hash索引存取</h4><p>适用条件：等值连接/比较</p><h4 id="聚簇存取"><a href="#聚簇存取" class="headerlink" title="聚簇存取"></a>聚簇存取</h4><p>按照某个属性（组）来存，在其上值相同的物理上连续存放，这个属性（组）叫做聚簇码。</p><p><strong>适用条件：</strong></p><ul><li>很少增删、很少对变长列操作（否则维护开销非常巨大）</li><li>常按类型查询</li></ul><h3 id="反规范化设计"><a href="#反规范化设计" class="headerlink" title="反规范化设计"></a>反规范化设计</h3><p>虽然大体是按照3NF来设计，但有时为了效率，需要增加一些冗余。</p><ol><li>水平分割：之前提到过，把常用元组和不常用元组放在不同表</li><li>冗余字段：对于集中需要连接的字段</li><li>派生字段：属性的计算表达式，如果经常需要查询就可以添加到属性里边，减少计算</li><li>垂直分割：常要查询的列放一块，其他列放一块，减小IO</li></ol><h3 id="确定数据库的存储结构"><a href="#确定数据库的存储结构" class="headerlink" title="确定数据库的存储结构"></a>确定数据库的存储结构</h3><p><strong>包含：</strong>确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等</p><p><strong>考虑因素：</strong>存取时间、存储空间利用率、维护代价，当然这三点常常是相互矛盾的，需要做好tradeoff</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章大致介绍了数据库设计的整个流程：需求分析-概念结构设计-逻辑结构设计-物理结构设计。</p><p>需求分析是一个很实际的阶段，很难用理论描述详细，只是大致介绍了一些方法以及数据字典的概念。</p><p>概念结构设计是本章的一个重点，介绍了E-R图的画法。在概念结构设计的时候，需要表示出主键和关键属性。</p><p>逻辑结构设计也是一个重点，介绍了E-R图向关系模式转变的方法：</p><p>重点是联系的表示，根据联系种类的不同，有如下的方法：</p><ul><li>一对一<ul><li>两端强制：可以合并，可以放在任意一边外键</li><li>一端强制、一端选择：一般将强制端放在选择端作外键避免NULL</li><li>两端选择：为了避免NULL采用中间关系</li></ul></li><li>多对一：放在多端作为外键</li><li>多对多：只能作为单独关系</li></ul><p>然后，需要根据范式分解理论，适当对范式进行分解消除冗余。</p><p>最后，需要在模式的基础上为用户设计外模式。</p><p>物理结构设计也不太好详细讲述，这里主要对比了三种存取方式的对比：B+树索引、Hash索引、聚簇。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第六章 关系数据理论</title>
      <link href="/2022/12/15/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
      <url>/2022/12/15/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>本章很像离散数学^ ^</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>数据依赖往往会导致冗余、更新异常等，数据依赖分为：函数依赖FD和多值依赖MVD</p><p>之前说过关系模式的详细定义：<code>R(U,D,DOM,F)</code>，在本章，我们主要研究的是属性之间的数据依赖，所以简化为<code>R(U,F)</code>的形式</p><p><strong>第一范式：</strong>元组的分量是不可分的数据项</p><h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p><strong>定义：</strong>假设R(U)是属性集U上的关系模式，X和Y是U的子集，若对于R(U)的任意可能关系r，r中不可能存在两个元组在X上的值相等而Y值不相等，则称“X函数确定Y”或“Y函数依赖于X”，记作$X \rightarrow Y$。</p><p>更加数学化的表达：任意$t_1 , t_2 \in r$，如果：$t_1[X]=t_2[X] \Rightarrow t_1[Y]=t_2[Y]$，则$X \rightarrow Y$。</p><p><strong>平凡函数依赖：</strong>上面的定义有一种特殊情况，若$Y \subseteq X$，那么一定有$X \rightarrow Y$，这样的函数依赖是平凡的。</p><p><strong>完全函数依赖：</strong>$X \rightarrow Y$，如果对于X的任意真子集都有$X’ \nrightarrow Y$，则称为完全函数依赖，记作$X \stackrel{F}{\rightarrow} Y$，否则叫非完全函数依赖，记为$X \stackrel{P}{\rightarrow} Y$。</p><p><strong>传递函数依赖：</strong>如果有$X\rightarrow Y, Y \rightarrow Z$，且满足$Y \nsubseteq X,Y \nrightarrow X, Z \nsubseteq Y$，则称为Z传递函数依赖于X，记作$X \stackrel{传递}{\rightarrow} Y$。</p><p>传递函数依赖后面的三个限制条件是去掉<strong>平凡情况</strong>的：Y不能是X的子集，更不能和X相互依赖，Z也不能是Y的子集。</p><p>FD是由数据的语义确定的，取决于<strong>对于业务规则的理解</strong>。</p><h3 id="键-码"><a href="#键-码" class="headerlink" title="键/码"></a>键/码</h3><p>该部分在第二章：关系型数据库已经详细介绍了，请参阅<a href="https://blog-boulevard.top/2022/12/08/第二章 关系型数据库/#关系的一些关键概念">数据库原理第二章 关系型数据库 | Boulevard’s Blog (blog-boulevard.top)</a></p><h3 id="函数依赖的公理系统"><a href="#函数依赖的公理系统" class="headerlink" title="函数依赖的公理系统"></a>函数依赖的公理系统</h3><h4 id="逻辑蕴含"><a href="#逻辑蕴含" class="headerlink" title="逻辑蕴含"></a>逻辑蕴含</h4><p>前面说过，R(U,F)中，F是所有数据依赖的集合，如果存在函数依赖$X \rightarrow Y$的话，则称为F<strong>逻辑蕴含</strong>$X\rightarrow Y$。</p><h4 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h4><p>对于R(U,F)有如下<strong>推理规则</strong>：</p><ol><li>自反律：若$Y \subseteq X$，则F蕴含$X \rightarrow Y$。这一点是显而易见的。</li><li>增广律：若F蕴含$X \rightarrow Y$，则F蕴含$XZ \rightarrow YZ$。</li><li>传递律：F蕴含$X\rightarrow Y, Y \rightarrow Z$，则F蕴含$X \rightarrow Z$。</li></ol><p>注：说了好像和没说差不多，1是平凡的函数依赖、3是传递依赖，2也非常显然…</p><p>根据上面的三条推理规则，还能得到<strong>另外三条推理规则</strong>：</p><ol><li>合并规则：若$X\rightarrow Y, X \rightarrow Z$，则$X\rightarrow YZ$。</li><li>伪传递规则：若$X \rightarrow Y,WY \rightarrow Z$，则$XW \rightarrow Z$。</li><li>分解规则：若$X\rightarrow Y,Z \subseteq Y$，则$X\rightarrow Z$。</li></ol><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式（Normal Form，NF），顾名思义，是符合某一种级别的关系模式的集合。范式关系如下：</p><p><img src="/images/DBSNote/image-20221215121446192.png" alt="image-20221215121446192"></p><p>低级范式，<strong>可以通过转化为多个高级范式</strong>，这个过程叫做<strong>规范化</strong>。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p><strong>定义：</strong>$R \in1NF$，R中的每一个非主属性都<strong>完全函数依赖</strong>于<strong>任何一个候选码</strong>，则$R \in 2NF$。</p><p><strong>2NF导致异常的例子：</strong></p><blockquote><p>假设有关系<code>S-L-C(Sno,Sdept,Sloc,Cno,Grade)</code>其中Sloc为学生的住处，一个系的学生住在一个地方。那么函数依赖如下：</p><p><img src="/images/DBSNote/image-20221215122101484.png" alt="image-20221215122101484"></p><p>候选码是：(Sno,Cno)</p><p>首先是冗余：每写入一个选课记录，就要重新写入一遍Sdept和Sloc。</p><p>然后是三个异常：</p><ul><li>插入异常：如果一个学生没有选课记录，怎么去记录他的Sdept和Sloc？</li><li>删除异常：如果把学生的选课记录全删了，那么Sdept和Sloc也没有记录了。</li><li>修改复杂：如果学生搬地方了，那么每一条选课记录的Sloc都需要修改。</li></ul><p><strong>解决方法：模式分解让其满足2NF</strong></p><p>明明Sdept和Sloc都是Sno可以直接决定的，与Cno无关，所以就没必要放在这个关系：</p><ul><li>SC(Sno,Cno,Grade)</li><li>S-L(Sno,Sdept,Sloc)</li></ul></blockquote><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p><strong>定义：</strong>$R\in 1NF$，如果R中不存在<strong>码X</strong>、<strong>属性组Y</strong>、<strong>非主属性Z</strong>，使得$X\rightarrow Y,Y\rightarrow Z$成立，$Y \nrightarrow X$，则$R \in3NF$</p><p><strong>3NF主要解决了非主属性对候选键的传递依赖。</strong></p><p>注意这里对于属性组Y，没有特别严格的要求，其可以是部分主属性，也可以是非主属性，也可以是两者的结合。</p><p>也就是说，当Y是部分主属性$Y\in X$的时候，就变成了非主属性对于候选键的部分依赖，所以<strong>满足3NF一定满足2NF</strong>。</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p><strong>定义：</strong>假设关系模式$R(U,F)\in 1NF$，若$X\in Y$且$Y \nsubseteq X$时<strong>X必含有码</strong>，则$R\in BCNF$</p><p>也就是说，BCNF中的决定属性集必为超码。</p><p><strong>为什么要有BCNF？</strong></p><p><strong>BCNF消除了主属性对码的部分和传递依赖</strong></p><p>3NF解决了非主属性对于候选键的传递依赖，但是任然可能存在一些主属性之间的依赖关系</p><p>BCNF在第三范式的基础上更进一步，所以又叫修正/扩充的第三范式，解决了第三范式中还有可能存在的一些问题：</p><ul><li>候选键的子集 对 候选键 传递依赖</li><li>候选键的子集+非主属性 对 候选键 传递依赖</li></ul><blockquote><p>e.g.<code>邮编(城市,街道,邮编号)</code></p><p>主码是：<code>(城市,街道)-&gt;邮编号</code></p><p>但是又有<code>邮编号-&gt;城市</code></p><p>所以这个关系满足3NF但是不满足BCNF。</p></blockquote><p>达到BCNF以后，就只有属性对于候选键的依赖关系而没有其他的依赖关系了。在函数依赖的范畴内，BCNF已经实现了模式的彻底分解，消除了插入异常和删除异常。</p><p><strong>BCNF的分解</strong></p><p>通过上面的例子我们可以看到，满足3NF而不满足BCNF的经典例子是这样的：</p><p>R(A,B,C)：AB-&gt;C, C-&gt;B</p><p>那么AC-&gt;ABC：AB、AC都是候选键，所以A、B、C都是主属性，没有非主属性，R一定是3NF，但是不满足BCNF。如下图所示：</p><p><img src="/images/DBSNote/image-20221215162339236.png" alt="image-20221215162339236"></p><p>分解成BCNF的关键，就是只要看到了A-&gt;B出现，那么A必须要作为<strong>主码</strong>。</p><p>所以这里分解成：R1(A, B)、R2(C, B)</p><p><strong>主属性的判断：</strong>如果A能够决定候选键的部分属性，那么A一定是主属性。</p><p><strong>BCNF导致异常的例子</strong></p><blockquote><p>仓储(仓库，物品，管理员，数量)</p><ul><li>(仓库，物品)-&gt;(管理员，数量)</li><li>(管理员，物品)-&gt;(仓库，数量)</li><li>(仓库-&gt;管理员)，(管理员-&gt;仓库)</li></ul><p>那么这里只有数量是非主属性，且不存在对于候选键的传递依赖，满足3NF</p><p>但是由于第三条，所以不满足BCNF</p><p>这时候，如果要创建一个没有存放物品的仓库，只有仓库和管理员，但是由于物品也是一个主属性，所以会导致插入异常。</p><p>同样的，如果所有物品都出库了，需要删除所有物品，那么最后仓库本身与其管理员也没有了记录。</p></blockquote><p>注：这里一开始我犯了个错，认为存在传递依赖:(仓库，物品) -&gt; (仓库，管理员)-&gt;数量</p><p>但是要注意(仓库，管理员) -&gt; (仓库，物品)，所以这个不能算作是传递依赖。</p><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><p><strong>定义：</strong>$R(U)$，$X,Y,Z\subseteq U$且$Z = U - X - Y$。多值依赖$X \rightarrow \rightarrow Y$成立 i.f.f 对于R中的任意关系r，给定(x,z)值，有一组Y值，这组值仅仅与x有关而与z无关。</p><p>也就是说Y和Z是相互独立的。</p><p><strong>等价定义：</strong>$R(U)$，$X,Y,Z\subseteq U$且$Z = U - X - Y$，任取元组$t_1,t_2$，$t_1[X] = t_2[X]$，则存在元组$t_3$使得：$t_3[X] = t_1[X] = t_2[X],t_3[Y] = t_1 [Y],t_3[Z] = t_2[Z]$。</p><p>或者说，允许Y,Z这对值排列组合。</p><p><strong>平凡多值依赖：</strong>$Z = \emptyset$</p><p>多值依赖的图示如下：</p><p><img src="/images/DBSNote/image-20221215172038565.png" alt="image-20221215172038565"></p><p><strong>多值依赖的性质：</strong></p><ul><li>对称性：$X\rightarrow \rightarrow Y$，则$X\rightarrow \rightarrow Z，Z=U-X-Y$</li><li>传递性：若$X\rightarrow \rightarrow Y$，$Y\rightarrow \rightarrow Z$，则$X\rightarrow \rightarrow Z-Y$</li><li>函数依赖是多值依赖的特殊情况</li><li>推理规则<ul><li>若$X\rightarrow \rightarrow Y$，$X\rightarrow \rightarrow Z$，则$X\rightarrow \rightarrow YZ$</li><li>若$X\rightarrow \rightarrow Y$，$X\rightarrow \rightarrow Z$，则$X\rightarrow \rightarrow Y\cap Z$</li><li>若$X\rightarrow \rightarrow Y$，$X\rightarrow \rightarrow Z$，则$X\rightarrow \rightarrow Y-Z,X\rightarrow \rightarrow Z-Y$</li></ul></li><li>多值依赖的有效性和属性集范围有关，缩小范围成立、扩大范围不一定成立。（容易理解，多值依赖涉及补集Z，补集中添加的属性和Y可能不独立）</li></ul><h3 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h3><p><strong>定义：</strong>对于每一个非平凡的多值依赖$X\rightarrow \rightarrow Y$，X一定含有码，则$R\in 4NF$。</p><p><strong>实质：</strong>4NF中的多值依赖，要么是函数依赖、要么是平凡多值依赖</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一章主要介绍了<strong>两个依赖，五个范式</strong></p><p>五个范式的推进关系如下：</p><ul><li>1NF是最基本的范式，要求的属性的<strong>原子性</strong></li><li>2NF消除了<strong>非主属性</strong>对候选键的<strong>部分函数依赖</strong></li><li>3NF消除了<strong>非主属性</strong>对候选键的<strong>传递函数依赖</strong></li><li>BCNF消除了<strong>主属性</strong>对候选键的<strong>部分和传递函数依赖</strong></li><li>4NF消除了<strong>非平凡且非函数的多值依赖</strong></li></ul><p>当然，规范化并不是说越高的范式越好，不是每个关系都要分解成BCNF甚至4NF才可以的，要视具体情况而言。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第五章 数据库完整性</title>
      <link href="/2022/12/13/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
      <url>/2022/12/13/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>数据库完整性和上一章的数据库安全性听起来有部分重合，但是实际上是不同的两个概念：</p><ul><li>数据库安全性是防范的非法操作和恶意破坏</li><li>数据库完整性是防范的不合语义、不正确的数据</li></ul><p>为了维护数据库的完整性，数据库需要提供：</p><ul><li>定义完整性的规则</li><li>完整性检查的方法</li><li>违约处理</li></ul><p>RDB的三大完整性在之前已经提到过很多次了：实体、参照、用户定义的完整性。本章先详细介绍这三种完整性，然后介绍SQL中定义完整性的工具：完整性约束命名子句、断言、触发器。</p><h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用<code>PRIMARY KEY</code>定义主键，可以将其定义为列级完整性约束条件，也可以定义为表级约束条件。</p><h3 id="检查和违约处理"><a href="#检查和违约处理" class="headerlink" title="检查和违约处理"></a>检查和违约处理</h3><p>主码唯一、非空，否则<strong>拒绝</strong></p><p>因为主码要求是唯一的，所以每次插入或者修改主码的时候都需要检查，一般来说DBMS会自动地在主码上面建立一个索引</p><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>参照完整性使用<code>FOREIGN KEY ... REFERENCES ...</code>短语定义</p><h3 id="检查与违约处理"><a href="#检查与违约处理" class="headerlink" title="检查与违约处理"></a>检查与违约处理</h3><p>这里需要分类讨论：可能是增加或者修改了一个元组，这个元组引用了不存在的实体；也可能是删除或者修改了一个被引用的元组，导致引用的元组失去了参照。</p><p>如果是第一种情况：添加或者修改一个元组，这个元组引用了不存在的实体，那么只能<strong>拒绝</strong>。</p><p>如果是第二种情况：可以拒绝、可以级联修改/删除、也可以把引用设置为空。可以定义：<code>ON DELETE/UPDATE CASCADE/NO ACTION/SET NULL</code></p><h2 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h2><h3 id="属性上的约束"><a href="#属性上的约束" class="headerlink" title="属性上的约束"></a>属性上的约束</h3><p>包含：</p><ol><li>列非空</li><li>列唯一</li><li>列是否满足表达式</li></ol><p><strong>违约处理一般是拒绝</strong></p><h3 id="元组的约束"><a href="#元组的约束" class="headerlink" title="元组的约束"></a>元组的约束</h3><p>在CREATE TABLE的时候用CHECK定义，可以跨多个属性</p><p><strong>违约处理一般也是拒绝</strong></p><h2 id="完整性约束子句"><a href="#完整性约束子句" class="headerlink" title="完整性约束子句"></a>完整性约束子句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="operator">&lt;</span>约束条件<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>约束条件包含NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK短语等</p><p>修改的时候，可以使用如下语法删除再添加</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表明<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言是一种更有<strong>一般性</strong>的约束，例如涉及多个表或者聚集操作。</p><p>断言创建以后，涉及断言的操作执行之前都会检查，如果不通过断言则<strong>拒绝执行</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="operator">&lt;</span>CHECK...<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>删除断言：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是用户定义在<strong>表</strong>上的，由<strong>事件驱动</strong>的过程。触发器提供了一个<strong>动态完整性</strong>，也就是说<strong>可以前后对比</strong>。</p><h3 id="定义触发器"><a href="#定义触发器" class="headerlink" title="定义触发器"></a>定义触发器</h3><p>只有表的拥有者才可以定义，<strong>且不能定义在视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span></span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; <span class="operator">&lt;</span>触发事件<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span><span class="operator">|</span><span class="keyword">OLD</span> <span class="type">ROW</span><span class="operator">|</span><span class="keyword">TABLE</span> <span class="keyword">AS</span> <span class="operator">&lt;</span>变量<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> &#123;<span class="type">ROW</span><span class="operator">|</span>STATEMENT&#125;</span><br><span class="line">[<span class="keyword">WHEN</span> <span class="operator">&lt;</span>触发条件<span class="operator">&gt;</span>] <span class="operator">&lt;</span>触发动作体<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>触发事件可以是<strong>INSERT/DELETE/UPDATE</strong>，也可以指明<strong>UPDATE OF 具体列</strong></p><p>BEFORE/AFTER表明是先执行触发器动作还是事件动作</p><p>比较难理解的是FOR EACH {ROW|STATEMENT}：当运行一个SQL语句的时候，可能会触及表中的多行，这个时候，如果是<strong>行级触发器</strong>，<strong>涉及了多少行就触发多少次</strong>；而语句级触发器无论涉及了多少行都<strong>只触发一次</strong>。</p><p> 对于<code>REFERENCING</code>子句，ROW还是比较好理解的，如果是TABLE的话，这个表指的是<strong>所有有被修改涉及到的元组</strong></p><p><strong>行级触发器</strong>的例子：</p><p>学生SC，修改分数（Grade）增加了超过10%的时候，需要将修改记录到，SC_U(Sno, Cno, Oldgrade, Newgrade)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> SC_T</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> Grade <span class="keyword">ON</span> SC</span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line"><span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> OldTuple</span><br><span class="line"><span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> NewTuple</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span>(NewTuple.Grade <span class="operator">&gt;=</span> <span class="number">1.1</span> <span class="operator">*</span> OldTuple.Grade)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC_U <span class="keyword">VALUES</span>(OldTuple.Sno, OldTuple.Cno, OldTuple.Grade, NewTuple.Grade);</span><br></pre></td></tr></table></figure><p><strong>语句级触发器的例子</strong></p><p>StudentInsertLog（Numbers）是记录学生数量的表，每次插入学生Student，都需要为Student+1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Student_Count</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> Student</span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> DELTA</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentInsertLog</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> DELTA;</span><br></pre></td></tr></table></figure><h3 id="激活触发器"><a href="#激活触发器" class="headerlink" title="激活触发器"></a>激活触发器</h3><p>触发器是由<strong>触发事件</strong>激活的，服务器会自动执行。</p><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一章主要介绍了三个完整性和实现完整性的三种SQL语法。</p><p>实体完整性是非常简单的，定义主键即可，如果违约了也只能拒绝。</p><p>参照完整性的定义也非常简单，使用外键即可。稍微复杂一些的是违约处理，如果是引用元组引用了一个不存在的目标元组，那么只能拒绝；如果是被引用的元组由修改或者删除，可以自己定义是拒绝、级联删除/修改、设为空。</p><p>用户定义的完整性可以使用CHECK来实现，违约一般也是拒绝。</p><p>除此之外，还有一些更加高级的完整性约束方法。</p><p>首先可以使用CONSTRAINT语句来命名完整性约束，方便管理约束。</p><p>其次由断言，断言的范围更广泛，可以涉及多个表。</p><p>最后是触发器，这部分语法比较复杂。分为改变多少个元组就执行多少次的行级触发器、以及一个语句只执行一次的语句级触发器。同时可以设置触发器是在动作之前还是之后完成。触发器是动态的，可以对比动作前后的元组。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第四章 数据库安全性</title>
      <link href="/2022/12/13/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
      <url>/2022/12/13/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>数据库是可以共享的，必然会导致一些安全性问题。</p><p>数据库的<strong>安全性</strong>是指保护数据库防止不合法使用所造成<strong>数据泄露、更改或者破坏</strong></p><p>数据库安全<strong>目标</strong>：CIA（保密性、完整性、可用性）</p><h2 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h2><h3 id="数据库的不安全因素"><a href="#数据库的不安全因素" class="headerlink" title="数据库的不安全因素"></a>数据库的不安全因素</h3><ul><li><strong>非授权用户</strong>的恶意存取和破坏</li><li>重要、敏感<strong>信息泄露</strong></li><li>安全环境的脆弱性：OS、硬件、网络等</li></ul><p>数据库安全系统图如下所示：</p><p><img src="/images/DBSNote/image-20221212161149249.png" alt="image-20221212161149249"></p><h3 id="安全标准"><a href="#安全标准" class="headerlink" title="安全标准"></a>安全标准</h3><h4 id="TCSEC（橘皮书）"><a href="#TCSEC（橘皮书）" class="headerlink" title="TCSEC（橘皮书）"></a>TCSEC（橘皮书）</h4><p>分为D-C1-C2-B1-B2-B3-A1等级：</p><p><img src="/images/DBSNote/image-20221212162029136.png" alt="image-20221212162029136"></p><h4 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h4><p>统一TCSEC和其他准则的国际通用准则</p><p><img src="/images/DBSNote/image-20221212162134180.png" alt="image-20221212162134180"></p><h4 id="等保"><a href="#等保" class="headerlink" title="等保"></a>等保</h4><p>我国制定</p><p><img src="/images/DBSNote/image-20221212162214910.png" alt="image-20221212162214910"></p><h2 id="数据库安全性控制"><a href="#数据库安全性控制" class="headerlink" title="数据库安全性控制"></a>数据库安全性控制</h2><p><strong>非法使用数据库的情况</strong>有如下：</p><ol><li>使用合法程序绕过DBMS的授权机制</li><li>直接执行非授权操作</li><li>通过多次合法查询推导出保密数据</li></ol><p>前面两点都是容易想到的，最后这点要注意</p><p>计算机系统安全模型如下：</p><p><img src="/images/DBSNote/image-20221212163626073.png" alt="image-20221212163626073"></p><p>在这个系统中，安全措施是一级一级的，缺乏联动机制，不方便溯源与整体安全</p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>对于DBMS，其安全性控制模型如下：</p><p><img src="/images/DBSNote/image-20221212163718542.png" alt="image-20221212163718542"></p><p>对上图的解释：</p><ul><li>首先用户访问的时候会进行身份的鉴别，防止不可信用户进入</li><li>然后会进行自主/强制存取控制，甚至推理控制（统计安全，一般的DBMS不支持）</li><li>对于这两步收集的数据，可以进行审计，进行简单的入侵检测</li></ul><h3 id="数据库安全性控制的常用方法"><a href="#数据库安全性控制的常用方法" class="headerlink" title="数据库安全性控制的常用方法"></a>数据库安全性控制的常用方法</h3><ul><li>用户标识和鉴别</li><li>存取控制</li><li>视图</li><li>审计</li><li>数据加密</li><li>数据备份与恢复</li></ul><p>下面，具体介绍这些方法中的某些：</p><h3 id="鉴别（Identification＆Authentication）"><a href="#鉴别（Identification＆Authentication）" class="headerlink" title="鉴别（Identification＆Authentication）"></a>鉴别（Identification＆Authentication）</h3><p>鉴别是<strong>最外层</strong>的安全保护措施</p><p>对于使用数据库的用户，系统会提供一个用户标识号UID，在整个系统生命周期内UID都是唯一的</p><h4 id="一般的鉴别方法"><a href="#一般的鉴别方法" class="headerlink" title="一般的鉴别方法"></a>一般的鉴别方法</h4><ul><li>静态口令：也就是Password</li><li>动态口令：一次一密</li><li>生物特征：指纹等</li><li>智能卡：硬件加密、不可复制</li></ul><p>当然，实际上，为了安全性，也可以一次使用好几种</p><h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><p>所谓存取控制，就是通过定义权限的方法来限制用户对于不同数据的读写权限。</p><p>用户的权限定义会被存放在<strong>数据字典</strong>中。</p><p>定义了用户权限以后，用户在发起存储请求的时候，系统就可以进行权限检查，<strong>权限定义和合法权检查机制一起组成了存取控制子系统</strong></p><p>存取控制主要有两种方法：自主存取控制DAC、强制存取控制MAC。其中自主存取控制通过的是给用户授予权限的方式，强制存取控制通过的是给对象和用户各自设定等级。</p><h4 id="DAC自主存取控制"><a href="#DAC自主存取控制" class="headerlink" title="DAC自主存取控制"></a>DAC自主存取控制</h4><p>DAC中，可以通过GRANT语句授权、也可以使用REVOKE语句回收授权。授予的权限可以是对于数据的（表、表的某一列等）、也可以是模式级别的授权（授予DBA权限等），具体如下：</p><p><img src="/images/DBSNote/image-20221212182915589.png" alt="image-20221212182915589"></p><p>具体检查DAC授权的过程叫<strong>访问控制</strong></p><p><strong>GRANT对于数据对象授权：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br></pre></td></tr></table></figure><p>WITH GRANT OPTION表示同时授予用户传播权限的权力，值得注意的是，不可以循环授权</p><p>GRANT可以由BDA、该对象拥有者、以及被WITH GRANT OPTION授权的用户使用，</p><p><strong>REVOKE可以收回权限：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...[CASCADE<span class="operator">|</span>RESTRICT];</span><br></pre></td></tr></table></figure><p><strong>创建数据库模式的权限：</strong></p><p>DBA创建用户的时候，可以给用户赋予模式权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>username<span class="operator">&gt;</span> [<span class="keyword">WITH</span>][DBA<span class="operator">|</span>RESOURCE<span class="operator">|</span><span class="keyword">CONNECT</span>];</span><br></pre></td></tr></table></figure><p>为了方便对于用户的授权，DAC中还有<strong>角色</strong>的概念：角色是权限的集合，可以通过给用户授予角色来简化授权。”Users change frequently, Roles don’t.“</p><p><strong>角色的创建：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="operator">&lt;</span>rolename<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p><strong>将角色赋予用户：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>角色<span class="number">1</span><span class="operator">&gt;</span>,[<span class="operator">&lt;</span>角色<span class="number">2</span><span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>角色<span class="operator">/</span>用户<span class="operator">&gt;</span>...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br></pre></td></tr></table></figure><p>同样的，角色也是允许传播的</p><p><strong>RBAC：</strong>基于角色的访问控制，Role-Based Access Control</p><p><strong>RBAC的三个安全原则：</strong></p><ul><li>最小权限原则：只分配完成任务需要的<strong>最小权限集</strong></li><li>责任分离：调用相互<strong>独立互斥的角色</strong>来完成敏感任务</li><li>数据抽象 ：通过权限的抽象来体现</li></ul><p>除此之外，还有<strong>静态职责分离SSD</strong>：不能够把冲突的角色授予给一个用户；对应的，还有<strong>动态职责分离DSD</strong>：可以同时授予冲突角色，但是不能够在一次会话中同时激活。</p><h4 id="MAC强制存取控制"><a href="#MAC强制存取控制" class="headerlink" title="MAC强制存取控制"></a>MAC强制存取控制</h4><p>MAC是一种更加严格的存取控制方法，MAC中实体被分为两类：</p><ul><li><strong>主体：</strong>系统中的活动实体，如用户、<strong>用户的进程</strong></li><li><strong>客体：</strong>系统中的被动实体，如文件、基本表、索引、视图等</li></ul><p><strong>策略：</strong></p><p>对于主体和客体，都有一个敏感度标记（Label）：绝密TS、机密S、秘密C、公开P</p><p>主体的敏感度叫做<strong>许可证级别</strong>，客体的敏感度叫做<strong>密级</strong></p><p>对于不同的侧重，有不同的MAC规则：</p><ul><li>保密性规则（BLP模型）：（向）下读、上写。也就是用户只能读比自己等级低的、只能写比自己等级高的。数据从下往上流动。</li><li>完整性规则（Biba模型）：（向）上读、下写。也就是用户只能修改比自己等级低的，读比自己等级高的。数据从上往下流动。</li></ul><p>一般MAC采用下读、上写的保密性规则。</p><p><strong>MAC的优点：</strong></p><ul><li>标记与数据不可分割</li><li>比DAC安全性更高</li></ul><h2 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h2><p>本部分不再赘述</p><h2 id="审计（Audit）"><a href="#审计（Audit）" class="headerlink" title="审计（Audit）"></a>审计（Audit）</h2><p>C2以上安全级别的DBMS必须要有审计功能</p><h3 id="审计的事件"><a href="#审计的事件" class="headerlink" title="审计的事件"></a>审计的事件</h3><ul><li>服务器事件</li><li>系统权限：对系统结构或者模式对象操作</li><li>语句事件：对于SQL的审计</li><li>模式对象：在特定模式对象的SELECT或者DML</li></ul><h3 id="审计功能"><a href="#审计功能" class="headerlink" title="审计功能"></a>审计功能</h3><ul><li>查阅审计</li><li>在初始化时设定多套审计规则</li><li>审计分析和报表</li><li>审计日志管理</li><li>提供专门视图</li></ul><h3 id="SQL开关审计"><a href="#SQL开关审计" class="headerlink" title="SQL开关审计"></a>SQL开关审计</h3><ul><li>AUDIT：开启</li><li>NOAUDIT：取消</li></ul><p>除了DBA可以对数据库开启<strong>系统级审计</strong>以外，用户还可以对自己创建的表和视图进行<strong>用户级审计</strong>。</p><h3 id="涉密信息系统的”三员“"><a href="#涉密信息系统的”三员“" class="headerlink" title="涉密信息系统的”三员“"></a>涉密信息系统的”三员“</h3><p><img src="/images/DBSNote/image-20221213104343902.png" alt="image-20221213104343902"></p><h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p>数据主要需要在存储、传输的两个过程加密</p><h3 id="存储加密"><a href="#存储加密" class="headerlink" title="存储加密"></a>存储加密</h3><p>数据库的存储加密分为：透明存储加密、非透明存储加密</p><h4 id="透明存储加密"><a href="#透明存储加密" class="headerlink" title="透明存储加密"></a>透明存储加密</h4><p>又叫内核级加密，对用户是完全透明的</p><p>数据在内存缓冲区是未加密的，当数据从内存写入到文件中的时候会进行加密</p><p><strong>优点：</strong>性能好，安全完备性较高，无需在应用层修改</p><p><strong>缺点：</strong>只能静态保护，防护的颗粒度较粗</p><p>e.g. Oracle TDE可以支持表空间加密和列加密，其中表空间加密是对整个表加密、列加密是在SQL层对数据加密</p><h4 id="非透明存储加密"><a href="#非透明存储加密" class="headerlink" title="非透明存储加密"></a>非透明存储加密</h4><p>通过多个加密函数实现</p><h3 id="传输加密"><a href="#传输加密" class="headerlink" title="传输加密"></a>传输加密</h3><h4 id="端到端加密与链路加密"><a href="#端到端加密与链路加密" class="headerlink" title="端到端加密与链路加密"></a>端到端加密与链路加密</h4><p>根据TCP/IP五层模型，可以在链路层和网络层（端到端）加密数据。</p><p>我们知道链路层报文由报头和报文组成，报文内容则是IP数据报。</p><p>所以链路加密和端到端加密的区别就是：<strong>链路加密把链路层的报文和报头都加密了，而端到端加密只加密了IP数据报。</strong></p><h4 id="SSL安全套接层协议"><a href="#SSL安全套接层协议" class="headerlink" title="SSL安全套接层协议"></a>SSL安全套接层协议</h4><p>SSL的大体思路如下：</p><ul><li>使用数字证书确认端点可靠性</li><li>协商加密算法和密钥</li><li>用密文形式传输数据</li></ul><h2 id="其他安全性保护"><a href="#其他安全性保护" class="headerlink" title="其他安全性保护"></a>其他安全性保护</h2><ul><li>推理控制：在统计上安全</li><li>隐蔽信道</li><li>数据库脱敏：对敏感数据变换处理，比如说手机号变成123****4567</li><li>数据库防火墙：过滤掉非法的SQL</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章的开始首先介绍了几个重要的标准：TCSEC、CC、等保…</p><p>然后介绍了数据库安全性控制的机制：首先进行用户身份鉴别，然后是存取控制。</p><p>鉴别较为简单，有password、一次一密、生物认证、硬件认证等方法。</p><p>存取控制是本章的重点内容：分为自主存取控制和强制存取控制。用户的存取权限会被记录在数据库的数据字典中，DBMS会在操作之前检查用户的权限，构成了存取控制子系统。</p><p>其中自主存取控制是给用户授予操作某些对象（可以是系统级别的模式等、也可以是具体的数据），使用GRANT和REVOKE语句，同时还可以授权用户传播自己的权限。</p><p>一个一个授予用户所需的权限是很不方便的重复过程，所以在DAC的基础上，引入了角色（Role）这个概念，角色是多个权限的集合，可以先授予权限给角色，然后授予角色给多个用户。这一套基于权限的访问控制方法称作RBAC（Role-Based Access Control）。RBAC的三大基本原则是：最小权限、责任分离、数据抽象。对于给一个用户同时授予冲突角色这种危险行为，有静态职责分离SSD或者动态职责分离DSD控制。</p><p>MAC自主存取控制是一种更加高安全性的存取控制，用户和数据都会被打上敏感度标签，用户在读或者写数据的时候需要对比其与数据的敏感度标签。对于具体的MAC策略，有侧重保密性的BLP模型：（往）下读上写、以及侧重完整性的Biba模型：（往）上读下写。一般而言，数据库使用较为侧重保密性的下读上写方案。</p><p>视图也是保护数据库安全性的一大要素，视图在之前的章节已经详细介绍过了，这一章就不再介绍了。</p><p>审计也是保障数据库安全性的一大保障，数据库可以对服务器事件审计，也可以对系统权限、模式对象、SQL等进行审计。DBA可以开启系统级的审计，用户也可以对于其创建的数据对象进行用户级审计。</p><p>有了安全审计员，数据库就做到了三权分立：系统管理员、安全保密管理员、安全审计员。</p><p>最后是对于数据的加密，数据可以在存储的时候加密、也可以在传输的时候加密。</p><p>对于存储加密，有内核级的透明存储加密：将内存中的数据写入到硬盘中的文件时加密，这样的加密对用户是透明的，速度也比较快。非透明存储加密没有作为重点介绍，只是说明了其需要使用多个加密函数。</p><p>对于传输加密，其分为链路加密和端到端加密。链路加密就是把链路层的报文和报头都加密，端到端加密则是只加密IP数据报。</p><p>目前常用的传输加密方案是SSL协议，思路是：首先使用数字证书认证双方身份，然后协商加密的函数和密钥，最后开始传输加密的数据。</p><p>除此之外，还有一些其他的数据库安全保护方法：统计安全的推理控制，隐蔽信道，脱敏，数据库防火墙等。恢复和备份也是保障数据库安全性的一种有效方式，将在后面的章节详细介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第三章 SQL</title>
      <link href="/2022/12/10/%E7%AC%AC%E4%B8%89%E7%AB%A0%20SQL/"/>
      <url>/2022/12/10/%E7%AC%AC%E4%B8%89%E7%AB%A0%20SQL/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h2><h3 id="SQL的产生和发展"><a href="#SQL的产生和发展" class="headerlink" title="SQL的产生和发展"></a>SQL的产生和发展</h3><p>SQL在IBM诞生，起初由Codd提出关系数据建模，而后Chamberlin和Boyce开发了SEQUEL语言，后续改名SQL</p><h3 id="SQL的特点"><a href="#SQL的特点" class="headerlink" title="SQL的特点"></a>SQL的特点</h3><ul><li>综合统一：包含数据定义语言DDL、数据操纵语言DML、数据控制语言DCL、事务控制语言TCL（Transaction Control Language）。SQL可以独立完成数据库生命周期的全部活动。</li><li>高度非过程化：存取路径的选择由DBMS自动完成</li><li>面向集合操作：这一点<strong>与关系操作一样</strong>，SQL操作的对象和结果都是集合</li><li>提供多种使用方式：除了这两章介绍的SQL以外，SQL还可以使用ODBC、JDBC等API被高级语言使用</li><li>简介：语法核心功能只用了9个动词</li></ul><h3 id="SQL的基本概念"><a href="#SQL的基本概念" class="headerlink" title="SQL的基本概念"></a>SQL的基本概念</h3><p>SQL也是支持数据库的三级模式结构的，SQL从内到外为：存储文件、基本表、视图。三者间的关系以及与各级模式的对应关系如下：</p><p><img src="/images/DBSNote/image-20221209101513396.png" alt="image-20221209101513396"></p><p><strong>视图</strong>就是用户可以看到的基本表的部分，所以是外模式：要注意的是SQL的<strong>一个视图可以是由多个表导出</strong>的</p><p><strong>基本表</strong>自然而然就是全局的逻辑数据，构成模式；<strong>存储文件</strong>构成内模式，要注意<strong>基本表和存储文件</strong>之间的关系可以是<strong>一对一、多对一</strong>。</p><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>SQL可以定义模式、表、视图与索引，主要用到CREATE、DROP、ALTER三个关键字，具体如下：</p><p><img src="/images/DBSNote/image-20221209103131184.png" alt="image-20221209103131184"></p><p>注意：模式和视图是<strong>不能修改</strong>的</p><p>RDBMS的<strong>层次化对象命名</strong>机制如下图：</p><p><img src="/images/DBSNote/image-20221209103521068.png" alt="image-20221209103521068"></p><p>其中，<strong>一个数据库实例可以有多个模式、一个模式下通常有多个表</strong>。</p><h3 id="定义模式"><a href="#定义模式" class="headerlink" title="定义模式"></a>定义模式</h3><p>创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>模式名省略的时候，自动设置为用户名</p><p>定义模式相当于定义了一个<strong>命名空间</strong></p><p>删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="operator">&lt;</span>CASCADE<span class="operator">|</span>RESTRICT<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>CASCADE级联表示删除模式下的所有对象；RESTRICT限制表示如果模式非空则不可以删除。</p><p><strong>关于不同数据库中模式的地位：</strong>MySQL中Schema和数据库是等价概念，Oracle中的Schema是User名下所有数据库对象的总和，和用户名相同。简单来说：<strong>MySQL中Schema=Database，Oracle中Schema=user</strong>。</p><h3 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h3><p>创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">      (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[ <span class="operator">&lt;</span>列级完整性约束条件<span class="operator">&gt;</span> ]</span><br><span class="line">      [,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[ <span class="operator">&lt;</span>列级完整性约束条件<span class="operator">&gt;</span>] ] </span><br><span class="line">...</span><br><span class="line">      [,<span class="operator">&lt;</span>表级完整性约束条件<span class="operator">&gt;</span> ] );</span><br></pre></td></tr></table></figure><p>定义表所属的模式：</p><ul><li>在创建表时使用 &lt;模式名&gt;.&lt;表名&gt;</li><li>在创建模式时同时创建表</li><li>设置表所属的模式</li><li>倘若没有指定，系统会根据<strong>搜索路径</strong>来确定其模式</li></ul><p>修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [完整性约束]]</span><br><span class="line">[<span class="keyword">ADD</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span> RESTRICT]]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span> [RESTRICT<span class="operator">|</span>CASCADE]]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><p>也就也是说，对于一个基本表，可以加、减、修改列，设置和取消完整性约束。</p><p>删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [RESTRICT<span class="operator">|</span>CASCADE];</span><br></pre></td></tr></table></figure><p>同样的有级联和限制之分：设计到其他表的引用，如Foreign Key、View等</p><h3 id="定义索引"><a href="#定义索引" class="headerlink" title="定义索引"></a>定义索引</h3><p>常见的索引有：顺序、B+树、hash、bitmap</p><p><strong>DBA或者表的属主</strong>可以建立索引，索引由DBMS自动维护。<strong>索引不能被用户显式选择</strong>，系统会自动判断是否有存在的索引可以加速性能。</p><p>创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>], [<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>]])：</span><br></pre></td></tr></table></figure><p>其中UNIQUE表示一个索引值只对应一条记录，CLUSTER表示建立聚簇索引。次序为ASC升序、DESC降序。</p><p>重命名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> INDEX <span class="operator">&lt;</span>旧名<span class="operator">&gt;</span> RENAME <span class="keyword">TO</span> <span class="operator">&lt;</span>新名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><p>数据字典是一张DBMS内部的表，记录了数据库的所有定义信息：</p><ul><li>关系模式定义</li><li>视图定义</li><li>索引定义</li><li>完整性约束定义</li><li>用户权限</li><li>统计信息等</li></ul><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>] …</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> ]…<span class="operator">|</span>(<span class="keyword">SELECT</span> 语句)      </span><br><span class="line">[<span class="keyword">AS</span>] <span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>ALL|DISTINCT表是否保留重复</p><p>目标列可以有别名，也可以使用表达式作为目标列</p><p>除了运算符以外，表达式还可以使用IN、LIKE、BETWEEM…AND…等</p><p>ORDER BY若没有标明ASC/DESC则升序排列，对于NULL的排序，由具体系统决定</p><p>GROUP BY可以细化聚集函数的作用对象，如果要对聚集函数进行筛选，不<strong>能够将聚集函数放在WHERE中，需要放在GROUP BY后面的HAVING子句中！！！</strong></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>这一块的表达非常多样化，例如条件，最基本的是写在WHERE子句中、但其实也可以写在ON子句中，而且两者是有区别的：WHERE可以看作先做笛卡尔积后筛选、ON可以看作使用nested loop join一边join一边筛选，所以在外连接一些情况下面，两者的结果会有所不同。如果是自然连接的话，还可以使用<code>JOIN...USING</code>表达自然连接的列。</p><p>连接查询这部分在此前以及有过内容了，可以参阅：<a href="https://blog-boulevard.top/2022/10/02/sql连接/#自身连接">SQL连接 | Boulevard’s Blog (blog-boulevard.top)</a></p><h3 id="子查询、集合查询、派生表查询等"><a href="#子查询、集合查询、派生表查询等" class="headerlink" title="子查询、集合查询、派生表查询等"></a>子查询、集合查询、派生表查询等</h3><p>参见<a href="https://blog-boulevard.top/2022/10/07/sql查询剩余的部分/">SQL查询剩余的部分 | Boulevard’s Blog (blog-boulevard.top)</a>，子查询主要有IN、比较运算符、ANY(SOME)/ALL、EXISTS等方法，特别注意双NOT EXISTS表示关系除。</p><h3 id="SQL的特别用法"><a href="#SQL的特别用法" class="headerlink" title="SQL的特别用法"></a>SQL的特别用法</h3><ul><li><p>CASE语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">Condition</span> <span class="keyword">then</span> <span class="keyword">result</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li><li><p>返回结果的前N条记录：</p><ul><li>SQL Server： <code>SELECT TOP N|百分比</code></li><li>MySQL：<code>SELECT FROM WHERE... LIMIT N</code></li><li>Oracle：<code>SELECT FROM WHERE ROWNUM&lt;=N</code></li></ul></li></ul><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>可以插入单条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>属性列<span class="operator">&gt;</span>...]</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="operator">&lt;</span>值<span class="operator">&gt;</span>...);</span><br></pre></td></tr></table></figure><p>也可以插入子查询结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>属性列<span class="operator">&gt;</span>...]</span><br><span class="line">子查询;</span><br></pre></td></tr></table></figure><p>插入之前会检查三个完整性</p><h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><h4 id="复制结构"><a href="#复制结构" class="headerlink" title="复制结构"></a>复制结构</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">new</span> <span class="keyword">LIKE</span> orig;</span><br></pre></td></tr></table></figure><h4 id="复制结构和数据"><a href="#复制结构和数据" class="headerlink" title="复制结构和数据"></a>复制结构和数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">new</span> [<span class="keyword">AS</span>] <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orig;</span><br></pre></td></tr></table></figure><h4 id="先复制结构后复制数据"><a href="#先复制结构后复制数据" class="headerlink" title="先复制结构后复制数据"></a>先复制结构后复制数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">new</span> <span class="keyword">LIKE</span> orig;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">new</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orig;</span><br></pre></td></tr></table></figure><p>复制过程中，需要注意：</p><ul><li>主、外键、索引是否被复制（通常没有）</li><li>约束是否被复制</li></ul><p>在复制过程中，会禁止索引、外键、触发器等</p><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span> <span class="operator">&lt;</span>列<span class="operator">&gt;=</span><span class="operator">&lt;&gt;</span>,...</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><p>修改数据的时候，也需要临时禁止约束（外键、check、index、trigger等）</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><h2 id="空值的处理"><a href="#空值的处理" class="headerlink" title="空值的处理"></a>空值的处理</h2><p>空值就是“不确定”、“不存在”的意思，只能用IS [NOT] NULL判断，而不能用=NULL。</p><p>如果有NOT NULL、UNIQUE或者是作为码属性则不允许为空</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>从一个<strong>或者多个</strong>基本表<strong>或视图</strong>导出的虚表</p><p>在数据库中，视图只有定义，不存放数据</p><h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span></span><br><span class="line"><span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,...]</span><br><span class="line"><span class="keyword">AS</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure><p>所谓WITH CHECK OPTION就是说更改视图的时候，需要保证满足视图定义的谓词条件（也就是满足子查询的条件表达式）</p><p>比如说，基本表是所有学生Student，给1系创建一个视图Student_Dept1，那么在开启了WITH CHECK OPTION的情况下，这个系的老师若插入一条学生纪录、系号为2，则会报错。</p><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [CASCADE];</span><br></pre></td></tr></table></figure><p>之前说过，视图是可以从其他视图导出的，开启级联以后，如果该视图导出了其他视图，就会把导出的其他视图也删掉。</p><h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>对于用户来说查询视图和查询基本表没有什么区别</p><p>对DBMS来说，常用视图消解法实现对于视图的查询：转化为对于基本表的等价查询</p><p>试图消解法有时候不能产生正确的查询，具体可以看下面的例子：</p><p>定义S_G视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S_G(Sno,Gavg)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,<span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure><p>对其查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> S_G</span><br><span class="line"><span class="keyword">WHERE</span> Gavg<span class="operator">&gt;=</span><span class="number">80</span>l;</span><br></pre></td></tr></table></figure><p>视图消解以后，就变成了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,<span class="built_in">AVG</span>(Grade) <span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">AVG</span>(Grade)<span class="operator">&gt;=</span><span class="number">80</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure><p>而之前提过，聚集函数不能够出现在WHERE中，而要使用HAVING函数</p><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>同样的，也是使用视图消解法</p><p>但是，还是同样的，视图的更新也会有一些问题：</p><p>比如上面的S_G就不能更新，以外Gavg是聚合函数产生的列，是无法转化到基本表的</p><p>一般来说有如下情况的不能更新：</p><ul><li>使用了聚合函数</li><li>使用了UNIQUE、DISTINCT</li><li>使用的GROUP BY</li><li>使用了算术表达式</li><li>视图没有包括基本表的主键</li><li>…</li></ul><p>一般来说，只允许给一个表的行列子集构成的视图更新</p><h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><ul><li>简化操作</li><li>从多个角度看同一数据</li><li>重构数据库的逻辑独立性</li><li>保护机密数据</li><li>更清晰的表达查询</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一章的东西真的很多，除了SQL的一些历史、特点、概念以外，主要介绍了SQL对于数据的定义、查询、更新、以及视图</p><p>对于数据定义，要清楚模式和视图是不能够更改(ALTER)的。所有的数据定义被存在了数据字典中。</p><p>数据的查询这部分比较复杂：</p><p>对于普通的查询而言，要注意聚合函数与GROUP BY … HAVING …</p><p>对于连接查询，要注意用USING、WHERE、ON来连接的区别</p><p>对于子查询而言，有IN、ANY(SOME)/ALL、EXISTS等方法，要注意两个NOT EXISTS表示关系除的方法</p><p>同时，查询的时候还可以使用CASE语句、控制结果返回长度等。</p><p>对于数据的更新，这部分比较简单</p><p>对于视图，主要要注意视图消解法，以及对于视图查询和更新的限制</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第二章 关系型数据库</title>
      <link href="/2022/12/08/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/12/08/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>关系数据模型是E.F.Codd于1970年提出的一种<strong>概念模型</strong></p><p>按照上一章介绍的，概念模型有三个要素：数据结构、数据操作，以及数据的完整性约束条件</p><p>本章的前三部分就介绍了这三个部分，然后介绍了表示关系操作的一种数学方法：关系代数</p><h2 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>关系用来定义现实世界的实体、实体间的联系，也就是说<strong>RDB的数据结构是非常单一</strong>的，不仅实体是一种关系，联系也是一种关系。简单来说，关系是严格数学定义（集合论与关系代数）的表</p><p>关系的<strong>逻辑结构</strong>被称为关系模式，既然关系是表，那么关系模式就是表头</p><p>关于域、笛卡尔积、元组、分量、基数、度、关系、属性等简单概念就不再赘述</p><h4 id="关系的一些关键概念"><a href="#关系的一些关键概念" class="headerlink" title="关系的一些关键概念"></a>关系的一些关键概念</h4><h5 id="各种码-键（key）"><a href="#各种码-键（key）" class="headerlink" title="各种码/键（key）"></a>各种码/键（key）</h5><p><strong>（超）码/键</strong>是可以唯一表示元组的属性组，可以<strong>最小唯一标识</strong>的属性组被称为<strong>候选码/键</strong>，在这些候选码/键中选择一个作为使用的标识即可，规定作为标识的称为<strong>主码/键</strong>。</p><p>如果一个主码/键就是关系的<strong>整个属性组</strong>，那么被称为<strong>全码/键</strong></p><p>候选码的属性被称为<strong>主属性</strong>，这一点需要注意，<strong>并不只有主码的属性才叫主属性</strong></p><p>当一个实体<strong>引用</strong>了另一个实体的时候，需要将其<strong>主码</strong>作为自己的属性，被称为<strong>外码/键</strong></p><h5 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h5><p>联系分为1:1，1:n，m:n三种类型，都可以用外键来表示，但是m:n关系很容易导致冗余的出现，因此需要单独拆分出来一个关系表示一对m:n联系</p><h4 id="三类关系"><a href="#三类关系" class="headerlink" title="三类关系"></a>三类关系</h4><p>在RDB中，存在三类关系：</p><ul><li>基本关系（基本表）：也就是一张实际存在的表</li><li>查询表：对于基本表查询以后的结果汇聚为一张表</li><li>视图表：基本表或者其他试图表导出的虚表，没有实际的数据存储</li></ul><p>这些内容在后面都有更详细的解释</p><h4 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h4><ul><li>列同质：一个列的分量来自同一个域</li><li>不同列可以出自同一个域</li><li>列顺序可以交换</li><li>元组候选码不能相同</li><li>行顺序可以交换</li><li>分量必须取原子值（1NF）</li></ul><h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>前面说过<strong>模式是实例的型</strong>，那么<strong>关系模式其实就是关系的型</strong>：关系模式相对稳定，关系是随时间变化的。当然，不那么严格的，有时候也会把关系模式成为关系，重点还是看上下文想表达的是这个型还是值</p><p>关系模式可以表示为</p><script type="math/tex; mode=display">R(U,D,DOM,F)</script><p>其中R表示关系名，D是属性名集合，DOM是属性向域的映射集合，F是属性之间数据依赖关系的集合</p><p>不同的属性可能来自同一个域，也就是说U中的元素可能比D多，所以为了知道具体哪个属性出自哪个域，就需要DOM这个映射来表示</p><p>一半来说，我们也可以简记为：</p><script type="math/tex; mode=display">R(U)=R(A_1, A_2,...,A_n)</script><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>所有关系的集合构成的数据库</p><p>其型为关系数据库模式Schema，是对其的描述；值是某一时刻对应的关系的集合</p><h3 id="关系模型的存储结构"><a href="#关系模型的存储结构" class="headerlink" title="关系模型的存储结构"></a>关系模型的存储结构</h3><p>这一段说的比较笼统，关于物理存储，若一个表对应一个文件，则由操作系统进行物理数据的组织；若一个表对应多个文件，就需要DBMS自己进行存储管理。</p><h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><h3 id="基本关系操作"><a href="#基本关系操作" class="headerlink" title="基本关系操作"></a>基本关系操作</h3><p>基本关系操作按照是否改变了数据分为：查询、更新两类</p><p>查询操作有：选择、投影、连接、除、并、差、交、笛卡尔积；其中选择、投影、并、差、笛卡尔积是5种基本操作</p><p>也就是说，连接、除、交是导出操作。首先说连接，笛卡尔积可以导出连接，但是连接不能导出笛卡尔积，所以连接不算基本操作；除在后续会提到，这算是最复杂的关系操作了，所以也不算基本；交这个操作有点鸡肋，在选择的时候把筛选条件and起来就算是代替交了，所以也不是基本操作。</p><p>更新操作有：插入、删除、修改</p><p>关系操作采用<strong>一次一集合</strong>的方式，其对象与结果都是集合</p><h3 id="关系数据库语言的分类"><a href="#关系数据库语言的分类" class="headerlink" title="关系数据库语言的分类"></a>关系数据库语言的分类</h3><ul><li><strong>关系代数</strong>语言用的就是关系运算来表示查询要求，代表为ISBL</li><li><strong>关系演算</strong>语言使用谓词表达，课程没有教授</li><li><strong>结构化查询语言SQL</strong>则结合了两者的特点</li></ul><h2 id="关系完整性"><a href="#关系完整性" class="headerlink" title="关系完整性"></a>关系完整性</h2><p>关系的完整性约束分为：实体完整性、参照完整性、用户定义的完整性。前两者称为关系的<strong>两个不变性</strong></p><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>要求<strong>主属性</strong>非空（not NULL），因为主码唯一标识着实体，若主属性空，则说明实体不可区分。</p><h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>倘若关系R通过外键F引用了关系S，那么F要么为S中某一个存在的元组的主码，要么为空</p><p>也就是说，<strong>不允许引用不存在的实体</strong></p><h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><p>与具体的语义有关，需要用户的理解</p><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>关系代数的运算对象和结果都是关系，分为：集合运算符（水平）、专门的关系运算符（行列都涉及）</p><p><img src="/images/DBSNote/image-20221207230407140.png" alt="image-20221207230407140"></p><h3 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h3><p>这部分比较容易理解，只需要确定两个关系要满足并相容（属性个数相同且所在的域一一对应）</p><h3 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h3><h4 id="一些记号"><a href="#一些记号" class="headerlink" title="一些记号"></a>一些记号</h4><ul><li>$t[A_i]$：元组$t$在属性$A_i$的分量</li><li>$t[A]$：元组在属性组上的分量构成的子元组</li><li>$Z_x$：象集，若有关系$R(X,Z)$，则$Z_x = { t[Z]|t\in R,t[X]=x}$</li></ul><h4 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h4><p>又叫限制Restriction，指选出符合条件的元组，记为：</p><script type="math/tex; mode=display">\sigma _F (R) = \{t|t \in R \and F(t)=true\}</script><p>$F$是选择的条件，基本形式为$X_1\Theta Y_1$，其中$\Theta$为比较运算符，如果存在嵌套的话，优先级从高到低为：括号、比较、非、与、或</p><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>Projection，选出一部分属性列来，记为：</p><script type="math/tex; mode=display">\pi _A (R) = \{t[A]|t \in R \}</script><h4 id="连接（-Theta-连接）"><a href="#连接（-Theta-连接）" class="headerlink" title="连接（$\Theta$连接）"></a>连接（$\Theta$连接）</h4><script type="math/tex; mode=display">R\underset{A\Theta B}\Join S = \{\overset{\frown}{t_r t_s}|t_r \in R \and t_s \in S \in t_r[A] \Theta t_s[B]\}</script><p>也就是在两个关系的笛卡尔积中选择满足关系$\Theta$的关系</p><p><strong>等值连接：</strong>当$\Theta$为等号的时候，成为等值连接</p><p><strong>自然连接：</strong>在<strong>同名</strong>属性组上做等值连接，在结果中会把两个属性合并</p><p><strong>外连接：</strong></p><p>​    <strong>悬浮元组：</strong>R、S做自然连接的时候，R中可能存在一些S中没有对应的元组，这些元组在连接的时候就被舍弃了。</p><p>​    <strong>外连接：</strong>把悬浮元组保存在结果中，另一边赋值为NULL；若只保留左边关系的元组，就叫<strong>左外连接</strong>，反之叫<strong>右外连接</strong>。</p><h4 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h4><p>设$R(X,Y)$，$S(Y,Z)$借助之前象集的定义，除运算定义为：</p><script type="math/tex; mode=display">R\div S = \{t_r[X]| t_r \in R \and \pi _y (S)\in Y_x, x=t_r[X]\}</script><p>也就是说，在关系$R$中给定一个$x$，$x$对应的$y$值必须要能够包含$S$中出现的所有$y$值</p><p>所以除法运算解决“查询…至少/全部的/所有的”这类问题很方便</p><p>除运算也可以不用象集定义：</p><script type="math/tex; mode=display">R\div S = \pi _x (R) - \pi_x((\pi_x(R)\times S)-R)</script><p>举一个简单的例子，即可表示除运算的方便之处：</p><p>查询选修了所有课程的学生学号：$\pi<em>{Sno,Cno}(SC)\div \pi</em>{Cno}(Course)$</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关系数据库是目前最常用的数据库系统，本章按照数据模型的三大要素对其进行了介绍。</p><p>首先是关系数据结构，关系就是一张二维表，这也是关系数据库唯一的数据结构。具体而言，一个关系数据库中往往有三种表：基本表、查询表、试图表。</p><p>关系模式则用来表示关系的结构，是关系的型。</p><p>对于具体的物理存储，本章没有过多介绍，只说了可以一个基本表一个文件让OS管理、也可以建立多个文件让DBMS管理。</p><p>关系操作有查询、更新两类：</p><p>查询操作有：选择、投影、连接、除、并、差、交、笛卡尔积；其中选择、投影、并、差、笛卡尔积是5种基本操作</p><p>更新操作有：插入、修改、删除</p><p>描述关系操作的语言有：关系代数、关系演算、SQL。本章下面会重点讲解关系代数，SQL则会再后面单独开几章，关系演算则不在课程范围内。</p><p>关系完整性包含：实体完整性、参照完整性、用户定义的完整性。前两者为关系的两个不变性。</p><p>关系代数是一种以关系（集合）为对象和结果的关系操作表示方法，分为集合运算与关系运算。其中，关系运算主要包含了选择、投影、连接、除。连接的分类较多，包含$\Theta$连接、等值连接、自然连接、外连接等。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX语法支持教程</title>
      <link href="/2022/12/07/hexo%E5%8D%9A%E5%AE%A2latex%E6%94%AF%E6%8C%81%E6%95%99%E7%A8%8B/"/>
      <url>/2022/12/07/hexo%E5%8D%9A%E5%AE%A2latex%E6%94%AF%E6%8C%81%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="教程来源"><a href="#教程来源" class="headerlink" title="教程来源"></a>教程来源</h2><p>主要参考<a href="https://blog.csdn.net/crazy_scott/article/details/79293576">(98条消息) hexo下LaTeX无法显示的解决方案_zealscott的博客-CSDN博客</a></p><p>略有不同，主要在主题的_config.yml</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>首先需要安装mathjax：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math -save</span><br></pre></td></tr></table></figure><p>然后需要把hexo默认的md渲染引擎<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>换成<a href="https://github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uinstall hexo-renderer-marked -save</span><br><span class="line">npm install hexo-renderer-kramed -save</span><br></pre></td></tr></table></figure><h2 id="修改转义"><a href="#修改转义" class="headerlink" title="修改转义"></a>修改转义</h2><p>LaTeX与markdown语法有语义冲突，在markdown中，斜体和加粗可以用*或者_表示，在这里我们修改变量，将_用于LaTeX，而使用*表示markdown中的斜体和加粗</p><p>找到博客下<code>node_modules\kramed\lib\rules\inline.js</code>修改如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>原文中说需要找到主题下的<code>_config.yml</code>修改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><p>但是我用的<code>Chic</code>主题，进去以后发现<code>config.yml</code>有关部分是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plugin functions</span></span><br><span class="line"><span class="comment">## Mathjax: Math Formula Support</span></span><br><span class="line"><span class="comment">## https://www.mathjax.org</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">import:</span> <span class="string">demand</span> <span class="comment"># global or demand</span></span><br><span class="line">  <span class="comment">## global: all pages will load mathjax,this will degrade performance and some grammers may be parsed wrong.</span></span><br><span class="line">  <span class="comment">## demand: Recommend option,if your post need fomula, you can declare &#x27;mathjax: true&#x27; in Front-matter</span></span><br></pre></td></tr></table></figure><p>就没修改了</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在博客开头加上 <code>mathjax: true</code></p><p>然后测试效果如下：</p><p>$\Sigma _0 ^n \frac{1}{n}$</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简易教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理第一章 绪论</title>
      <link href="/2022/12/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%AA%E8%AE%BA/"/>
      <url>/2022/12/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>本课程主要包含：</p><ul><li>关系代数</li><li>SQL:DDL、DML</li><li>数据库建模与设计：ERD、范式分解</li><li>数据库安全：访问控制、SQL注入</li><li>数据库基本开发：JDBC、WEB开发、字符集</li></ul><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><p>和其他课程的惯例一样，本课程第一章第一节的第一部分讲述了数据库的发展历程：</p><ul><li>数据库技术产生于六十年代末</li><li>数据库技术是信息系统的核心和基础</li><li>它研究如何有效地组织和存储数据，如何高效地获取和处理数据</li><li>1960年代出现网状、层次模型，1970年代出现关系模型、Peter Chen提出E-R模型</li></ul><h3 id="四个概念"><a href="#四个概念" class="headerlink" title="四个概念"></a>四个概念</h3><p>对于数据库，首先需要了解如下的四个基本名词概念：</p><h4 id="数据（Data），及信息、知识等"><a href="#数据（Data），及信息、知识等" class="headerlink" title="数据（Data），及信息、知识等"></a>数据（Data），及信息、知识等</h4><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><ul><li>定义：描述事物的<strong>符号记录</strong>，可以识别、抽象。</li><li>种类：数字，文字，图片，视频，档案记录等</li><li>另一种定义：使用约定俗成的关键字，对客观事物的数量、属性、状态、相互关系等进行<strong>抽象表示</strong>，用人工或自然的方式保存和处理。</li></ul><h5 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h5><p>与数据对应的，还有信息这一定义：信息是有<strong>时效性</strong>，有一定含义和逻辑，经过<strong>加工处理的</strong>、对决策有价值的<strong>数据流</strong>。</p><p>也就是说：<strong>信息=数据+处理</strong>，例如：<em>张三，男，22岁，网安学院研究生，身高1.75米，体重72公斤</em></p><p><strong>数据是符号化的信息、信息是语义化的数据</strong>：数据是信息的载体，信息是数据的内涵和解释</p><p>e.g. （李明，男，199505，江苏南京市，计算机系，2013）是一条数据记录，如果不给其他信息就让你解释其意思，那这个江苏省南京市，可能是其籍贯、也可能是其现在的居住地址，只有给定了数据的语义：学生姓名、性别、出生年月、出生地、所在院系、入学时间，才能知道这条记录表达的信息是：李明是个大学生，1995年5月出生，江苏南京市人， 2013年考入计算机系。</p><h5 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h5><p>而对信息进一步处理，又会出现一个新的概念：<strong>知识</strong>，其是对进行归纳、演绎、比较等的结果。</p><p>e.g. 信息：张三是北航学生，李四是北航学生</p><p>-&gt;知识：张三和李四是校友</p><p>进一步，在大数据时代，诞生了<strong>数据挖掘</strong>：对于大量的实际数据，提取隐含的潜在信息。常用的算法有分类、聚类、回归等…因此，人工智能、商务智能、模式识别、机器学习等也是数据挖掘的同义词。</p><h5 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类"></a>数据的分类</h5><p>数据有结构化、半结构化、非结构化之分：</p><ul><li><strong>结构化数据</strong>可以被关系型数据库存储，也就是二维表格形式的数据</li><li><strong>半结构化数据</strong>也是结构化数据的一种表示，但是不能符合关系数据模型，XML、JSON等都是半结构化数据</li><li><strong>非结构化数据</strong>顾名思义是一种没有固定结构的数据，如图片、视频、文档等</li></ul><h4 id="数据库（Database，DB）"><a href="#数据库（Database，DB）" class="headerlink" title="数据库（Database，DB）"></a>数据库（Database，DB）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p><strong>长期储存</strong>在计算机内、<strong>有组织</strong>、<strong>可共享</strong>的大量数据集合</p><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><ul><li>按照一定的模型组织、描述和存储（如关系模型）</li><li>可共享（多个用户访问一个DB）</li><li>冗余度较小（数据库建立之前进行了范式分解）</li><li>数据独立性高（视图等方法）</li><li>易拓展（比如可以添加属性）</li></ul><h4 id="数据库管理系统（Database-Manage-System，DBMS）"><a href="#数据库管理系统（Database-Manage-System，DBMS）" class="headerlink" title="数据库管理系统（Database Manage System，DBMS）"></a>数据库管理系统（Database Manage System，DBMS）</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>帮助用户<strong>定义、创建、维护和控制数据库访问</strong>的软件，DBMS是一种<strong>大型复杂</strong>的<strong>基础软件</strong></p><p><strong>DBMS在用户与OS之间</strong></p><p><img src="/images/DBSNote/image-20221205160029091.png" alt="image-20221205160029091"></p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><ul><li>科学的<strong>组织和存储</strong>数据（DBMS可以自动管理）</li><li>高效地<strong>获取和维护</strong>数据（API与工具）</li></ul><h5 id="DBMS的功能"><a href="#DBMS的功能" class="headerlink" title="DBMS的功能"></a>DBMS的功能</h5><ul><li>数据定义<ul><li>提供DDL数据定义语言</li></ul></li><li>数据组织、存储、管理<ul><li>分类</li><li>确定文件结构、存取方式</li><li>实现数据之间的联系</li><li>提供多种存取方法（优化器）</li></ul></li><li>数据操纵<ul><li>使用DML数据管理语言进行基本操作：增删查改</li></ul></li><li>事务管理和运行管理<ul><li>DB的控制</li><li>安全性、完整性、并发</li><li>数据恢复</li></ul></li><li>数据库的建立和维护<ul><li>初始化：初始数据的装载和转换</li><li>DB的备份、转储</li><li>性能监视、分析</li><li>数据库重组织</li></ul></li><li>其他功能<ul><li>与其他软件通信（JDBC等）</li><li>数据转换</li><li>异构数据库的互访互操作</li></ul></li></ul><h4 id="数据库系统（Database-System，DBS）"><a href="#数据库系统（Database-System，DBS）" class="headerlink" title="数据库系统（Database System，DBS）"></a>数据库系统（Database System，DBS）</h4><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><p>DBS是一套系统，面向的是可能不懂数据库以及编程的用户，因此需要管理员和用户使用的应用程序，包含：</p><ul><li>数据库<ul><li>底层数据文件、结构、存取方式</li><li>数据字典（对于数据库的描述）</li></ul></li><li>DBMS及其应用开发工具</li><li>应用程序</li><li>数据库管理员DBA</li></ul><p>其结构图如下：</p><p><img src="/images/DBSNote/image-20221205161015044.png" alt="image-20221205161015044"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>数据库系统有如下特点：</p><ul><li><p>数据结构化</p><ul><li><strong>数据的整体结构化</strong>是数据库的<strong>主要特征</strong>之一，针对全组织、包含数据之间的联系，数据记录是可变长的，数据的最小单位是数据项</li></ul></li><li><p>数据共享性高、冗余度低</p></li><li>数据独立性高<ul><li>包含<strong>物理独立性和逻辑独立性</strong></li><li>主要有<strong>二级映像</strong>功能保证</li></ul></li><li>数据由DBMS统一管理控制<ul><li>安全性、完整性检查</li><li>并发控制</li><li>数据恢复</li></ul></li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型是对于现实世界数据特征的抽象，其应该满足：</p><ul><li>真实模拟现实世界</li><li>容易被人理解</li><li>便于计算机实现</li></ul><p>数据模型是数据库系统的<strong>核心和基础</strong>（这个不难理解，区别主流RDBMS和以前的一些DBMS的区别就是RDBMS使用了关系模型）</p><p>哈工大网课是这样形容数据模型的：数据模型是对模式的描述、是数据结构的结构</p><h3 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h3><p>这两类数据模型主要是根据数据模型作用的<strong>层次</strong>不同来划分的</p><h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><p>概念模型主要是按照<strong>用户观点</strong>来的，又叫<strong>信息模型</strong></p><p>如E-R图等，信息模型是与计算机系统无关的</p><h4 id="逻辑模型和物理模型"><a href="#逻辑模型和物理模型" class="headerlink" title="逻辑模型和物理模型"></a>逻辑模型和物理模型</h4><h5 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h5><p>逻辑模型是按照计算机系统的观点建模的，用于DBMS的实现。e.g.网状模型、层次模型、关系模型</p><p>如关系模型等，与计算机系统有关，但是与具体的物理系统无关</p><h5 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h5><p>物理模型顾名思义是数据在<strong>系统中的表示方式和存取方法</strong></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><strong>数据模型</strong>是表达计算机世界的模型，<strong>概念模型</strong>是表达信息世界的模型</p><p>！！！注意区分，前面说：数据模型分为概念模型，逻辑模型和物理模型，这里又把数据模型和概念模型做了对比，翻书后认为两个数据模型不是一个含义，前面的数据模型是一个笼统的称呼，就是表达数据的抽象，而后面与概念模型相对的数据模型则是具体的，比如说关系数据模型，是有其规定的数据结构、数据操作等…</p><p>几种数据模型的关系图：</p><p><img src="/images/DBSNote/image-20221206103123003.png" alt="image-20221206103123003"></p><h4 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h4><p>数据建模是一个抽象的过程，即：理解-区分-命名-表达</p><h3 id="概念模型-1"><a href="#概念模型-1" class="headerlink" title="概念模型"></a>概念模型</h3><p>用于信息世界的建模，可以在设计人员和用户之间交流（ERD）</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="实体Entity"><a href="#实体Entity" class="headerlink" title="实体Entity"></a>实体Entity</h5><p>客观存在且能够相互区分的实物</p><h5 id="属性Attribute"><a href="#属性Attribute" class="headerlink" title="属性Attribute"></a>属性Attribute</h5><p>实体的某一特征</p><h5 id="码-键Key"><a href="#码-键Key" class="headerlink" title="码/键Key"></a>码/键Key</h5><p>可以唯一标识实体的属性集</p><h5 id="实体型Entity-Type"><a href="#实体型Entity-Type" class="headerlink" title="实体型Entity Type"></a>实体型Entity Type</h5><p>实体名+属性名的集合，用于刻画一类实体</p><h5 id="实体集Entity-Set"><a href="#实体集Entity-Set" class="headerlink" title="实体集Entity Set"></a>实体集Entity Set</h5><p>同一类型实体的集合</p><h5 id="联系Relationship"><a href="#联系Relationship" class="headerlink" title="联系Relationship"></a>联系Relationship</h5><p>现实世界事物之间的联系，在信息世界中被反映为实体之间的联系</p><h3 id="数据模型的组成"><a href="#数据模型的组成" class="headerlink" title="数据模型的组成"></a>数据模型的组成</h3><p>数据模型由数据结构、数据操作和数据的完整性约束条件组成：</p><ul><li>数据结构：描述的是组成对象<strong>及其联系</strong>（注意包含联系，这很好理解，比如需要在关系中表明外键），是系统<strong>静态特性</strong>的描述</li><li>数据操作：包含操及其规则</li><li>数据完整性约束条件：对于数据模型中数据及其关系的制约和依存规则</li></ul><h3 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h3><ul><li>层次</li><li>网状</li><li>关系</li><li>O-O</li><li>对象关系</li><li>半结构化</li><li>图</li></ul><h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>也就是树形结构，结点双亲唯一，不能处理多对多</p><p><strong>优点</strong>：查询很快</p><p><strong>缺点</strong>：难以表示多对多，插入删除限制太多</p><h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><p>也就是图结构，允许多个无双亲节点，一个节点可以有多个双亲</p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>用户观点下，其逻辑结构是一张二维表（不允许表中有表）</p><ul><li>关系Relation：一张表</li><li>元组Tuple：表的一行</li><li>属性Attribute：表的一列</li><li>主键Key：可以唯一确定元组的属性组</li><li>域Domain：同类型数据的集合，属性范围是域的子集</li><li>分量Component：元组的一个属性值</li><li>关系模式Relation Schema：关系名（属性1，…，属性n）</li></ul><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>数据操作是集合（关系）操作，其对象和结果都是集合（关系），且操作路径对用户隐蔽</p><h4 id="完整性约束条件"><a href="#完整性约束条件" class="headerlink" title="完整性约束条件"></a>完整性约束条件</h4><p>关系模型存在三种完整性约束条件：实体完整性、参照完整性、用户定义完整性</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><ul><li>严格数学基础</li><li>概念单一</li><li>存取透明</li></ul><p><strong>缺点：</strong></p><ul><li>效率往往低于前面两者</li><li>查询需要优化</li></ul><h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><p>数据库的用户看来，数据库有：单用户、分布式、C/S、Web-App等结构</p><p>从开发人员来看，数据库内部的系统通常是三级<strong>模式</strong>结构</p><p>模式可以看作是数据库的<strong>型</strong>，描述了数据库的逻辑结构和特征，翻译数据的结构和联系，是相对稳定的；</p><p>实例是模式的具体<strong>值</strong>，反映了数据库在某一时刻的状态，是随时变化的。</p><h3 id="三级模式结构"><a href="#三级模式结构" class="headerlink" title="三级模式结构"></a>三级模式结构</h3><p>三级模式结构分为：</p><ul><li>外模式</li><li>模式</li><li>内模式</li></ul><p>示意图如下：</p><p><img src="/images/DBSNote/image-20221206115607863.png" alt="image-20221206115607863"></p><h4 id="模式Schema（逻辑模式）"><a href="#模式Schema（逻辑模式）" class="headerlink" title="模式Schema（逻辑模式）"></a>模式Schema（逻辑模式）</h4><p><strong>全体数据</strong>的逻辑结构和特征，是<strong>所有用户</strong>的公共数据视图</p><p>模式处在一个中间的位置，与物理细节无关，<strong>也与具体APP、开发工具无关</strong></p><h4 id="外模式External-Schema"><a href="#外模式External-Schema" class="headerlink" title="外模式External Schema"></a>外模式External Schema</h4><p>外模式是用户模式，是<strong>用户局部数据</strong>的逻辑结构和特征的描述，<strong>与应用有关</strong></p><p>外模式处在模式和应用之间，是模式的子集，基于外模式可以开发多个外模式，但是<strong>一个应用程序只能用一个外模式</strong>（也就是说，APP连接数据库只能作为一个用户登陆）</p><p>外模式可以保障数据库安全性：每个用户看不见完整的模式，只能看见自己对应的外模式</p><h4 id="内模式Internal-Schema（存储模式）"><a href="#内模式Internal-Schema（存储模式）" class="headerlink" title="内模式Internal Schema（存储模式）"></a>内模式Internal Schema（存储模式）</h4><p>内模式又叫存储模式，顾名思义，是数据的物理结构和存储方式的描述，例如：</p><ul><li>记录的存储：如顺序，B+树，Hash等方法</li><li>索引如何组织</li><li>数据是否压缩</li><li>数据是否加密</li></ul><p>同样一个数据库也只有一个内模式</p><h3 id="二级映像"><a href="#二级映像" class="headerlink" title="二级映像"></a>二级映像</h3><p>有了三级映像，自然需要出现其间的两级映射关系</p><h4 id="外模式-模式映像"><a href="#外模式-模式映像" class="headerlink" title="外模式/模式映像"></a>外模式/模式映像</h4><p>也就是从模式映射到每个用户的外模式，通常定义在外模式的描述中。</p><p>外模式/模式映像可以保证数据的<strong>逻辑独立性</strong>：模式改变的时候，DBA改变外模式/模式映象，使得外模式保持不变。这样，APP就不需要修改，保证了<strong>数据与APP的逻辑独立性</strong>，简称<strong>数据的逻辑独立性</strong>。</p><h4 id="模式-内模式映像"><a href="#模式-内模式映像" class="headerlink" title="模式/内模式映像"></a>模式/内模式映像</h4><p>该映像定义了<strong>全局逻辑结构</strong>和<strong>存储结构</strong>之间的关系，定义在模式的描述中</p><p>内模式和模式都是唯一的，很明显这个映像也是唯一的</p><p>模式/内模式映像保证了数据的物理独立性：存储结构（内模式）改变的时候，DBA修改该映像，使得模式保持不变。保证了数<strong>据与APP的物理独立性</strong>。简称<strong>数据的物理独立性</strong>。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>外模式稳定</li><li>数据与APP在逻辑、物理上都是独立的，所以大大减少了APP的修改</li></ul><h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>数据库是一个庞大的系统，还是之前说过的那句话，数据库系统是需要给非程序员使用的，其包含：</p><ul><li><p>DB</p></li><li><p>DBMS及其开发工具</p></li><li><p>App</p></li><li><p>DBA</p></li><li><p>硬件平台：内存、磁盘、通信</p></li><li><p>软件：除了DBMS之外，还要与DB接口的高级语言及其编译器，应用系统等</p></li><li><p>人员：除了DBA之外，还要DB设计人员、系统分析人员、应用程序员，用户</p><p>​    各级人员职责如下：</p><ul><li>DBA：决定DB的内容、结构、存取策略、安全性完整性要求、监控DB、改进重组DB</li><li>系统分析人员：需求分析、规范说明、DB概要设计</li><li>DB设计人员：需求调查，确认数据以及各级模式</li><li>应用程序员：编写、调试、安装应用程序</li><li>用户：<ul><li>偶然用户：偶尔访问，如高管</li><li>简单用户：日常查询更新，如旅馆前台</li><li>复杂用户：科学家，工程师等，可以直接使用DB语言访问</li></ul></li></ul><p>​    人员使用的DBS各级示意图：</p><p><img src="/images/DBSNote/image-20221206161221993.png" alt="image-20221206161221993"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章主要是对于数据库的一个笼统概念介绍</p><p>首先介绍了最基本的四个概念：Data、DB、DBMS、DBS，这几个概念是从小到大的包含关系</p><p>然后介绍了数据的两类模型：概念模型、逻辑模型和物理模型。</p><p>其中，概念模型与数据库系统无关，是用户可以看懂的（如ERD），用于信息世界；逻辑模型与数据库系统有关，但是不涉及底层硬件，如关系模型；物理模型则描述的是是底层的存储方式。后两者都在计算机世界。</p><p>这中间，重点介绍了概念模型，概念模型包含三大要素：数据结构、数据操作、数据完整性约束条件。概念模型中有实体、属性、码、实体型、实体集、联系等关键概念。</p><p>经典的概念模型有树状的层次模型和图结构的网状模型，目前最常用的是关系模型。关系模型的数据结构是一张二维表、数据操作包含增删查改等基本操作，且都是面向集合（关系）的操作、关系模型有三大完整性：实体、参照、用户定义。</p><p>接下来，本章具体介绍了数据库系统的结构，数据库系统常常采用外模式-模式-内模式的三级结构，分别对于用户部分数据逻辑结构-整体数据逻辑结构-数据物理结构。连接三级结构的是两级映像：外模式/模式映像、模式/内模式映像，两级映像分别保障了数据和应用程序之间在逻辑和物理上的独立性。</p><p>数据库是一个庞大的系统，除了数据、数据库管理系统以外，还有建立在数据库上的应用程序和数据库的有关软件，以及各类人员：DBA、系统分析人员，应用程序员，各种用户等。不同用户可以访问和修改数据库的不同层级。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何制作更好看的客制化PCB及其渲染图</title>
      <link href="/2022/11/11/pretty-pcb/"/>
      <url>/2022/11/11/pretty-pcb/</url>
      
        <content type="html"><![CDATA[<h2 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h2><p>键盘的PCB与其他电子元器件里面的PCB有所不同，需要一些颜值和声音（玄学）上的改变来吸引顾客，其中最著名的就是owlab的suit、spring系列pcb：黑芯，沉金，漏线。同时还有IRIS65等pcb采用黑芯，线路单独上颜色的pcb。</p><p>最近这几天没有继续折腾pcb代码功能了，试一试这些奇奇怪怪的东西，当然目前还没有合适的板子（和钱）去打样。</p><h2 id="PCB基本介绍"><a href="#PCB基本介绍" class="headerlink" title="PCB基本介绍"></a>PCB基本介绍</h2><p>要知道各种PCB的效果是怎么做的，就需要首先知道PCB的基本结构和其中的一些术语。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>对于键盘的FR-4双层板来说，我们可以这样理解其结构：</p><p>PCB的<strong>基础（core）是一张FR-4板</strong>（通常是黄白色的，很丑，但也有黑色磨砂质感的，很贵），在这个线路上，会<strong>蚀刻一层铜（copper）</strong>，是你画的线路和焊盘。然后，为了保护线路，pcb最上层还会有一层<strong>阻焊（solder）</strong>，可以理解成一层油漆，也就是导致pcb出现黑白绿等多种不同颜色的东西。当然，焊盘是不能被阻焊覆盖，要露出来焊东西的，这种给阻焊留空的工艺我们叫做<strong>开窗</strong>。</p><p>所以简单理解，<strong>PCB从里到外就是这三层结构：FR-4基板、铜线路、阻焊</strong>。</p><h3 id="铺铜"><a href="#铺铜" class="headerlink" title="铺铜"></a>铺铜</h3><p>所以铺铜，其实是一种另类的走线，铺铜一般用在GND线路上面，增加接地性能。在链接完出了GND的所有线路之后，还会剩下很多空位置是没有走线的，这时候我们就可以用铺铜把这些位置用铜填起来，并给将其作为一大块GND线路连接各个GND焊盘。</p><h2 id="不同类型PCB方案分析"><a href="#不同类型PCB方案分析" class="headerlink" title="不同类型PCB方案分析"></a>不同类型PCB方案分析</h2><h3 id="黑色-漏线（owlab）"><a href="#黑色-漏线（owlab）" class="headerlink" title="黑色 漏线（owlab）"></a>黑色 漏线（owlab）</h3><p>最经典的spring、suit80的pcb样式，线是铜色的（而不是金色，这个线路的颜色和焊盘沉金的颜色是不一样的，这个线路更偏红），板材是黑色的。</p><p>其思路为：</p><ul><li>不铺铜，GND也用走线连接（不过一般GND、VCC走线会稍微宽一点）</li><li>透明阻焊</li><li>黑芯板材</li></ul><p>不铺铜的原因很简单，露出来一大块一大块的铜太丑了</p><p>所以要制造这种pcb，主要是对工厂要求高：黑芯板材、透明阻焊</p><p>目前找到能做这两种的只有猎板网</p><p><img src="/images/pretty-pcb/image-20221112095259973.png" alt="image-20221112095259973"></p><h3 id="白色-漏线"><a href="#白色-漏线" class="headerlink" title="白色 漏线"></a>白色 漏线</h3><p>观感效果与上面的类似，都是露出了金色的走线，但是实际上设计思路很不一样</p><p>之前我们提到过，阻焊是可以开窗的，而正常情况下只有需要焊接的焊盘是露出来的。而这张PCB不一样，他给导线也开窗了，也就是说导线上面是没有阻焊的。</p><p>这个<strong>操作很简单</strong>，在立创eda就可以完成：点一下导线，右边的属性栏中会有一个开窗选项，点一下就给你的导线开窗了。</p><p>仔细对比可以发现，这张板子的导线和上面ow板子的导线都是金色的，但是色调却不一样：ow板子的是偏红的铜色、这一张板子其实是和沉金焊盘一样的灿金色。</p><p>铜裸露出来很容易氧化，所以实际上这个板子漏的线上面还沉金保护了。</p><p><strong>不推荐这种设计</strong>：裸露的导线容易被短接出问题，而且焊接的时候一不小心沾了一点锡到导线上面就真的寄了。如果非要用这种设计的话，请<strong>只给按键矩阵的走线开窗</strong>，其他位置的导线为了安全起见不要开窗。</p><p><img src="/images/pretty-pcb/O1CN01VysK0c1UKaY1uTAYH_!!980092499.jpg" alt="img"></p><h3 id="黑色-彩色走线"><a href="#黑色-彩色走线" class="headerlink" title="黑色 彩色走线"></a>黑色 彩色走线</h3><p>最初见到这种PCB是在Iris 65上面</p><p>与owlab的pcb相同的点是在于，都采用黑芯板材并将其露了出来</p><p>不同的点是这张PCB的走线采用了红色阻焊覆盖</p><p>所以这张板子的思路为：</p><ul><li>不铺铜</li><li>黑芯板材</li><li>除导线以外全部开窗</li></ul><p>这张板子的省去了透明阻焊的钱，会比ow那种便宜一些，至于哪个好看就见仁见智了。</p><p><strong>难点</strong>在于，如何只给导线上阻焊，而其他位置全部开窗的。这个操作稍微难一些，在下一节详细介绍。</p><p><img src="/images/pretty-pcb/image-20221112100202737.png" alt="image-20221112100202737"></p><h2 id="第三种PCB板子画法教程"><a href="#第三种PCB板子画法教程" class="headerlink" title="第三种PCB板子画法教程"></a>第三种PCB板子画法教程</h2><p>在立创eda中，要么选择导线给他开窗，要么自己到阻焊层画一个区域，这个区域内就开窗了。</p><p>这里提到了<strong>阻焊层</strong>这个概念，这一层是在画pcb时常常被忽略的一层。一般来说，默认给焊盘开窗而其他地方不开，所以阻焊层就没什么人去管了。</p><p>阻焊层是负逻辑的，也就是说，你在阻焊层画了一个形状，这一块就进行开窗了，而没画东西的地方就任然保留阻焊。</p><p>那么要画出Iris65的pcb效果，就要在阻焊层画出所有没有导线的地方的形状。立创eda目前没有区域选择或者反向选择的功能，所以需要手动描摹出导线意外区域的形状，想想给不是给人干的。</p><p>那有没有什么办法，可以自动在没有导线的地方画满呢？答案是<strong>铺铜</strong></p><p>我们需要在线路层，创造一个不属于任何网络（no-net）的铺铜，然后将其转移到阻焊层即可。就这么简单</p><p>但是遗憾的是，立创eda的铺铜不支持创建不属于任意网络的铺铜，所以我们只能求助于其他功能更强大的eda。</p><p>这里我们选择了<strong>Altium Designer</strong>（简称AD），版本使用AD17版本。因为嘉立创的pcb可以导出为AD，而在其官网说明中，导出兼容性最好的是17版本。</p><h3 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h3><h4 id="修改板子大小"><a href="#修改板子大小" class="headerlink" title="修改板子大小"></a>修改板子大小</h4><p>嘉立创导出pcb到ad以后，pcb的边框是比在立创eda中要大的：</p><p><img src="/images/pretty-pcb/image-20221112102949830.png" alt="image-20221112102949830"></p><p>我们需要先修改一下大小，首先删掉立创导出的边框（这个一般会有bug），在下方<strong>切换到Keep-Out Layer</strong>，然后按住P+L在这一层开始画线，画出你想要的边框。</p><p>ad中的<strong>多选</strong>是按住shift不放开，按住shift选中你画的边框。</p><p>然后在<strong>菜单&gt;设计&gt;板子形状</strong>中点击<strong>按选择对象定义</strong>，板子就变小了：</p><p><img src="/images/pretty-pcb/image-20221112103752107.png" alt="image-20221112103752107"></p><h4 id="修改铺铜规则"><a href="#修改铺铜规则" class="headerlink" title="修改铺铜规则"></a>修改铺铜规则</h4><p>铺铜的时候，线路和铺铜之间肯定是有一段距离的，同时太小的地方也不会铺铜。但是我们只是借助铺铜来画开窗的区域，希望是能在没有导线和焊盘的地方全部铺铜，然后再转移到阻焊层。所以需要修改一下铺铜规则：</p><p>参考文章<a href="https://blog.csdn.net/LJin19910205/article/details/80520207">Altium Designer 敷铜间距规则设置<em>lijinaaaaa的博客-CSDN博客</em>覆铜间距</a>，将铺铜间距设为0（或者很小的数）</p><h3 id="创建铺铜"><a href="#创建铺铜" class="headerlink" title="创建铺铜"></a>创建铺铜</h3><p>规则如下：</p><p><img src="/images/pretty-pcb/image-20221112104632422.png" alt="image-20221112104632422"></p><p>创建完以后是这样的：</p><p><img src="/images/pretty-pcb/image-20221112104720008.png" alt="image-20221112104720008"></p><h3 id="转移到阻焊层"><a href="#转移到阻焊层" class="headerlink" title="转移到阻焊层"></a>转移到阻焊层</h3><p>选择铺铜，右键&gt;多边形操作&gt;Explod Selected Polygons to Free Primitives，变成这样：</p><p><img src="/images/pretty-pcb/image-20221112104908031.png" alt="image-20221112104908031"></p><p>把外面不要的红色删掉，选择板子里面的铺铜，右键&gt;查找相似对象，选择同一层，同类型，同网络（No Net）的对象：</p><p><img src="/images/pretty-pcb/image-20221112105042719.png" alt="image-20221112105042719"></p><p>选中以后，修改到阻焊层：</p><p><img src="/images/pretty-pcb/image-20221112105125419.png" alt="image-20221112105125419"></p><p>板子变成了这样：</p><p><img src="/images/pretty-pcb/image-20221112105144999.png" alt="image-20221112105144999"></p><p>到3D模式查看，发现已经成功了：</p><p><img src="/images/pretty-pcb/image-20221112105221245.png" alt="image-20221112105221245"></p><h2 id="AD输出Gerber"><a href="#AD输出Gerber" class="headerlink" title="AD输出Gerber"></a>AD输出Gerber</h2><p>既然已经用AD改板子了，那转回立创EDA再导出Gerber又会多一次风险，倒不如直接导出Gerber。</p><p>这里不再赘述，给出立创官方AD打板的指导<a href="https://www.jlc.com/portal/server_guide_10171.html">技术指导：Altium Designer输出Gerber文件步骤 (jlc.com)</a></p><h2 id="渲染AD-PCB"><a href="#渲染AD-PCB" class="headerlink" title="渲染AD PCB"></a>渲染AD PCB</h2><p>AD自带的3D浏览只是能看级别的，所以顺带学习了一下怎么渲染PCB，这里也是全程跟教程走的，直接给教程了：</p><p><a href="https://www.bilibili.com/video/BV1Aa411U7d1/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">如何快速渲染一个美观的PCB图_哔哩哔哩_bilibili</a></p><p>需要用到KeyShot软件，大概安装包1G多，网上很多破解</p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简易教程 </tag>
            
            <tag> 客制化键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链实验一</title>
      <link href="/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>实验1需要求三个数的最小公倍数，只需要选择三个数中的一个，遍历其倍数，直到这个倍数可以被另外两个数整除即为结果</p><h3 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a>结果截图</h3><p><img src="/images/BlockChainLAB1/image-20220915204514451.png" alt="image-20220915204514451"></p><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a,b,c <span class="type">int</span></span><br><span class="line">fmt.Scan(&amp;a,&amp;b,&amp;c)</span><br><span class="line"><span class="comment">//fmt.Println(a,b,c)</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a*i % b == <span class="number">0</span> &amp;&amp; a*i % c == <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a*i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ul><li>采用HASH160对pubkey加密得到fingerprint</li><li>在fingerprint左拼接版本字节，并调用HASH256加密得到checksum</li><li>将 version||fingerprint||checksum 进行Base58编码得到地址结果</li></ul><h3 id="结果截图-1"><a href="#结果截图-1" class="headerlink" title="结果截图"></a>结果截图</h3><p><img src="/images/BlockChainLAB1/image-20220915204945677.png" alt="image-20220915204945677"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;ex1-package/base58&quot;</span></span><br><span class="line"><span class="string">&quot;golang.org/x/crypto/ripemd160&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line"><span class="comment">//&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> version = <span class="type">byte</span>(<span class="number">0x6f</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// func Hex2Byte(str string) []byte &#123;</span></span><br><span class="line"><span class="comment">// slen := len(str)</span></span><br><span class="line"><span class="comment">// bHex := make([]byte, len(str)/2)</span></span><br><span class="line"><span class="comment">// ii := 0</span></span><br><span class="line"><span class="comment">// for i:=0;i&lt;len(str);i+=2 &#123;</span></span><br><span class="line"><span class="comment">// if slen != 1&#123;</span></span><br><span class="line"><span class="comment">// ss := string(str[i]) + string(str[i+1])</span></span><br><span class="line"><span class="comment">// bt, _ := strconv.ParseInt(ss, 16, 32)</span></span><br><span class="line"><span class="comment">// bHex[ii] = byte(bt)</span></span><br><span class="line"><span class="comment">// ii++</span></span><br><span class="line"><span class="comment">// slen -= 2</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// return bHex</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HASH160</span><span class="params">(x []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">hash1 := sha256.New()</span><br><span class="line">hash1.Write(x)</span><br><span class="line">hash1_res := hash1.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">hash2 := ripemd160.New()</span><br><span class="line">hash2.Write(hash1_res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash2.Sum(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HASH256</span><span class="params">(x []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">hash1 := sha256.New()</span><br><span class="line">hash1.Write(x)</span><br><span class="line">hash1_res := hash1.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">hash2 := sha256.New()</span><br><span class="line">hash2.Write(hash1_res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash2.Sum(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintHex</span><span class="params">(x []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(x);i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%02x&quot;</span>, x[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBTCAdd</span><span class="params">(pk []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;------------中间数据--------------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;pub key is:&quot;</span>)</span><br><span class="line">PrintHex(pk)</span><br><span class="line"></span><br><span class="line">fingerprint := HASH160(pk)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;fingerprint is:&quot;</span>)</span><br><span class="line">PrintHex(fingerprint)</span><br><span class="line"></span><br><span class="line">tmp1 := <span class="built_in">append</span>([]<span class="type">byte</span>&#123;version&#125;, fingerprint...)</span><br><span class="line"><span class="comment">//PrintHex(tmp1)</span></span><br><span class="line">checksum := HASH256(tmp1)[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;checksum is:&quot;</span>)</span><br><span class="line">PrintHex(checksum)</span><br><span class="line">fmt.Println(<span class="string">&quot;----------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//PrintHex(checksum)</span></span><br><span class="line">tmp2 := <span class="built_in">append</span>(tmp1, checksum...)</span><br><span class="line"></span><br><span class="line">myAlphabet := base58.NewAlphabet(<span class="string">&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> addr <span class="type">string</span> = base58.Encode(tmp2, myAlphabet)</span><br><span class="line">fmt.Println(addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> pk_str <span class="type">string</span></span><br><span class="line">fmt.Scan(&amp;pk_str) </span><br><span class="line">pk, _ := hex.DecodeString(pk_str)</span><br><span class="line"><span class="comment">//PrintHex(pk)</span></span><br><span class="line"><span class="comment">//x := Hex2Byte(x_str)</span></span><br><span class="line">makeBTCAdd(pk)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h2><h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><p>实验三的流程为：</p><ul><li>采用数组实现二叉树结构</li><li>给叶子节点赋值并计算其Hash值（采用SHA256）</li><li>反向遍历树数组，计算每一个节点的Hash值</li><li>生成另一棵树，只有一个叶子与前面的树不同</li><li>从根节点开始，递归寻找下一层中不同的叶子，直到找到不同的叶节点并输出其index</li></ul><h3 id="结果截图-2"><a href="#结果截图-2" class="headerlink" title="结果截图"></a>结果截图</h3><p><img src="/images/BlockChainLAB1/image-20220915205416249.png" alt="image-20220915205416249"></p><h3 id="实验代码-1"><a href="#实验代码-1" class="headerlink" title="实验代码"></a>实验代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeTree</span><span class="params">(L [16]<span class="type">string</span>)</span></span> [<span class="number">31</span>]<span class="type">string</span>&#123;</span><br><span class="line">MKTree := [<span class="number">31</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 生成叶子的Hash</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++ &#123;</span><br><span class="line">hash := sha256.New()</span><br><span class="line">hash.Write([]<span class="type">byte</span>(L[i]))</span><br><span class="line">MKTree[i+<span class="number">15</span>] = hex.EncodeToString(hash.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向上递推根</span></span><br><span class="line">MKTree = computeAllNodes(MKTree)</span><br><span class="line"><span class="keyword">return</span> MKTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeAllNodes</span><span class="params">(MKTree [31]<span class="type">string</span>)</span></span> [<span class="number">31</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">14</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line">lhash, _:= hex.DecodeString(MKTree[<span class="number">2</span>*i+<span class="number">1</span>])</span><br><span class="line">rhash, _ := hex.DecodeString(MKTree[<span class="number">2</span>*i+<span class="number">2</span>])</span><br><span class="line">hash := sha256.New()</span><br><span class="line">hash.Write(<span class="built_in">append</span>(lhash, rhash...))</span><br><span class="line">MKTree[i] = hex.EncodeToString(hash.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MKTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compMKTree</span><span class="params">(MKTree1 [31]<span class="type">string</span>, MKTree2 [31]<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> MKTree1 == MKTree2&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">index := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(index)</span></span><br><span class="line"><span class="keyword">if</span> index*<span class="number">2</span> + <span class="number">1</span> &gt;= <span class="number">31</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> MKTree1[index*<span class="number">2</span> + <span class="number">1</span>] != MKTree2[index*<span class="number">2</span> + <span class="number">1</span>] &#123;</span><br><span class="line">index = index*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">index = index*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">L1 := [<span class="number">16</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;p&quot;</span>&#125;</span><br><span class="line">MKTree1 := makeTree(L1)</span><br><span class="line"><span class="comment">//fmt.Println(MKTree1)</span></span><br><span class="line"></span><br><span class="line">L2 := [<span class="number">16</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;p&quot;</span>&#125;</span><br><span class="line">MKTree2 := makeTree(L2)</span><br><span class="line"><span class="comment">//fmt.Println(MKTree2)</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Diff index:&quot;</span>, compMKTree(MKTree1, MKTree2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 区块链实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链实验二</title>
      <link href="/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%9E%E9%AA%8C%E4%BA%8C/"/>
      <url>/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><h2 id="实验1-构建区块"><a href="#实验1-构建区块" class="headerlink" title="实验1 构建区块"></a>实验1 构建区块</h2><h3 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h3><p>本实验需要构建区块链的基本构成单位：区块。实验中简单区块链的区块结构为：</p><div class="table-container"><table><thead><tr><th>字段</th><th>解释</th><th>数据类型</th></tr></thead><tbody><tr><td>Time</td><td>当前时间戳，也就是区块创建的时间</td><td>int64</td></tr><tr><td>PrevHash</td><td>前一个块的哈希，即父哈希</td><td>[]byte</td></tr><tr><td>Hash</td><td>当前块的哈希</td><td>[]byte</td></tr><tr><td>Data</td><td>区块存储的实际有效信息，也就是交易</td><td>[]byte</td></tr></tbody></table></div><p>首先需要在Block结构体中加入这四个字段</p><p>然后对于一个给定Time，PrevHash，Data的一个区块，其Hash值定义为SHA256(PrevHash + Time+ Data)，计算器Hash值即可</p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/images/BlockChainLABTwo/image-20220922163153763.png" alt="image-20220922163153763"></p><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><p>block.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="type">int64</span></span><br><span class="line">Data []<span class="type">byte</span></span><br><span class="line">PrevHash []<span class="type">byte</span></span><br><span class="line">Hash []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="type">string</span>, prevHash []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line">block := &amp;Block&#123;time.Now().Unix(), []<span class="type">byte</span>(data), prevHash, []<span class="type">byte</span>&#123;&#125;&#125;</span><br><span class="line">block.SetHash()</span><br><span class="line"><span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> SetHash() &#123;</span><br><span class="line"><span class="comment">//为Block生成hash，使用sha256.Sum256(data []byte)函数</span></span><br><span class="line"></span><br><span class="line">Hash := sha256.Sum256(<span class="built_in">append</span>(<span class="built_in">append</span>(b.PrevHash, IntToHex(b.Time)...), b.Data...))</span><br><span class="line">b.Hash = Hash[:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line"></span><br><span class="line">block := NewBlock(<span class="string">&quot;Genesis Block&quot;</span>, []<span class="type">byte</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Prev. hash: %x\n&quot;</span>, block.PrevHash)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Time: %s\n&quot;</span>, time.Unix(block.Time, <span class="number">0</span>).Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;Data: %s\n&quot;</span>, block.Data)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Time using: &quot;</span>, time.Since(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验2-实现一条链"><a href="#实验2-实现一条链" class="headerlink" title="实验2 实现一条链"></a>实验2 实现一条链</h2><h3 id="实验流程-1"><a href="#实验流程-1" class="headerlink" title="实验流程"></a>实验流程</h3><p>一条区块链可以看做一组Block类组成的数组，首先需要添加数组的第一个元素，也就是创世区块（GenesisBlock），设置其Data为“Genesis Block”，PrevHash为空比特串的SHA256</p><p>然后对于每一个新插入的区块，首先查找之前最后一个区块的Hash值作为其PrevHash，然后生成这个区块添加到数组末尾即可</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="/images/BlockChainLABTwo/image-20220922163738769.png" alt="image-20220922163738769"></p><h3 id="实验代码-1"><a href="#实验代码-1" class="headerlink" title="实验代码"></a>实验代码</h3><p>blockchain.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">blocks []*Block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span></span> AddBlock(data <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">//可能用到的函数：</span></span><br><span class="line"><span class="comment">//len(array)：获取数组长度</span></span><br><span class="line"><span class="comment">//append(array,b):将元素b添加至数组array末尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到最后一个区块的Hash</span></span><br><span class="line">PrevHash := bc.blocks[<span class="built_in">len</span>(bc.blocks)<span class="number">-1</span>].Hash</span><br><span class="line"><span class="comment">// 生成节点</span></span><br><span class="line">block := NewBlock(data, PrevHash)</span><br><span class="line"><span class="comment">// 添加到链</span></span><br><span class="line">bc.blocks = <span class="built_in">append</span>(bc.blocks, block)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGenesisBlock</span><span class="params">()</span></span> *Block &#123;</span><br><span class="line"><span class="comment">//创世区块前置哈希为空，Data为&quot;Genesis Block&quot;</span></span><br><span class="line"><span class="keyword">return</span> NewBlock(<span class="string">&quot;Genesis Block&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockchain</span><span class="params">()</span></span> *Blockchain &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Blockchain&#123;[]*Block&#123;NewGenesisBlock()&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bc := NewBlockchain()</span><br><span class="line">bc.AddBlock(<span class="string">&quot;Send 1 BTC to Ivan&quot;</span>)</span><br><span class="line">bc.AddBlock(<span class="string">&quot;Send 2 more BTC to Ivan&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, block := <span class="keyword">range</span> bc.blocks &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;PrevHash: %x\n&quot;</span>, block.PrevHash)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Data: %s\n&quot;</span>, block.Data)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line">fmt.Println()  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验3-加入PoW模块"><a href="#实验3-加入PoW模块" class="headerlink" title="实验3 加入PoW模块"></a>实验3 加入PoW模块</h3><h3 id="实验流程-2"><a href="#实验流程-2" class="headerlink" title="实验流程"></a>实验流程</h3><p>首先需要设置一个难度，即暴力计算出的Hash要求前多少比特为0</p><p>然后开始构建PoW算法，实验已经给出由nonce生成sha256输入的函数，这里只需要将nonce置为0以后不断+1遍历，计算该nonce值下的hash值并判断是否满足前targetBits个比特为0。若满足条件则跳出循环，返回当前的nonce和hash值</p><p>最后在区块结构中增加Nonce值，并修改SetHash()函数调用PoW算法，将区块的Nonce和Hash值设置为PoW算法返回的结果即可</p><h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="/images/BlockChainLABTwo/image-20220922164616626.png" alt="image-20220922164616626"></p><h3 id="实验代码-2"><a href="#实验代码-2" class="headerlink" title="实验代码"></a>实验代码</h3><p>proofofWork.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;math/big&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetBits = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProofOfWork <span class="keyword">struct</span> &#123;</span><br><span class="line">block  *Block</span><br><span class="line">target *big.Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(b *Block)</span></span> *ProofOfWork &#123;</span><br><span class="line">target := big.NewInt(<span class="number">1</span>)</span><br><span class="line">target.Lsh(target, <span class="type">uint</span>(<span class="number">256</span>-targetBits))</span><br><span class="line"></span><br><span class="line">pow := &amp;ProofOfWork&#123;b, target&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span></span> prepareData(nonce <span class="type">int</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">data := bytes.Join(</span><br><span class="line">[][]<span class="type">byte</span>&#123;</span><br><span class="line">pow.block.PrevHash,</span><br><span class="line">pow.block.Data,</span><br><span class="line">IntToHex(pow.block.Time),</span><br><span class="line">IntToHex(<span class="type">int64</span>(targetBits)),</span><br><span class="line">IntToHex(<span class="type">int64</span>(nonce)),</span><br><span class="line">&#125;,</span><br><span class="line">[]<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span></span> Run() (<span class="type">int</span>, []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> hashInt big.Int</span><br><span class="line"><span class="keyword">var</span> hash [<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line">nonce := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Mining the block containing \&quot;%s\&quot;\n&quot;</span>, pow.block.Data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">here := pow.prepareData(nonce)</span><br><span class="line">hash = sha256.Sum256(here)</span><br><span class="line">hashInt.SetBytes(hash[:])</span><br><span class="line"><span class="keyword">if</span> hashInt.Cmp(pow.target) &lt; <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">nonce++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\r%x&quot;</span>, hash)</span><br><span class="line">fmt.Print(<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> nonce, hash[:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span></span> Validate() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">var</span> hashInt big.Int</span><br><span class="line">hashInt.SetBytes(pow.block.Hash)</span><br><span class="line"><span class="keyword">if</span> hashInt.Cmp(pow.target) &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="type">int64</span></span><br><span class="line">Data []<span class="type">byte</span></span><br><span class="line">PrevHash []<span class="type">byte</span></span><br><span class="line">Hash []<span class="type">byte</span></span><br><span class="line">Nonce <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="type">string</span>, prevHash []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line">block := &amp;Block&#123;time.Now().Unix(), []<span class="type">byte</span>(data), prevHash, []<span class="type">byte</span>&#123;&#125;, <span class="number">0</span>&#125;</span><br><span class="line">block.SetHash()</span><br><span class="line"><span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> SetHash() &#123;</span><br><span class="line"></span><br><span class="line">pow := NewProofOfWork(b)</span><br><span class="line">b.Nonce, b.Hash = pow.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 区块链实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APM32键盘开发板の开发记录</title>
      <link href="/2022/10/29/apm32-developer/"/>
      <url>/2022/10/29/apm32-developer/</url>
      
        <content type="html"><![CDATA[<h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><p>本开发板采用<code>apm32f103</code>系列的<code>c8t6</code>或<code>cbt6</code>主控，目的是作为一个QMK固件学习的廉价开发板，其基本情况：</p><p>开发板外观如下</p><p><img src="/images/apm32dvlp/8f71e3499f27e378391ac2a1cbdc555.jpg" alt="8f71e3499f27e378391ac2a1cbdc555"></p><h3 id="关于主控"><a href="#关于主控" class="headerlink" title="关于主控"></a>关于主控</h3><p>主控方面，有四个选择：<code>stm32/apm32 f103 c8t6/cbt6</code></p><p>apm32是stm32的国产版，软硬件都兼容，也就是说在设计电路和写固件的时候直接按stm32弄就行。</p><p>c8t6和cbt6的区别主要是flash大小，也就是最大支持的固件大小，其中c8t6为<code>64k</code>、cbt6为<code>128k</code>，目前而言两者价格差别很小，所以建议选择后者。</p><p>文章使用的是<code>apm32 f103 cbt6</code></p><h3 id="关于电路设计"><a href="#关于电路设计" class="headerlink" title="关于电路设计"></a>关于电路设计</h3><p>电路分为两个部分，左边是apm32开发板，包含1个apm32键盘最小系统、9个按键、1个旋钮、2个插线母座。</p><p>其中apm32开发板的硬件设计参考苏达酱的apm32最小系统板：</p><p>b站教程：<a href="https://www.bilibili.com/video/BV1FV4y1K7mm/?spm_id_from=333.788&amp;vd_source=a42d90bcf7fcd7bedcf7188f6b5545c7">【苏达】还在用32u4？该换apm啦！apm主控键盘教程第一期（前期准备）_哔哩哔哩_bilibili</a></p><p>立创开源工程：<a href="https://oshwhub.com/nimrodlord/apm32-jian-pan-zui-xiao-ji-tong">apm32键盘最小系统 - 嘉立创EDA开源硬件平台 (oshwhub.com)</a></p><p>在此基础上，添加了按键和旋钮，将一部分无用的引脚引出连接插线段子，便于后续功能开发。</p><p>右边的usb hub部分基本与该开源工程一致<a href="https://oshwhub.com/apana/usbhub">【已验证】USB拓展坞 USB集线器 USBHub - 嘉立创EDA开源硬件平台 (oshwhub.com)</a></p><p>该项目只用了SL2.1A芯片，支持四个USB 2.1输入，本项目只是在其基础上，去掉了一个USB输入，将其换成了一个FFP连接器，然后在开发板的Type-C输出也接入到另一个FFP连接器上，可以通过一根FFP软排线将左侧的开发板接入到右侧的HUB。</p><h3 id="关于固件"><a href="#关于固件" class="headerlink" title="关于固件"></a>关于固件</h3><p>基础固件参考了上述苏达的教程以及<a href="https://www.bilibili.com/video/BV1pt4y1a7dG/?spm_id_from=333.880.my_history.page.click">【QMK教程】从配置编译环境到实现RBG矩阵灯效 OLED屏幕动画 旋钮编码器功能 VIA改键 ARM移植的详细大教学，看完就会写QMK固件_哔哩哔哩_bilibili</a>。</p><p>基础固件与之前的博客<a href="https://blog-boulevard.top/2022/10/24/qmk-vial/">QMK编译+Vial在线改键功能 | Boulevard’s Blog (blog-boulevard.top)</a>基本类似，只是更改了主控有关。</p><h2 id="Bootloader烧录"><a href="#Bootloader烧录" class="headerlink" title="Bootloader烧录"></a>Bootloader烧录</h2><p>apm32出厂是不带dfu的，也就是说不能和Atmega32u4一样，焊接好板子以后连上USB即可使用qmk工具箱烧录。apm32和stm32都需要刷写好bootloader以后才能够用usb连接qmk工具箱烧录固件。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>烧录器：支持对Arm Cortex M3设备进行SWD接口烧录的烧录器，ST-Link、CMSIS-DAP即可。我使用的是猛龙电子的CMSIS-DAP v2。</li><li>Keil5：软件方面，使用Keil进行烧录。Keil是常用的单片机开发软件，下载和安装都非常傻瓜。</li></ol><h3 id="Bootloader准备"><a href="#Bootloader准备" class="headerlink" title="Bootloader准备"></a>Bootloader准备</h3><p>使用苏达视频中提供的BL，不过需要注意的是，keil只支持hex文件，苏达群里的是bin文件，需要进行转换。</p><h3 id="Keil配置"><a href="#Keil配置" class="headerlink" title="Keil配置"></a>Keil配置</h3><h4 id="下载Apm32设备包"><a href="#下载Apm32设备包" class="headerlink" title="下载Apm32设备包"></a>下载Apm32设备包</h4><p>在Keil官网的包下载页面<a href="https://www.keil.com/dd2/pack/#!#eula-container">MDK5 Software Packs (keil.com)</a> &gt; APEXMIC &gt; APEX Microelectronics APM32F1软件包下载即可：</p><p><img src="/images/apm32dvlp/image-20221029163444442.png" alt="image-20221029163444442"></p><h4 id="导入包到Keil"><a href="#导入包到Keil" class="headerlink" title="导入包到Keil"></a>导入包到Keil</h4><p>打开Keil，打开Pack Installer</p><p><img src="/images/apm32dvlp/1667032525749.png" alt="1667032525749"></p><p>在Pack Installer菜单中找到File&gt;Import，找到上面下载的包导入即可</p><h4 id="配置apm32烧录工程"><a href="#配置apm32烧录工程" class="headerlink" title="配置apm32烧录工程"></a>配置apm32烧录工程</h4><p>新建一个工程，将Bootloader的hex文件放置到工程文件夹中：</p><p><img src="/images/apm32dvlp/image-20221029164114604.png" alt="image-20221029164114604"></p><p>在Keil中，工程会有一个Target1：</p><p><img src="/images/apm32dvlp/image-20221029164202675.png" alt="image-20221029164202675"></p><p>右键第一个，设置：</p><p>在Device中选择到对应的芯片</p><p><img src="/images/apm32dvlp/image-20221029164235505.png" alt="image-20221029164235505"></p><p>在Output中，把Name of Executable改为BL的hex文件：</p><p><img src="/images/apm32dvlp/image-20221029164313095.png" alt="image-20221029164313095"></p><p>再Device中选择你的烧录器，我这里选择CMSIS-DAP Debugger：</p><p><img src="/images/apm32dvlp/image-20221029164424713.png" alt="image-20221029164424713"></p><p>然后在烧录器右边的Settings中继续设置烧录器：</p><p>在Debug中，选择你的CMSIS-DAP版本，这里我选择CMSIS-DAP v2；然后在Flash Download中设置如下，注意Programming Algorithm需要选择你芯片对应的，如果没有需要点Add加进来：</p><p><img src="/images/apm32dvlp/image-20221029164602341.png" alt="image-20221029164602341"></p><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>在上述的Keil工程配置完毕以后，将烧录器连接好开发板的SWD接口，点击LOAD即可：</p><p><img src="/images/apm32dvlp/image-20221029164735953.png" alt="image-20221029164735953"></p><h3 id="固件烧录"><a href="#固件烧录" class="headerlink" title="固件烧录"></a>固件烧录</h3><p>在Bootloader烧录好以后，插上开发板的type-c，在<code>设备管理器&gt;通用串行总线设备</code>中会看到一个<code>Maple 003</code>的设备，就说明上面的BL烧录没有问题了。</p><p>打开QMK Toolbox，可以看到设备已经被识别了，后续就可以和32u4一样，用QMK工具箱烧录QMK键盘固件了：</p><p><img src="/images/apm32dvlp/image-20221029165051241.png" alt="image-20221029165051241"></p><h2 id="固件开发过程"><a href="#固件开发过程" class="headerlink" title="固件开发过程"></a>固件开发过程</h2><h3 id="rev0"><a href="#rev0" class="headerlink" title="rev0"></a>rev0</h3><h4 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h4><p>rev0是一个<strong>最基础的验证MCU电路的版本，只验证了键盘功能</strong></p><p>最基础的版本参考我的博客：<a href="https://blog-boulevard.top/2022/10/24/qmk-vial/">QMK编译+Vial在线改键功能 | Boulevard’s Blog (blog-boulevard.top)</a></p><p>下面只描写apm32版本与atmega32u4版本不同的地方</p><h4 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h4><p><img src="/images/apm32dvlp/image-20221029165533531.png" alt="image-20221029165533531"></p><p>工程结构如下，对比32u4版本，只多了<code>chconf.h</code>、<code>halconf.h</code>、<code>mcuconf.h</code>三个文件，下面一一说明每个文件修改之处。</p><h4 id="keymap、键盘名-c、键盘名-h、config-h"><a href="#keymap、键盘名-c、键盘名-h、config-h" class="headerlink" title="keymap、键盘名.c、键盘名.h、config.h"></a>keymap、键盘名.c、键盘名.h、config.h</h4><p>这三个文件不变，和32u4完全一样</p><h4 id="chconf-h"><a href="#chconf-h" class="headerlink" title="chconf.h"></a>chconf.h</h4><p>照抄就行，不知道干啥的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CH_CFG_ST_TIMEDELTA 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CH_CFG_USE_CONDVARS_TIMEOUT FALSE</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;chconf.h&gt;</span><br></pre></td></tr></table></figure><h4 id="halconf-h"><a href="#halconf-h" class="headerlink" title="halconf.h"></a>halconf.h</h4><p>第一行和最后一行照抄，中间两行是启用SPI和PWM总线，普通的键盘功能可以不需要。后续可能需要修改，比如OLED需要使用I2C总线。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define HAL_USE_PWM TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define HAL_USE_SPI TRUE</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;halconf.h&gt;</span><br></pre></td></tr></table></figure><h4 id="mcuconf-h"><a href="#mcuconf-h" class="headerlink" title="mcuconf.h"></a>mcuconf.h</h4><p>暂时也只需要照抄，需要和上面规定的总线对应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;mcuconf.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #undef STM32_PWM_USE_TIM1</span></span><br><span class="line"><span class="comment">// #define STM32_PWM_USE_TIM1 TRUE</span></span><br></pre></td></tr></table></figure><h4 id="rules-mk"><a href="#rules-mk" class="headerlink" title="rules.mk"></a>rules.mk</h4><p>MCU和BL类型改为STM32对应的，下面这些设置在上次的博客已经说明了，一样。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MCU name</span></span><br><span class="line">MCU = STM32F103</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bootloader selection</span></span><br><span class="line">BOOTLOADER = stm32duino</span><br><span class="line"></span><br><span class="line">LTO_ENABLE = yes</span><br><span class="line">BOOTMAGIC_ENABLE ?= yes<span class="comment"># Virtual DIP switch configuration</span></span><br><span class="line">MOUSEKEY_ENABLE ?= no<span class="comment"># Mouse keys</span></span><br><span class="line">EXTRAKEY_ENABLE ?= yes<span class="comment"># Audio control and System control</span></span><br><span class="line">CONSOLE_ENABLE ?= no<span class="comment"># Console for debug</span></span><br><span class="line">COMMAND_ENABLE ?= no    <span class="comment"># Commands for debug and configuration</span></span><br><span class="line">SLEEP_LED_ENABLE ?= no  <span class="comment"># Breathing sleep LED during USB suspend</span></span><br><span class="line">NKRO_ENABLE ?= yes    <span class="comment"># USB Nkey Rollover</span></span><br><span class="line">BACKLIGHT_ENABLE ?= no</span><br><span class="line">RGBLIGHT_ENABLE ?= no</span><br></pre></td></tr></table></figure><h4 id="问题备注"><a href="#问题备注" class="headerlink" title="问题备注"></a>问题备注</h4><p>功能比较简单，没有其他问题，但是reset键不是很灵，不知道是啥原因。所以<strong>在固件中为键盘设置一个reset的组合键</strong>，方便进入BL模式刷机。</p><h3 id="rev0-5"><a href="#rev0-5" class="headerlink" title="rev0.5"></a>rev0.5</h3><h4 id="版本说明-1"><a href="#版本说明-1" class="headerlink" title="版本说明"></a>版本说明</h4><p>rev0.5是一个添加了旋钮的版本，旋钮还有一些问题没有提及</p><h4 id="代码内容"><a href="#代码内容" class="headerlink" title="代码内容"></a>代码内容</h4><p>这里的代码是不支持vial的，若需要vial旋钮代码，请见博客<a href="https://blog-boulevard.top/2022/10/24/qmk-vial/">QMK编译+Vial在线改键功能 | Boulevard’s Blog (blog-boulevard.top)</a>。</p><p>添加旋钮需要修改如下内容</p><ol><li>在rules.mk中开启旋钮：</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENCODER_ENABLE = yes</span><br></pre></td></tr></table></figure><ol><li>在config.h中设置旋钮：</li></ol><p>第一二行，显而易见是设置旋钮的A、B脚连接的MCU引脚。</p><p>第三行设置的是ENCODER的分辨率（灵敏度），也就是编码器在每个止动之间记录的脉冲数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Encoder Setting */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODERS_PAD_A &#123; A10 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODERS_PAD_B &#123; A8 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODER_RESOLUTION 4</span></span><br></pre></td></tr></table></figure><ol><li>在keymap.c中定义<code>encoder_update_user</code>：</li></ol><p>分别定义了顺时针，逆时针的键码。注意，如果键码是音量加减等功能，需要把<code>tap_code</code>改为<code>tap_code(KC_COLU, 10)</code>这样。同时需要在<code>rules.mk</code>里面开启<code>EXTRAKEY_ENABLE = yes</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">encoder_update_user</span><span class="params">(<span class="type">uint8_t</span> index, <span class="type">bool</span> clockwise)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (clockwise) &#123;</span><br><span class="line">        tap_code(KC_1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tap_code(KC_2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题备注-1"><a href="#问题备注-1" class="headerlink" title="问题备注"></a>问题备注</h4><p>有一个很奇怪的BUG，在我的电路设计中，我将旋钮的上面两个脚当作轴体接到了ROW0, COL3，将下面的A、B脚接到了主控的B0, B1脚。然而在排除旋钮、固件本身问题的情况以后，无论是按下还是旋转都没有反应，将旋钮上面两个脚飞线到ROW0,COL0以后就可以触发这个键。</p><p>在DEBUG很久以后，还是没有效果，于是我将另一个旋钮的A、B脚接到主控的A8、A9，C接地，其他不接。这个旋钮就可以正常工作了。</p><p>目前还未找到原因，旋钮本身是可以用的。不知道是MCU这两个脚的原因还是电路设计的原因，有空再去排除。</p><h5 id="2022·11·12更新"><a href="#2022·11·12更新" class="headerlink" title="2022·11·12更新"></a>2022·11·12更新</h5><p>除了把旋钮接到了A8A9，按下的两个脚也飞线到了轴座焊盘上面，仍然可以用</p><h3 id="rev1"><a href="#rev1" class="headerlink" title="rev1"></a>rev1</h3><h4 id="版本说明-2"><a href="#版本说明-2" class="headerlink" title="版本说明"></a>版本说明</h4><p>rev1主要是写了OLED屏幕的demo，屏幕为128*32分辨率的SSD1306驱动OLED。</p><h4 id="I2C基础"><a href="#I2C基础" class="headerlink" title="I2C基础"></a>I2C基础</h4><p>OLED屏幕需要<strong>开启I2C总线</strong>，下面简介一下I2C的一些基础知识。</p><p>使用I2C的OLED屏幕有四个脚：VCC、GND、SCL(有的叫SCK，都是SClock的意思)、SDA。</p><p>其中VCC理论上接入3.3V和5V都可以，但是为了避免烧掉，还是建议接3.3V。GND不必多说，接地。</p><p>SCL和SPA是I2C的两个脚，直接连接到MCU，但是需要注意的是这两个脚不能够随便接，需要<strong>查阅主控说明书</strong>，查看其<strong>支持I2C的脚</strong>。</p><p>一般而言，一个MCU可以有多对I2C的脚记为I2C1、I2C2…。<strong>对于APM32F103而言，我们使用其I2C1，其SCL为B6、SDA为B7</strong>。</p><h4 id="代码内容-1"><a href="#代码内容-1" class="headerlink" title="代码内容"></a>代码内容</h4><h5 id="开启I2C"><a href="#开启I2C" class="headerlink" title="开启I2C"></a>开启I2C</h5><p>需要在与芯片相关的文件中开启I2C：</p><p><code>chconf.h</code>不需要修改。</p><p><code>halconf.h</code>需要开启I2C：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;halconf.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HAL_USE_I2C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_USE_I2C TRUE</span></span><br></pre></td></tr></table></figure><p><code>mcuconf.h</code>则需要选择I2C使用I2C1这根：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;mcuconf.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STM32_I2C_USE_I2C1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STM32_I2C_USE_I2C1 TRUE</span></span><br></pre></td></tr></table></figure><h5 id="设置I2C参数，OLED参数"><a href="#设置I2C参数，OLED参数" class="headerlink" title="设置I2C参数，OLED参数"></a>设置I2C参数，OLED参数</h5><p>在<code>config.h</code>中加入如下：</p><p>第一行，开启I2CD1。对应的还有I2CD2，这是I2C的两个版本v1、v2。其选择与主控型号有关，在qmk官方文档中给出了，常用的STM32 F1X F3X系列都是I2Cv1。</p><p>后面四行，设置I2C1的时钟速率、第二个我也不知道、后面两个是I2C1的两个Pin，前面说了是B6/B7（注意别写反）</p><p>最后五行，设置OLED的亮度，超时时间，滚动时间等显示参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_DRIVER I2CD1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C1_CLOCK_SPEED 400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C1_DUTY_CYCLE FAST_DUTY_CYCLE_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C1_SCL_PIN B6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C1_SDA_PIN B7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_BRIGHTNESS 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_TIMEOUT 80000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_FADE_OUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_FADE_OUT_INTERVAL 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SCROLL_TIMEOUT 40000</span></span><br></pre></td></tr></table></figure><h5 id="内容代码"><a href="#内容代码" class="headerlink" title="内容代码"></a>内容代码</h5><p>内容代码主要在keymap.c的函数<code>oled_task_user()</code>中：</p><p>下面这个实例是官方给的显示文字的实例，内容比较简单，显示不出汉字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OLED_ENABLE</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">oled_task_user</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Host Keyboard Layer Status</span></span><br><span class="line">    oled_write_P(PSTR(<span class="string">&quot;Layer: &quot;</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (get_highest_layer(layer_state)) &#123;</span><br><span class="line">        <span class="keyword">case</span> _HOME:</span><br><span class="line">            oled_write_P(PSTR(<span class="string">&quot;HOME\n&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> _FN2:</span><br><span class="line">            oled_write_P(PSTR(<span class="string">&quot;FN\n&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Or use the write_ln shortcut over adding &#x27;\n&#x27; to the end of your string</span></span><br><span class="line">            oled_write_ln_P(PSTR(<span class="string">&quot;Undefined&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Host Keyboard LED Status</span></span><br><span class="line">    <span class="type">led_t</span> led_state = host_keyboard_led_state();</span><br><span class="line">    oled_write_P(led_state.num_lock ? PSTR(<span class="string">&quot;NUM &quot;</span>) : PSTR(<span class="string">&quot;    &quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    oled_write_P(led_state.caps_lock ? PSTR(<span class="string">&quot;CAP &quot;</span>) : PSTR(<span class="string">&quot;    &quot;</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    oled_write_P(PSTR(<span class="string">&quot;\n\nCCRzzz(- -)&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>下面这个是显示LOGO的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">oled_task_user</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> PROGMEM qmk_logo[] = &#123;</span><br><span class="line">            <span class="number">0x80</span>, <span class="number">0x81</span>, <span class="number">0x82</span>, <span class="number">0x83</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x86</span>, <span class="number">0x87</span>, <span class="number">0x88</span>, <span class="number">0x89</span>, <span class="number">0x8A</span>, <span class="number">0x8B</span>, <span class="number">0x8C</span>, <span class="number">0x8D</span>, <span class="number">0x8E</span>, <span class="number">0x8F</span>, <span class="number">0x90</span>, <span class="number">0x91</span>, <span class="number">0x92</span>, <span class="number">0x93</span>, <span class="number">0x94</span>,</span><br><span class="line">            <span class="number">0xA0</span>, <span class="number">0xA1</span>, <span class="number">0xA2</span>, <span class="number">0xA3</span>, <span class="number">0xA4</span>, <span class="number">0xA5</span>, <span class="number">0xA6</span>, <span class="number">0xA7</span>, <span class="number">0xA8</span>, <span class="number">0xA9</span>, <span class="number">0xAA</span>, <span class="number">0xAB</span>, <span class="number">0xAC</span>, <span class="number">0xAD</span>, <span class="number">0xAE</span>, <span class="number">0xAF</span>, <span class="number">0xB0</span>, <span class="number">0xB1</span>, <span class="number">0xB2</span>, <span class="number">0xB3</span>, <span class="number">0xB4</span>,</span><br><span class="line">            <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0xC2</span>, <span class="number">0xC3</span>, <span class="number">0xC4</span>, <span class="number">0xC5</span>, <span class="number">0xC6</span>, <span class="number">0xC7</span>, <span class="number">0xC8</span>, <span class="number">0xC9</span>, <span class="number">0xCA</span>, <span class="number">0xCB</span>, <span class="number">0xCC</span>, <span class="number">0xCD</span>, <span class="number">0xCE</span>, <span class="number">0xCF</span>, <span class="number">0xD0</span>, <span class="number">0xD1</span>, <span class="number">0xD2</span>, <span class="number">0xD3</span>, <span class="number">0xD4</span>, <span class="number">0x00</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    oled_write_P(qmk_logo, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们可以在keymap.c同级文件夹中定义一个.h文件，在其中定义多个render_xxx函数显示不同内容，然后在keymap.c中include这个文件并进行逻辑调用，如在默认层和FN层显示不同内容，调用不同函数等。</p><h4 id="问题备注-2"><a href="#问题备注-2" class="headerlink" title="问题备注"></a>问题备注</h4><p>播放动画时，需要把每一帧都存到Flash中，再加上可能的Vial等功能，很容易导致固件大小超出B8T6的Flash大小（64k），但是却小于CBT6的Flash（128k）。</p><p>但是我们在rules.mk定义MCU的时候，只填了<code>MCU = STM32F103</code>，并未标注MCU为什么版本，所以默认认为其是C8T6，导致固件超过64K的时候会报错。</p><p>所以需要把C8T6改为CBT6：</p><p>在qmk_firmware根目录中，有<code>builddefs</code>这个文件夹，点进去有很多mk文件，需要修改其中的两个：</p><ol><li>bootloader.mk</li></ol><p>找到这个文件的191行，把<code>x8</code>改为<code>xB</code></p><p><img src="/images/apm32dvlp/image-20221101153707975.png" alt="image-20221101153707975"></p><ol><li>mcu_selection.mk</li></ol><p>找到这个文件的第278行，同样<code>x8</code>改为<code>xB</code></p><p><img src="/images/apm32dvlp/image-20221101153800616.png" alt="image-20221101153800616"></p><p>这样的话，固件超过64k而小于128k时就还是可以编译了。当然，由于C8和CB在其他地方时没有区别的，所以不会导致编译出来的小于64k的固件用在C8T6上有问题。</p><h3 id="rev2"><a href="#rev2" class="headerlink" title="rev2"></a>rev2</h3><h4 id="版本说明-3"><a href="#版本说明-3" class="headerlink" title="版本说明"></a>版本说明</h4><p>该版本主要加入了电磁阀，下面说明其软硬件</p><h4 id="外部电路说明"><a href="#外部电路说明" class="headerlink" title="外部电路说明"></a>外部电路说明</h4><p>不借助外部供电，能够用到的最大电压是5V1A的Type-C输出，很明显电流太小不够电磁阀用的，需要用三极管放大电流，这里我采用的是官方给出的TIP120达林顿晶体管。</p><p>网上抄的一段原理，没学过模电的laymen真的看不懂了= =</p><p><img src="/images/apm32dvlp/image-20221102102713479.png" alt="image-20221102102713479"></p><p>QMK官方给的参考电路图<a href="https://cdn-shop.adafruit.com/product-files/412/solenoid_driver.pdf">solenoid_driver (adafruit.com)</a>如下：</p><p><img src="/images/apm32dvlp/image-20221102102128385.png" alt="image-20221102102128385"></p><p>这里，Solenoid Power我们直接选用Type-C的5V电压，除此之外还需要一个TIP120达林顿晶体管（有人说IRF540也可以）、一个1N4004或1N4001或MUR340的整流二极管、一个1K或2.2K的电阻。</p><p>其中TIP120的三级脚定义如下：</p><p><img src="/images/apm32dvlp/image-20221102102937082.png" alt="image-20221102102937082"></p><p>根据官方给出的电路，三个脚分别这样接：</p><p><strong>B(Base级)：</strong>接一个1K/2.2K的电阻，然后接入到主控的一个脚（这里我用A15脚），电阻最终选的是1K。</p><p><strong>C(Collector级)：</strong>接一个1N4001二极管（或上面提到的另外两个），二极管正极（没有杠的一边）接C级。二极管的负极（有杠的一边）接Type-C 5V供电。</p><p><strong>E(Emitter级)：</strong>接地。</p><p><strong>电磁阀：</strong>电磁阀的两根线分别接在1N4001二极管的两端即可。</p><p>最终，焊接好的电路如下：</p><p><img src="/images/apm32dvlp/image-20221102103601649.png" alt="image-20221102103601649"></p><h4 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h4><p><code>rules.mk</code>中开启反馈、添加反馈为电磁阀SOLENOID:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAPTIC_ENABLE = yes</span><br><span class="line">HAPTIC_DRIVER += SOLENOID</span><br></pre></td></tr></table></figure><p>在<code>config.h</code>中加上电磁阀的引脚，使能，时间设置：</p><p>最后一个参数是默认电磁阀的通电时间（单位：ms），我设置的100ms，效果不是很明显，但是不重要，后续可以设置按键自己加减电磁阀通电时间来控制效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SOLENOID_PIN A15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOLENOID_ACTIVE true</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOLENOID_DEFAULT_DWELL 100</span></span><br></pre></td></tr></table></figure><p>在keymap.c中可以添加电磁阀控制有关的键码，我主要使用了四个：</p><p><code>HPT_TOG</code>：开关电磁阀</p><p><code>HPT_FBK</code>：切换触发时机，可以有按下时触发、抬起时触发、按下抬起都触发。</p><p><code>HPT_DWLI</code>：增加通电时间以增加反馈强度</p><p><code>HPT_DWLD</code>：减少反馈强度</p><h4 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h4><p>这里暂时是没有发现BUG的。</p><p>主要的问题是TIP120这个晶体管太大了，而且只有插件型的不能SMT，导致PCB和生产会比较麻烦。</p><p>所以目前想做的是寻找同样功能的贴片三极管、但是因为模电知识不够暂时找不到。</p><h3 id="rev2-5"><a href="#rev2-5" class="headerlink" title="rev2.5"></a>rev2.5</h3><p>添加了<strong>有源</strong>蜂鸣器</p><p><strong>关于有源无源蜂鸣器区别：</strong>有源指带有震荡源，加上电压就会响；无源指没有震荡源，需要加上一个震荡信号驱动。</p><p>软件不需要变，和电磁阀的一样；硬件更简单，把蜂鸣器正级接到MCU，负极接地</p><h3 id="rev3（最终版本）"><a href="#rev3（最终版本）" class="headerlink" title="rev3（最终版本）"></a>rev3（最终版本）</h3><h4 id="版本说明-4"><a href="#版本说明-4" class="headerlink" title="版本说明"></a>版本说明</h4><p>采用了ULN2003A驱动电磁阀，相比TIP120更小</p><p>将与电磁阀共引脚的5v有源蜂鸣器换为使用AUDIO系统控制的无源压电蜂鸣器，单独使用A8引脚控制，做到了与电磁阀独立按键控制</p><h4 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h4><h5 id="电磁阀"><a href="#电磁阀" class="headerlink" title="电磁阀"></a>电磁阀</h5><p>ULN2003A是一种贴片式达林顿晶体管阵列，是在参考有电磁阀的套件（m0110、Sodd65）时发现的，其资料如下</p><p><img src="/images/apm32dvlp/v2-40761f2fc2d5e7df823236032800a417_r.jpg" alt="img"></p><p>uln2003a集成了七个达林顿阵列，可以有七组独立的输入输出。当然，如果一对输入输出带来的电流增益太小，无法驱动你的设备的话，也可以进行串联，即：一个输入信号接入到几个IN脚，负载接到对应的几个out脚。</p><p>网上的电路：</p><p><img src="/images/apm32dvlp/2018041516285477" alt="img"></p><p>按照电路，先用一对达林顿管，发现力度不是很够，电磁阀只有微弱的运动。</p><p>于是一个一个并联尝试，增加到四对达林顿管并联的时候发现效果还可以了。</p><h5 id="压电蜂鸣器"><a href="#压电蜂鸣器" class="headerlink" title="压电蜂鸣器"></a>压电蜂鸣器</h5><p>压电蜂鸣器比较简单，似乎不分正负极，一个接规定的输出引脚（推荐A8）、一个接地即可。</p><h4 id="代码攥写"><a href="#代码攥写" class="headerlink" title="代码攥写"></a>代码攥写</h4><p>电磁阀方面，只是改变了外围电路，代码还是和之前一样。</p><p>蜂鸣器方面，因为期望与电磁阀分开用按键控制，而之前选用的反馈功能是不支持的，所以在qmk官方文档中搜索buzzer关键字的时候，发现了除了反馈功能以外，音频功能（audio）也支持piezo buzzer（压电蜂鸣器）。</p><p>于是就决定使用压电蜂鸣器，并开始攥写其代码。</p><h5 id="DAC与PWM驱动"><a href="#DAC与PWM驱动" class="headerlink" title="DAC与PWM驱动"></a>DAC与PWM驱动</h5><p>压电式蜂鸣器也是一种无源蜂鸣器，需要使用模拟信号驱动，QMK官方给出的两种方式是DAC数模转换与PWM脉冲宽度调制。</p><p>具体是什么不用理解（因为我也不会），只要知道我们需要这两种方式是让单片机输出模拟信号驱动蜂鸣器的方法即可。</p><p>而qmk官方文档提到，stm32f1xx系列是不支持DAC的，所以我们可以选择的就只有PWM模式。</p><p>PWM又分为软件PWM和硬件PWM，具体差别在哪我也没看懂，用硬件PWM就行。</p><p>注意不是每一个脚都支持硬件PWM的，官方给出的是A8脚，我们也使用这个。如果一定要用其他脚的话，需要查看STM32/APM32的datasheet，寻找有TIMx_CHy表示的脚，这表示这个脚使用TIMER X、属于PWM CHANNEL Y。</p><h5 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h5><p>首先需要根据<a href="https://docs.qmk.fm/#/audio_driver?id=pwm-hardware">Audio Driver (qmk.fm)</a>开启PWM，设置TIM1,CHANNEL1（如果用的不是A8，这里需要对应修改）：</p><p><code>halconf.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//halconf.h:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_USE_PWM                 TRUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_USE_PAL                 TRUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_USE_GPT                 TRUE</span></span><br><span class="line">#include_next &lt;halconf.h&gt;</span><br></pre></td></tr></table></figure><p><code>mcuconf.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mcuconf.h:</span></span><br><span class="line">#include_next &lt;mcuconf.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STM32_PWM_USE_TIM1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STM32_PWM_USE_TIM1                  TRUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STM32_GPT_USE_TIM4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STM32_GPT_USE_TIM4                  TRUE</span></span><br></pre></td></tr></table></figure><p><code>config.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//config.h:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUDIO_PIN A8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUDIO_PWM_DRIVER PWMD1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUDIO_PWM_CHANNEL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUDIO_STATE_TIMER GPTD4</span></span><br></pre></td></tr></table></figure><p>然后到<code>rules.mk</code>开启AUDIO、设置驱动方式为pwm硬件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AUDIO_ENABLE = yes</span><br><span class="line">AUDIO_DRIVER = pwm_hardware</span><br></pre></td></tr></table></figure><p>最后，再到<code>config.h</code>加上一行<code>#define AUDIO_CLICKY</code></p><p>AUDIO_CLICKY是指按键的时候发出声音，这正是我们需要的，同时，音频还有很多其他功能，甚至可以放8bit位宽的歌曲，这里就不细说，可以参见qmk官方文档（这个真的很重要）。</p><p>添加几个关于AUDIO_CLICKY的按键：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keymap.c:</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = &#123;</span><br><span class="line"></span><br><span class="line">[_HOME] = LAYOUT(</span><br><span class="line">KC_1, KC_2, KC_3,</span><br><span class="line">KC_4, KC_5, KC_6, </span><br><span class="line">KC_7, KC_8, MO(<span class="number">1</span>)),</span><br><span class="line"></span><br><span class="line">    [_FN2] = LAYOUT(</span><br><span class="line">CLICKY_TOGGLE, HPT_TOG, QK_BOOT,</span><br><span class="line">HPT_FBK, CLICKY_UP, CLICKY_DOWN,  </span><br><span class="line">HPT_DWLI, HPT_DWLD, KC_9),</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>CLICKY_TOGGLE</code>：开关按键声音，这个和旁边的<code>HPT_TOG</code>分开了，自然也就可以独立控制属于AUDIO模块的蜂鸣器和属于Haptic Feedback模块的电磁阀了</p><p><code>CLICKY_UP</code>：按键时蜂鸣器声音频率+，也就是调整PWM波形的频率来提高音调</p><p><code>CLICKY_DOWN</code>：与上一个相反</p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简易教程 </tag>
            
            <tag> 客制化键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QMK编译+Vial在线改键功能</title>
      <link href="/2022/10/24/QMK-VIAL/"/>
      <url>/2022/10/24/QMK-VIAL/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>QMK MSYS 0.18.0</p><p>环境配置不再赘述，msys集成度较高，git clone不出问题基本上就不会出问题。</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p><a href="https://kbfirmware.com/">Keyboard Firmware Builder</a>，参考丈二、苏达等人教程，配置好PIN、MAP等，到COMPILE中下载第二项：Download.zip，即可下载源码。</p><p><strong>但是要注意的是，在线固件网站的QMK版本很老，在0.18.0版本中编译不会通过，所以我们只在需要时复制其中的一些代码过去，整体模板并不适用。</strong></p><h2 id="编写基本源码"><a href="#编写基本源码" class="headerlink" title="编写基本源码"></a>编写基本源码</h2><h3 id="QMK基本代码结构"><a href="#QMK基本代码结构" class="headerlink" title="QMK基本代码结构"></a>QMK基本代码结构</h3><p>QMK MSYS的工程默认放置于<code>C:/用户/用户名/qmk_firmware</code>/中，为了方便，记为<code>~</code></p><p><code>~/.build/</code>中存放的是编译输出的固件，<code>~/keyboards/</code>中存储的是各种键盘的源码，主要在这个目录编写代码</p><p>在<code>~/keyboards/键盘名/</code>文件夹中，是该键盘对应的源码，如果你的键盘有多版本的话，可以在文件夹下创建各个版本的文件夹<code>~/keyboards/键盘名/rev_x</code></p><p>进入到qmk工程目录以后，使用<code>qmk compile -kb 键盘名[/rev_x]</code>，即可在keyboards中自动找到并编译</p><p>在一个键盘基本的工程中，存在如下结构：</p><blockquote><p>│  键盘名.c<br>│  键盘名.h<br>│  config.h<br>│  rules.mk<br>│<br>└─keymaps<br>    ├─default<br>            keymap.c</p></blockquote><h2 id="基础文件内容编写"><a href="#基础文件内容编写" class="headerlink" title="基础文件内容编写"></a>基础文件内容编写</h2><h3 id="rules-mk"><a href="#rules-mk" class="headerlink" title="rules.mk"></a>rules.mk</h3><p>规定编译选项：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MCU name</span></span><br><span class="line">MCU = atmega32u4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bootloader selection</span></span><br><span class="line">BOOTLOADER = atmel-dfu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build Options</span></span><br><span class="line"><span class="comment">#   change yes to no to disable</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">LTO_ENABLE = yes</span><br><span class="line">BOOTMAGIC_ENABLE = yes      <span class="comment"># Enable Bootmagic Lite</span></span><br><span class="line">EXTRAKEY_ENABLE = yes       <span class="comment"># Audio control and System control</span></span><br><span class="line">NKRO_ENABLE = yes           <span class="comment"># Enable N-Key Rollover</span></span><br><span class="line"></span><br><span class="line">MOUSEKEY_ENABLE = no        <span class="comment"># Mouse keys</span></span><br><span class="line">CONSOLE_ENABLE = no         <span class="comment"># Console for debug</span></span><br><span class="line">COMMAND_ENABLE = no         <span class="comment"># Commands for debug and configuration</span></span><br><span class="line">BACKLIGHT_ENABLE = no     <span class="comment"># Enable keyboard backlight functionality</span></span><br><span class="line">RGBLIGHT_ENABLE = no      <span class="comment"># Enable keyboard RGB underglow</span></span><br><span class="line">AUDIO_ENABLE = no           <span class="comment"># Audio output</span></span><br></pre></td></tr></table></figure><p>最开始两个MCU和BL选项，本次使用的是最简单的32u4。</p><p>LTO_ENABLE：压缩固件内容，编译时间稍微长一点，编译出来的固件内容小一点，一般开启。</p><p>后面的具体每一个对应什么参见QMK官方文档。</p><h3 id="config-h"><a href="#config-h" class="headerlink" title="config.h"></a>config.h</h3><p>规定键盘基本设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config_common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USB Device descriptor parameter */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VENDOR_ID       0xFEED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRODUCT_ID      0x6060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_VER      0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MANUFACTURER    boulevard</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRODUCT         amx55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* key matrix size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_ROWS 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_COLS 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* key matrix pins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_ROW_PINS &#123; F0, F1, F4, F5, F6 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_COL_PINS &#123; C7, C6, D7, D6, D5, D4, D3, D2, D1, D0, B7, B6 &#125;</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* COL2ROW or ROW2COL */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIODE_DIRECTION ROW2COL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set 0 if debouncing isn&#x27;t needed */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBOUNCE 5</span></span><br></pre></td></tr></table></figure><p>第一二行，照抄</p><p><strong>下面的几行就可以从下载的源码复制过来</strong>，具体定义如下：</p><p>USB Device descriptor parameter：下面的五个Define是USB的ID和名字，自己设置就行</p><p>key matrix size：矩阵的行列数</p><p>key matrix pins：矩阵行、列引脚编号</p><p>DIODE_DIRECTION：二极管方向，写反了会按键没反应。有时候键盘连接显示名称但是按键没反应可以看看这个有没有反。</p><p>DEBOUNCE：消抖次数，一般设置为5就行</p><h3 id="键盘名-h"><a href="#键盘名-h" class="headerlink" title="键盘名.h"></a>键盘名.h</h3><p>定义LAYOUT：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quantum.h&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAYOUT( \</span></span><br><span class="line"><span class="meta">K000, K001, K002, K003, K004, K005, K006, K007, K008, K009, K010, K011, \</span></span><br><span class="line"><span class="meta">K100, K101, K102, K103, K104, K105, K106, K107, K108, K109, K110, K111, \</span></span><br><span class="line"><span class="meta">K200, K201, K202, K203, K204, K205, K206, K207, K208, K209,       K211, \</span></span><br><span class="line"><span class="meta">K300,       K302, K303, K304, K305, K306, K307, K308, K309, K310, K311, \</span></span><br><span class="line"><span class="meta">K400, K401, K402,       K404,       K406,       K408, K409, K410, K411  \</span></span><br><span class="line"><span class="meta">) &#123; \</span></span><br><span class="line"><span class="meta">&#123; K000,  K001,  K002,  K003,  K004,  K005,  K006,  K007,  K008,  K009,  K010,  K011 &#125;, \</span></span><br><span class="line"><span class="meta">&#123; K100,  K101,  K102,  K103,  K104,  K105,  K106,  K107,  K108,  K109,  K110,  K111 &#125;, \</span></span><br><span class="line"><span class="meta">&#123; K200,  K201,  K202,  K203,  K204,  K205,  K206,  K207,  K208,  K209,  KC_NO, K211 &#125;, \</span></span><br><span class="line"><span class="meta">&#123; K300,  KC_NO, K302,  K303,  K304,  K305,  K306,  K307,  K308,  K309,  K310,  K311 &#125;, \</span></span><br><span class="line"><span class="meta">&#123; K400,  K401,  K402,  KC_NO, K404,  KC_NO, K406,  KC_NO, K408,  K409,  K410,  K411 &#125;  \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>上面两行任然照抄，下面的<code>#define LAYOUT()</code>内容也是从下载的源码复制。</p><h3 id="键盘名-c"><a href="#键盘名-c" class="headerlink" title="键盘名.c"></a>键盘名.c</h3><p>只有一行，就是include一下上面的.h文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;amx55.h&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="keymaps文件夹"><a href="#keymaps文件夹" class="headerlink" title="keymaps文件夹"></a>keymaps文件夹</h3><p>存放的是默认按键配列，下面可以放很多个文件夹，名称是配列名。编译的时候可以通过<code>-km 配列名</code>选择编译的配列。最简单的版本只需要有一个default文件夹，文件夹下面只需要一个：<code>keymap.c</code>文件，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> QMK_KEYBOARD_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = &#123;</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>] = LAYOUT(</span><br><span class="line">KC_GRV, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_SPC, </span><br><span class="line">KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_BSLS, </span><br><span class="line">KC_CAPS, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_ENT, </span><br><span class="line">KC_LSFT, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_LSFT, KC_UP, KC_DEL, </span><br><span class="line">KC_LCTL, KC_LGUI, KC_LALT, KC_SPC, KC_SPC, MO(<span class="number">1</span>), KC_LEFT, KC_DOWN, KC_RGHT),</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>] = LAYOUT(</span><br><span class="line">KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_LBRC, KC_RBRC, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_SCLN, KC_QUOT, KC_TRNS, </span><br><span class="line">MO(<span class="number">2</span>), KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_COMM, KC_DOT, KC_SLSH, MO(<span class="number">2</span>), KC_TRNS, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">[<span class="number">2</span>] = LAYOUT(</span><br><span class="line">KC_ESC, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, RESET, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一行的#include照抄，这个数组注意不能直接复制源码，和源码有所不同。</p><p>首先写好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = LAYOUT(),</span><br><span class="line">    ...</span><br><span class="line">    [n] = LAYOUT(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认配置有几层写几个LAYOUT就行，然后去下载的源码里边把LAYOUT复制过来。</p><h2 id="编译固件"><a href="#编译固件" class="headerlink" title="编译固件"></a>编译固件</h2><p><code>qmk compile -kb 键盘名\[rev_x] -km keymap名</code></p><p>编译成功以后刷入测试即可。</p><p>注意有的时候会有一个什么backslash报错，需要在报错的文件最后加一个空行即可…</p><h2 id="Vial配置"><a href="#Vial配置" class="headerlink" title="Vial配置"></a>Vial配置</h2><h3 id="via与vial介绍"><a href="#via与vial介绍" class="headerlink" title="via与vial介绍"></a>via与vial介绍</h3><p>via是客制化常用的改键方案了，老版的via需要下载软件、导入配置好的json文件。新版可以使用网页且不用导入json，但是暂时还不知道怎么写固件…</p><p>vial有网页和软件两个方式，都不需要导入json，写好固件以后连接即可识别，且不需要保存，即改即存，功能似乎也比via完善。和不需要json的via版本一致，最大的缺点是把json需要的信息量存入到了键盘mcu的flash中，导致固件大很多，flash不是很大的mcu（比如又贵又拉的32u4）可能有点吃不消。</p><h3 id="支持vial的qmk编译环境搭建"><a href="#支持vial的qmk编译环境搭建" class="headerlink" title="支持vial的qmk编译环境搭建"></a>支持vial的qmk编译环境搭建</h3><p>在qmk msys中输入命令：</p><p><code>qmk setup -H 分支目录 -b vial vial-kb/vial-qmk</code></p><p>分支目录是你vial版本qmk工程文件放置的目录，然后会开始git clone和setup，和最开始的qmk环境搭建基本一致</p><p>然后cd到分支目录中，这个目录和qmk默认的工程目录几乎是一样的，把之前的keyboards中的键盘文件夹复制到这边，继续修改即可</p><h3 id="支持vial的固件编写"><a href="#支持vial的固件编写" class="headerlink" title="支持vial的固件编写"></a>支持vial的固件编写</h3><p>在keymap中新建一个文件夹vial，把之前default中的keymap.c复制过去，然后还需要三个文件：</p><p>config.h、rules.mk、vial.json</p><p>下面介绍三个文件的配置</p><h4 id="rules-mk-1"><a href="#rules-mk-1" class="headerlink" title="rules.mk"></a>rules.mk</h4><p>只有两行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VIA_ENABLE = yes</span><br><span class="line">VIAL_ENABLE = yes</span><br></pre></td></tr></table></figure><h4 id="vial-json"><a href="#vial-json" class="headerlink" title="vial.json"></a>vial.json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lighting&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;matrix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cols&quot;</span><span class="punctuation">:</span> <span class="number">12</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;layouts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keymap&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>lighting是灯光模式，方便在vial中设置灯光，我没有用灯，none</p><p>matrix中写入行列数</p><p>layouts中的keymap比较有趣，需要在常用的配列网站<a href="http://www.keyboard-layout-editor.com/#/">Keyboard Layout Editor</a>中，使用自己的配列，把每个键上面的字改为:<code>row,col</code>，表示这个键所在的行列：</p><p><img src="/images/QMK/image-20221024090736063.png" alt="image-20221024090736063"></p><p>然后再&lt;/&gt; Raw data中到处json，这个json的内容复制到keymap后面去就行。</p><h4 id="config-h-1"><a href="#config-h-1" class="headerlink" title="config.h"></a>config.h</h4><p>内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0-or-later */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIAL_KEYBOARD_UID &#123;0xDA, 0xDB, 0x70, 0x9F, 0xE7, 0x18, 0x63, 0x55&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIAL_UNLOCK_COMBO_ROWS &#123; 0, 2 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIAL_UNLOCK_COMBO_COLS &#123; 0, 11 &#125;</span></span><br></pre></td></tr></table></figure><p>第一行，按惯例，照抄</p><p>第二行，UID的配置，这个不能自己乱配，需要在工程目录下执行python脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python util/vial_generate_keyboard_uid.py</span><br></pre></td></tr></table></figure><p>执行完成后会显示一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VIAL_KEYBOARD_UID &#123;0xXX, 0xXX, 0xXX, 0xXX, 0xXX, 0xXX, 0xXX, 0xXX&#125;</span></span><br></pre></td></tr></table></figure><p>把生成的这个内容复制过去就行。</p><p>第三四行，定义了两个键的组合：</p><p>由于vial的权限比via高很多，可以执行一些危险操作，所以有的功能是被上锁的，执行这些功能之前，必须要按下两个固定的键解锁，这两行就是要设置这两个键。</p><p>这两行的坐标是竖着看的，上面这个代码的意思就是按下(0,0)、(2,11)两个键可以解锁vial的危险功能。</p><h3 id="支持vial的固件编译"><a href="#支持vial的固件编译" class="headerlink" title="支持vial的固件编译"></a>支持vial的固件编译</h3><p>仍然在vial分支的qmk工程目录下面执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qmk compile -kb 键盘名/[rev_x] -km vial</span><br></pre></td></tr></table></figure><p>生成以后，刷入固件，访问网站<a href="https://vial.rocks/">Vial Web</a>就可以在线改键。</p><h3 id="进阶：Vial旋钮固件自定义"><a href="#进阶：Vial旋钮固件自定义" class="headerlink" title="进阶：Vial旋钮固件自定义"></a>进阶：Vial旋钮固件自定义</h3><h4 id="开启QMK编码器映射功能"><a href="#开启QMK编码器映射功能" class="headerlink" title="开启QMK编码器映射功能"></a>开启QMK编码器映射功能</h4><p>QMK旋钮固件有两种编写方式：编码器映射（Mapping）、回调（Callback）。Vial的目前版本只支持映射方式。</p><p>首先需要在<code>rules.mk</code>中打开编码器映射：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENCODER_ENABLE = yes</span><br><span class="line">ENCODER_MAP_ENABLE = yes</span><br></pre></td></tr></table></figure><p>然后在<code>config.h</code>中配置旋钮引脚和解析度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Encoder Setting */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODERS_PAD_A &#123; A10 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODERS_PAD_B &#123; A8 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODER_RESOLUTION 4</span></span><br></pre></td></tr></table></figure><p>再到<code>keymap.c</code>中支持开启编码器映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ENCODER_MAP_ENABLE)</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> PROGMEM encoder_map[][NUM_ENCODERS][<span class="number">2</span>] = &#123;</span><br><span class="line">    [_HOME] =   &#123; ENCODER_CCW_CW(KC_1, KC_2) &#125;,</span><br><span class="line">    [_FN2] =  &#123; ENCODER_CCW_CW(KC_VOLD, KC_VOLU) &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>映射支持多层多旋钮，这里以两层（HOME、FN2）一个旋钮为例。</p><p>到这里，就通过编码器映射方式启用了旋钮，功能应该是可以正常使用的。</p><h4 id="开启Vial对于旋钮改键支持"><a href="#开启Vial对于旋钮改键支持" class="headerlink" title="开启Vial对于旋钮改键支持"></a>开启Vial对于旋钮改键支持</h4><p>到配列编辑网站加入两个按键，代表旋钮的两个方向，按键内容如下：</p><p><img src="/images/QMK/image-20221112130821772.png" alt="image-20221112130821772"></p><p>然后按照前面教程所说的，把这个网站生成的json复制到vial.json-&gt;layouts-&gt;keymap即可</p><p>再次编译刷写，进入vial就可以看到了。</p><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><h3 id="手把手视频教学"><a href="#手把手视频教学" class="headerlink" title="手把手视频教学"></a>手把手视频教学</h3><p><strong>32u4主控PCB绘制，在线固件生成：</strong>B站/zf用户：丈二先生</p><p> <a href="https://www.bilibili.com/video/BV1ch411x7J2/?spm_id_from=333.788">【零基础】客制化键盘DIY系列教程（二）Keyboard Editor 编辑自己的配列~_哔哩哔哩_bilibili</a></p><p><strong>qmk本地代码修改、编译：</strong>B站用户：HiryKun</p><p><a href="https://www.bilibili.com/video/BV1pt4y1a7dG/?spm_id_from=333.880.my_history.page.click">【QMK教程】从配置编译环境到实现RBG矩阵灯效 OLED屏幕动画 旋钮编码器功能 VIA改键 ARM移植的详细大教学，看完就会写QMK固件_哔哩哔哩_bilibili</a></p><p><strong>vial固件编写：</strong>B站用户：HiryKun</p><p><a href="https://www.bilibili.com/video/BV1ft4y1t7vx/?spm_id_from=333.999.0.0">【QMK教程】Vial的支持与配置，让你的键盘方便改键/改编码器/改灯效，无需选择JSON，比VIA更方便_哔哩哔哩_bilibili</a></p><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><strong>qmk官方文档：</strong><a href="https://docs.qmk.fm/#/">QMK Firmware</a></p><p><strong>vial官方文档：</strong><a href="https://get.vial.today/">Home - Vial</a></p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客制化键盘 </tag>
            
            <tag> DIY </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL查询剩余的部分</title>
      <link href="/2022/10/07/SQL%E6%9F%A5%E8%AF%A2%E5%89%A9%E4%BD%99%E7%9A%84%E9%83%A8%E5%88%86/"/>
      <url>/2022/10/07/SQL%E6%9F%A5%E8%AF%A2%E5%89%A9%E4%BD%99%E7%9A%84%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>写在上一篇：SQL连接之后，继续补全SQL查询的内容和demo</p><h2 id="嵌套查询（子查询）"><a href="#嵌套查询（子查询）" class="headerlink" title="嵌套查询（子查询）"></a>嵌套查询（子查询）</h2><p>也就是把一个查询块（SELECT-FROM-WHERE）嵌套到另一个查询快的WHERE或者HAVING子句中，一个最简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT Sname FROM Student WHERE Sno IN (SELECT Sno FROM SC WHERE Cno=&#x27;2&#x27;);</span><br><span class="line"></span><br><span class="line">+-------+</span><br><span class="line">| Sname |</span><br><span class="line">+-------+</span><br><span class="line">| 李勇  |</span><br><span class="line">| 刘晨  |</span><br><span class="line">+-------+</span><br><span class="line">2 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>这个命令的意思非常简单，就是先查询SC表中Cno=’2’的Sno，然后在student表中查询这些Sno对应的Sname。</p><p>注意：子查询中不能使用ORDER BY</p><h3 id="嵌套查询的求解方法"><a href="#嵌套查询的求解方法" class="headerlink" title="嵌套查询的求解方法"></a>嵌套查询的求解方法</h3><h4 id="不相关情况"><a href="#不相关情况" class="headerlink" title="不相关情况"></a>不相关情况</h4><p>对于上面这种例子中，子查询条件不依赖父查询的情况，从内到外依次执行两次查询即可</p><h4 id="相关情况"><a href="#相关情况" class="headerlink" title="相关情况"></a>相关情况</h4><p>也就是说子句的查询条件对父查询是有依赖的，具体例子如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Sno,Cno <span class="keyword">FROM</span> sc x <span class="keyword">WHERE</span> Grade <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade) <span class="keyword">FROM</span> sc y <span class="keyword">WHERE</span> y.Sno <span class="operator">=</span> x.Sno);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Cno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>这个嵌套查询得到的结果是：查找某个学生分数高于该学生<strong>自己平均分</strong>的课程，子句中用到了父查询的属性x.Sno，所以自然不能和上面一样从内到外执行。</p><p>那么就只能老老实实从外到内执行，通过遍历外层元组的方式查询。</p><h3 id="嵌套查询的种类"><a href="#嵌套查询的种类" class="headerlink" title="嵌套查询的种类"></a>嵌套查询的种类</h3><h4 id="带有IN子句的嵌套查询"><a href="#带有IN子句的嵌套查询" class="headerlink" title="带有IN子句的嵌套查询"></a>带有IN子句的嵌套查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Sno,Sname,Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span> (<span class="keyword">SELECT</span> Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;刘晨&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span> Sdept <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> CS    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> CS    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>首先IN子句内查询的是刘晨所在的系，外层查询的意思就是查找刘晨所在的系（即CS系）的学生。</p><p>这个语句照样可以用之前学到的自身连接完成查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> S1.Sno,S1.Sname,S1.Sdept <span class="keyword">FROM</span> Student S1, Student S2 <span class="keyword">WHERE</span> S1.Sdept <span class="operator">=</span> S2.Sdept <span class="keyword">AND</span> S2.Sname <span class="operator">=</span> <span class="string">&#x27;刘晨&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span> Sdept <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> CS    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> CS    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>另一个例子</strong>：查询选修课程名为”信息系统“的学生的学号和姓名</p><p>思路：学生的学号和姓名在student表中，同时学号也在sc表中，sc表中包含cno但是没有cname</p><p>所以我们先在course中查询cname=“信息系统”的cno，然后在sc中查询cno符合要求的sno，然后在student表中查找这些sno对应的sname</p><p>用两层IN实现上述逻辑就可以了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Sno,Sname <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> Cno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> Cno <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> Cname<span class="operator">=</span><span class="string">&#x27;信息系统&#x27;</span>) );</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>当然和上面一样我们也可以使用等值连接来查询，将三个表连接到一块再查询Cname就好了，当然也可以course这个表先查询后连接</p><h4 id="带比较运算符的嵌套查询"><a href="#带比较运算符的嵌套查询" class="headerlink" title="带比较运算符的嵌套查询"></a>带比较运算符的嵌套查询</h4><p>由于比较运算符是元组之间的运算，而不是元组集合间的运算，所以需要注意<strong>子查询返回的结果只有一个元组</strong>，否则会报错。</p><p>例如上面的例子1中，子查询返回的结果就只有一个元组，所以可以简单地把IN换成=</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Sno,Sname,Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept <span class="operator">=</span> (<span class="keyword">SELECT</span> Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;刘晨&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span> Sdept <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> CS    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> CS    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="带ANY-SOME-或ALL的嵌套查询"><a href="#带ANY-SOME-或ALL的嵌套查询" class="headerlink" title="带ANY(SOME)或ALL的嵌套查询"></a>带ANY(SOME)或ALL的嵌套查询</h4><p>这些谓词常常与比较运算符对比使用，表示与子查询中的任意或者所有复合要求</p><p>这些谓词可以用来代替聚类函数，如</p><p>WHERE Sage &lt; ANY(SELECT Sage FROM … WHERE …) 和</p><p>WHERE Sage &lt; (SELECT MAX(Sage) FROM … WHERE …) 就是等价的</p><p>注意有的时候千万别脑补想当然了，比如说我最开始看到&lt;ANY的时候就想到：小于任何？那不就是&lt;MIN(Sage)吗！</p><p>但是实际上这个&lt;ANY的意思是只需要存在一个或以上比它大的就可以了。所以我觉得用SOME是不是比ANY看起来更舒服呢…</p><h4 id="带有EXISTS的查询"><a href="#带有EXISTS的查询" class="headerlink" title="带有EXISTS的查询"></a>带有EXISTS的查询</h4><p>即存在$\exists$，EXISTS子句只返回True或者False：子查询的结果为空返回FALSE、否则返回TRUE。</p><p><strong>e.g.1</strong> 查选修课Cno为1的课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Sno<span class="operator">=</span>Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> Sname <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> 李勇  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>一般来说，由于EXISTS只看元组个数，所以SELECT *就可以了，当然非要SELECT+某些属性也不是不行，反正不影响判断逻辑</p><h5 id="NOT-EXISTS与关系÷运算"><a href="#NOT-EXISTS与关系÷运算" class="headerlink" title="NOT EXISTS与关系÷运算"></a>NOT EXISTS与关系÷运算</h5><p>先从一个例子入手：查询选修了全部课程的学生姓名</p><p>查询姓名先放到一边，这个表主要是在SC中查询对应Cno包含了所有course中Cno的Sno，那这不就是关系除，然后再和Student表连接投影其Sname，关系代数为：</p><script type="math/tex; mode=display">\pi_{Sname}(Student \bowtie (\pi_{Sno,Cno}(SC) \div \pi _{Cno}(Course))</script><p>最关键的就是这个关系除了，表示一个任意$\forall$的关系，但是SQL语言没有这个关系，所以我们只能用等式$(\forall x)P \equiv \urcorner (\exists x) (\urcorner P)$。</p><p>具体这个例子而言，也就是<strong>不存在</strong>一门课，使得这个学生<strong>没有选</strong>它。这个双重否定句就是结题的关键，我们可以轻松使用两个NOT EXISTS表示这句话。</p><p>翻译成SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Course <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span> Cno <span class="operator">=</span> Course.Cno) );</span><br></pre></td></tr></table></figure><p>当然对于我们的数据库demo而言，没有这么一个肝帝把课全选了，所以就返回Empty了。</p><p>当然 对于这种特殊问题，我们甚至可以使用COUNT聚集函数。只要这个学生的COUNT(Cno)&gt;=Course所有的COUNT(Cno)就可以了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> sc <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(cno) <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> Cno) <span class="keyword">FROM</span> course));</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>有关÷的第二个例子</strong></p><p>查询至少选修了学生201215122所选全部课程的学生学号</p><p>其实就是把<script type="math/tex">\pi_{Sname}(Student \bowtie (\pi_{Sno,Cno}(SC) \div \pi _{Cno}(Course))</script>除运算右边的集合换成201215122所选的Cno的集合，还是用两个NOT EXISTS解题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> sno, sname <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> cno <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> sc.sno <span class="operator">=</span> <span class="string">&#x27;201215122&#x27;</span>) c <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> sc.sno <span class="operator">=</span> student.sno <span class="keyword">AND</span> c.Cno <span class="operator">=</span> sc.Cno));</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+</span></span><br><span class="line"><span class="operator">|</span> sno       <span class="operator">|</span> sname <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>但是注意下面使用COUNT比较的方法就不能用了</p><p>不过SQL的查询表达真的是很多样化，这里再给出2种解法（其中第二种MySQL不支持，只能用Oracle）：</p><p><strong>解法1</strong>：外连接</p><p>左表：201215122选的所有课程</p><p>右表：需要判断的学生选的课程</p><p>外连接以后，对于左表中的某一门课程，如果这个学生没选，右表会出现NULL。我们只要保证这个学生NOT EXISTS连接以后的右表有NULL就好了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Sno,Sname <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> course <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> sc <span class="keyword">WHERE</span> sc.sno <span class="operator">=</span> <span class="string">&#x27;201215122&#x27;</span>) a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> course <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> sc <span class="keyword">WHERE</span> sc.sno <span class="operator">=</span> student.sno) b <span class="keyword">ON</span> a.cno <span class="operator">=</span> b.cno <span class="keyword">WHERE</span> b.cno <span class="keyword">IS</span> <span class="keyword">NULL</span> );</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>解法2</strong>：使用集合差，不过MySQL不支持这个操作，只有Oracle可以用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> Cno <span class="keyword">FROM</span> Course <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> sc <span class="keyword">WHERE</span> sc.sno <span class="operator">=</span> <span class="string">&#x27;201215122&#x27;</span> <span class="comment">--指定学生选的所有课</span></span><br><span class="line">        MINUS</span><br><span class="line">    <span class="keyword">SELECT</span> Cno <span class="keyword">FROM</span> Course <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> sc <span class="keyword">WHERE</span> sc.sno <span class="operator">=</span> student.sno  <span class="comment">--要判断的学生选的所有课   </span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><p>集合查询主要有UNION、INTERSECT、EXCEPT/MINUS三个，其中MySQL只支持UNION操作</p><h2 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h2><p>派生表也可以看作是一种嵌套查询，只是把子查询的位置放到了FROM子句中。</p><p>其有三种不同的语法</p><ol><li>派生表计算式 AS 派生表名(派生表列名)</li><li>派生表计算式 派生表名</li><li>WITH 派生表名 AS 派生表计算式 + SELECT父查询</li></ol><p>注意，如果派生表里面使用了聚集函数，那么一定要定义列名，因为聚集函数结果列本身是没有名字的。但要是没有派生函数的话，就可以直接用 派生表名.列名 表示其中的列。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库原理 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo建站图片加载问题</title>
      <link href="/2022/10/03/hexo%E5%BB%BA%E7%AB%99%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
      <url>/2022/10/03/hexo%E5%BB%BA%E7%AB%99%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="试错方法"><a href="#试错方法" class="headerlink" title="试错方法"></a>试错方法</h2><p>网上有多种多样的方法，把试过但是没有用的几种主流方法写一下：</p><ul><li>安装hexo-asset-image插件，并在config中打开功能。在md文档同目录下建立同名文件夹放置图片即可。</li><li>修改hexo-asset-image插件代码中的bug，更改package.json。</li><li>修改各种存储路径，如：<ul><li>使用Blog文件夹为根目录</li><li>直接使用图片名</li><li>使用source文件夹作为根目录</li><li>使用./同名文件夹/xxx.jpg</li></ul></li></ul><p>最后一种方法种的有几种路径在本地是有效的，但是上传到Netlify托管以后就出问题了，最终还是翻阅了官方文档找到了最暴力的方法。</p><h2 id="最终方法"><a href="#最终方法" class="headerlink" title="最终方法"></a>最终方法</h2><p>直接在source文件夹下面创建一个image文件夹，用来存放图片，然后每次写一个博客就在下面建立一个同名文件夹用来存储图片。md文档中图片的引用格式为: ![](/image/同名文件夹/xxx.jpg)</p><p><strong>特别注意是/不是\ ！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简易教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL连接</title>
      <link href="/2022/10/02/SQL%E8%BF%9E%E6%8E%A5/"/>
      <url>/2022/10/02/SQL%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL前面的基本语法都还暂时还行，连接这块的东西稍微有点多，所以整理一下。算是复习前面关系代数的连接，也是熟悉一下MySQL语法。</p><p>使用经典的S-T Schema当作例子吧，三个表如下：</p><p>S-T.Student</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span> Ssex <span class="operator">|</span> Sage <span class="operator">|</span> Sdept <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215123</span> <span class="operator">|</span> 王敏  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> MA    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215125</span> <span class="operator">|</span> 张立  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> <span class="keyword">IS</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+</span></span><br></pre></td></tr></table></figure><p>S-T.Course</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Cno <span class="operator">|</span> Grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span>    <span class="number">92</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">85</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----+-------+</span></span><br></pre></td></tr></table></figure><p>S-T.sc</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Cno <span class="operator">|</span> Grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span>    <span class="number">92</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">85</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----+-------+</span></span><br></pre></td></tr></table></figure><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>执行语句<code>SELECT * FROM Student, SC;</code></p><p>出现结果如下，也就是Student$\cdot$SC笛卡尔积。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span> Ssex <span class="operator">|</span> Sage <span class="operator">|</span> Sdept <span class="operator">|</span> Sno       <span class="operator">|</span> Cno <span class="operator">|</span> Grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215125</span> <span class="operator">|</span> 张立  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> <span class="keyword">IS</span>    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span>    <span class="number">92</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215123</span> <span class="operator">|</span> 王敏  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> MA    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span>    <span class="number">92</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span>    <span class="number">92</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span>    <span class="number">92</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215125</span> <span class="operator">|</span> 张立  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> <span class="keyword">IS</span>    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">85</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215123</span> <span class="operator">|</span> 王敏  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> MA    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">85</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">85</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">85</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215125</span> <span class="operator">|</span> 张立  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> <span class="keyword">IS</span>    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215123</span> <span class="operator">|</span> 王敏  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> MA    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215125</span> <span class="operator">|</span> 张立  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> <span class="keyword">IS</span>    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215123</span> <span class="operator">|</span> 王敏  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> MA    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215125</span> <span class="operator">|</span> 张立  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> <span class="keyword">IS</span>    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215123</span> <span class="operator">|</span> 王敏  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> MA    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+-----+-------+</span></span><br></pre></td></tr></table></figure><h2 id="等值连接与非等值连接"><a href="#等值连接与非等值连接" class="headerlink" title="等值连接与非等值连接"></a>等值连接与非等值连接</h2><h3 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h3><p>对于Sno进行等值连接<code>SELECT * FROM Student, SC WHERE Student.Sno=SC.Sno;</code></p><p>结果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span> Ssex <span class="operator">|</span> Sage <span class="operator">|</span> Sdept <span class="operator">|</span> Sno       <span class="operator">|</span> Cno <span class="operator">|</span> Grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span>    <span class="number">92</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">85</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+-----+-------+</span></span><br></pre></td></tr></table></figure><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p><code>SELECT * FROM Student NATURAL JOIN SC;</code></p><p>结果相比上面的等值连接，只是把两个Sno列合并了</p><h5 id="USING"><a href="#USING" class="headerlink" title="USING"></a>USING</h5><p>自然连接还可以用<code>USING(A1,...,An)</code>来规定需要使用的属性组。且这个时候可以省去<code>NATURAL</code>，直接使用<code>... JOIN ... USING(...)</code>来表达自然连接。</p><h3 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h3><p>也是先笛卡尔积，后过滤，就不细说了。</p><h2 id="过滤谓词"><a href="#过滤谓词" class="headerlink" title="过滤谓词"></a>过滤谓词</h2><p>连接以后，还可以在WHERE中加入其他条件，称为<strong>过滤谓词</strong>，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Student, SC <span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span> SC.Grade <span class="operator">&gt;</span> <span class="number">85</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span> Ssex <span class="operator">|</span> Sage <span class="operator">|</span> Sdept <span class="operator">|</span> Sno       <span class="operator">|</span> Cno <span class="operator">|</span> Grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+-----+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span>    <span class="number">92</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span>    <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span>    <span class="number">90</span> <span class="operator">|</span></span><br></pre></td></tr></table></figure><h2 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h2><p>特殊的连接，一定要给表取别名，要不然就分不清，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> FIRST.Cno, SECOND.Cpno <span class="keyword">FROM</span> Course <span class="keyword">FIRST</span>, Course <span class="keyword">SECOND</span> <span class="keyword">WHERE</span></span><br><span class="line">FIRST.Cpno <span class="operator">=</span> SECOND.Cno;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span> Cno <span class="operator">|</span> Cpno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>   <span class="operator">|</span> <span class="number">5</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span> <span class="number">7</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7</span>   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>   <span class="operator">|</span> <span class="number">6</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p>功能就是显示先修课的先修课（爷爷课是吧</p><h3 id="自生连接的引用"><a href="#自生连接的引用" class="headerlink" title="自生连接的引用"></a>自生连接的引用</h3><p>e.g.1 查询薪水不同的任意两位：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T1.Tname, T2.Tname</span><br><span class="line"><span class="keyword">From</span> Teacher T1, Teacher T2</span><br><span class="line"><span class="keyword">WHERE</span> T1.Salary <span class="operator">&gt;</span> T2.Salary;</span><br></pre></td></tr></table></figure><p>注意这里用&gt;而不是≠，是为了防止出现(T1,T2)、(T2,T1)这种重复结果</p><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>这一块东西就比较乱了…</p><p>外连接可以是基于<strong>ON</strong>子句的，ON中除了有等值条件以外<strong>还可以加入其他判断条件</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Student <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> (Student.Sno<span class="operator">=</span>SC.Sno);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> Sno       <span class="operator">|</span> Sname <span class="operator">|</span> Ssex <span class="operator">|</span> Sage <span class="operator">|</span> Sdept <span class="operator">|</span> Sno       <span class="operator">|</span> Cno  <span class="operator">|</span> Grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span>    <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span>    <span class="number">85</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> 李勇  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215121</span> <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span>    <span class="number">92</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> 刘晨  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> CS    <span class="operator">|</span> <span class="number">201215122</span> <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span>    <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215123</span> <span class="operator">|</span> 王敏  <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span> MA    <span class="operator">|</span> <span class="keyword">NULL</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">201215125</span> <span class="operator">|</span> 张立  <span class="operator">|</span> 男   <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span> <span class="keyword">IS</span>    <span class="operator">|</span> <span class="keyword">NULL</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+------+------+-------+-----------+------+-------+</span></span><br></pre></td></tr></table></figure><p>当然也可以用自然连接关键字：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Student <span class="keyword">NATURAL</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> SC;</span><br></pre></td></tr></table></figure><p>结果一样，只是自然连接合并了两个Sno。</p><h3 id="关于外连接ON和WHERE的区别"><a href="#关于外连接ON和WHERE的区别" class="headerlink" title="关于外连接ON和WHERE的区别"></a>关于外连接ON和WHERE的区别</h3><p><strong>使用外连接的时候</strong></p><p>WHERE可以看作是先建立连接，然后对于条件筛选；</p><p>ON则是和JOIN一起执行的：ON对于左边表中的任何一个元组x，无论右边表中存不存在一个元组y使得(x, y)满足ON条件，都至少会返回一个x元组，即：即使不应该返回任何(x, y)，也应该返回一个(x, NULL)。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>两个测试用的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> TestTable1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> size <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> TestTable2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> size <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span> AAA  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> BBB  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span> CCC  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br></pre></td></tr></table></figure><p><strong>如果用WHERE的话：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> testtable1 <span class="keyword">left</span> <span class="keyword">join</span> testtable2 <span class="keyword">on</span> (testtable1.size <span class="operator">=</span> testtable2.size) <span class="keyword">where</span> testtable2.name<span class="operator">=</span><span class="string">&#x27;AAA&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> size <span class="operator">|</span> size <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span> AAA  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+</span></span><br></pre></td></tr></table></figure><p><strong>而用ON的话：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> testtable1 <span class="keyword">left</span> <span class="keyword">join</span> testtable2 <span class="keyword">on</span> (testtable1.size <span class="operator">=</span> testtable2.size <span class="keyword">and</span> testtable2.name <span class="operator">=</span> &quot;AAA&quot;);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> size <span class="operator">|</span> size <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span> AAA  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+</span></span><br></pre></td></tr></table></figure><p><strong>但是对于INNER JOIN来说，自然是不存在一边为NULL的元组的，所以ON的结果和WHERE的结果就还是一样的，它们的区别仅限于在外连接。</strong></p><h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h2><p>没啥好说的，上面会了这个就可以看作是多次连接再连接</p><h2 id="关于SQL的连接类型："><a href="#关于SQL的连接类型：" class="headerlink" title="关于SQL的连接类型："></a>关于SQL的连接类型：</h2><p>SQL中有很多种连接</p><ul><li>INNER JOIN：内连接</li><li>LEFT/RIGHT/FULL OUTER JOIN：三种外连接</li><li>NATURAL JOIN：自然连接</li><li>CROSS JOIN：笛卡尔积</li><li>SELF JOIN：自链接</li></ul><p>同一种连接也有很多的表达方式，在使用tableA xxx join tableB时候，还可以使用using(Col1,…,Coln)来选择具体需要使用哪些公共属性来连接。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库原理 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LotLab固件编译教程</title>
      <link href="/2022/09/23/LotKB%E5%9B%BA%E4%BB%B6%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/23/LotKB%E5%9B%BA%E4%BB%B6%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>之前在Win和Linux上尝试配置了好多次LotLab蓝牙键盘的固件编译环，每次都寄了，后来发现有Docker环境…</p><p>直接docker run lotlab/nrf52-keyboard即可</p><p>把你的项目文件夹（包含config.h，keymap_common.h等）放入容器的/work/keyboard目录即可，然后进入项目文件夹输入<code>make -j</code>即可，注意可用的蓝牙文件是nrf52_keyboard_with_sd.hex</p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简易教程 </tag>
            
            <tag> 客制化键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>amx40新固件刷机教程</title>
      <link href="/2022/09/23/amx40%E6%96%B0%E5%9B%BA%E4%BB%B6%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/23/amx40%E6%96%B0%E5%9B%BA%E4%BB%B6%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>固件蓝牙发射功率增加了4dBm，减少断连可能性（但是介于使用环境不同，不保证完全不断连）</p><h2 id="更新固件教程"><a href="#更新固件教程" class="headerlink" title="更新固件教程"></a>更新固件教程</h2><h3 id="下载群文件"><a href="#下载群文件" class="headerlink" title="下载群文件"></a>下载群文件</h3><p>下载群文件中的<strong>amx40刷机文件.zip</strong>，解压，有如下两个文件：</p><p><img src="/images/amx40firmware/image-20220923152342798.png" alt="image-20220923152342798"></p><p>其中<strong>烧录工具箱-1.2.2.0.7z</strong>中是烧录固件的工具，<strong>nrf52_kbd_with_sd.hex</strong>是新固件。</p><h3 id="安装烧录工具箱"><a href="#安装烧录工具箱" class="headerlink" title="安装烧录工具箱"></a>安装烧录工具箱</h3><p>解压<strong>烧录工具箱-1.2.2.0.7z</strong>，进入解压后的文件夹是这样的：</p><p><img src="/images/amx40firmware/image-20220923152530993.png" alt="image-20220923152530993"></p><p>首先点击<strong>首次使用点我安装驱动.EXE</strong>，进入这个界面：</p><p><img src="/images/amx40firmware/image-20220923152608293.png" alt="image-20220923152608293"></p><p>点击安装，过几秒出现：</p><p><img src="/images/amx40firmware/image-20220923152633738.png" alt="image-20220923152633738"></p><p>然后关掉窗口即可。</p><h3 id="刷写固件"><a href="#刷写固件" class="headerlink" title="刷写固件"></a>刷写固件</h3><p>点击烧录工具箱中的<strong>wch_nrf_burner.exe</strong></p><p><img src="/images/amx40firmware/image-20220923152727227.png" alt="image-20220923152727227"></p><p><strong>有线</strong>连接amx40键盘，在当前设备一行的最右边点击刷新（最右边那个小圈圈），过几秒钟后，就可以在当前设备中看到这两个了（点击最右边那个倒三角形）</p><p><img src="/images/amx40firmware/image-20220923152951204.png" alt="image-20220923152951204"></p><p>然后选择其中的一个（CMSIS-DAP和Lotlab Configurator都可）</p><p>再在蓝牙固件中，选择amx40刷机文件中的<strong>nrf52_kbd_with_sd.hex</strong></p><p><img src="/images/amx40firmware/image-20220923153250363.png" alt="image-20220923153250363"></p><p>USB固件和下面的两个选项都不要管，选择好设备和蓝牙固件以后直接点击<strong>烧录</strong></p><p>然后稍微等待几十秒，下面出现这一堆英文提示，左下角显示准备就绪以后就刷好了：</p><p><img src="/images/amx40firmware/image-20220923153426919.png" alt="image-20220923153426919"></p><p>然后断开USB，重新插入即可</p><h2 id="（特别注意）关于刷机以后键位的问题"><a href="#（特别注意）关于刷机以后键位的问题" class="headerlink" title="（特别注意）关于刷机以后键位的问题"></a>（特别注意）关于刷机以后键位的问题</h2><p>刷机以后<strong>键位有可能被重置</strong>了，导致出现一些问题，比如你原来设置的蓝牙设备连接键位被改变了。</p><p>参考<strong>群文件&gt;爱丽丝40&gt;AMX40_配置网页改建服务教程.pdf</strong>改成你习惯的键位。</p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简易教程 </tag>
            
            <tag> 客制化键盘 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
