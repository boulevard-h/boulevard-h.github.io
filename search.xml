<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cursor 免费试用无线续杯教程</title>
      <link href="/2025/02/13/cursor-free-trial/"/>
      <url>/2025/02/13/cursor-free-trial/</url>
      
        <content type="html"><![CDATA[<p>思路：用临时邮箱白嫖cursor的新用户14天免费注册，然而cursor对这种行为有所防范，限制了机器码，所以需要在换邮箱之前修改机器码</p><p>用到的工具：</p><ul><li><a href="https://github.com/chengazhen/cursor-auto-free">https://github.com/chengazhen/cursor-auto-free</a> 修改机器码</li><li><a href="https://smailpro.com/">https://smailpro.com/</a> 临时邮箱</li></ul><h2 id="1-修改机器码"><a href="#1-修改机器码" class="headerlink" title="1. 修改机器码"></a>1. 修改机器码</h2><p>Windows：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">irm</span> https://aizaozao.com/accelerate.php/https://raw.githubusercontent.com/yuaotian/go<span class="literal">-cursor-help</span>/refs/heads/master/scripts/run/cursor_win_id_modifier.ps1 | <span class="built_in">iex</span></span><br></pre></td></tr></table></figure><p>Mac：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://aizaozao.com/accelerate.php/https://raw.githubusercontent.com/yuaotian/go-cursor-help/refs/heads/master/scripts/run/cursor_mac_id_modifier.sh| sudo bash</span><br></pre></td></tr></table></figure><p>运行以后，大概会出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[INFO] 成功修改文件: Cursor.app/Contents/Resources/app/out/vs/code/node/cliProcessMain.js</span><br><span class="line">[INFO] 重新签名应用...</span><br><span class="line">[INFO] 正在关闭 Cursor...</span><br><span class="line">[INFO] 创建应用备份: /Applications/Cursor.backup.20250213_121254.app</span><br><span class="line">[INFO] 安装修改版应用...</span><br><span class="line">[INFO] Cursor 主程序文件修改完成！原版备份在: /Applications/Cursor.backup.20250213_121254.app</span><br><span class="line"></span><br><span class="line">[WARN] 是否要修改MAC地址？</span><br><span class="line">0) 否 - 保持默认设置 (默认)</span><br><span class="line">1) 是 - 修改MAC地址</span><br><span class="line">请输入选择 [0-1] (默认 0): [INFO] 已跳过MAC地址修改</span><br><span class="line"></span><br><span class="line">[INFO] 文件结构:</span><br><span class="line">/Users/XXX/Library/Application Support/Cursor/User/globalStorage</span><br><span class="line">├── globalStorage</span><br><span class="line">│   ├── storage.json (已修改)</span><br><span class="line">│   └── backups</span><br><span class="line">│       └── storage.json.backup_20250213_121253</span><br><span class="line">│       └── system_id.backup_20250213_121253</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[INFO] 正在禁用 Cursor 自动更新...</span><br><span class="line">如果需要恢复自动更新，可以手动删除文件：</span><br><span class="line">/Users/XXX/Library/Application Support/Caches/cursor-updater</span><br><span class="line"></span><br><span class="line">[INFO] 成功禁用自动更新</span><br><span class="line"></span><br><span class="line">[INFO] 验证方法：</span><br><span class="line">运行命令：<span class="built_in">ls</span> -l <span class="string">&quot;/Users/XXX/Library/Application Support/Caches/cursor-updater&quot;</span></span><br><span class="line">确认文件权限显示为：r--r--r--</span><br><span class="line"></span><br><span class="line">[INFO] 完成后请重启 Cursor</span><br><span class="line">[INFO] 请重启 Cursor 以应用新的配置</span><br></pre></td></tr></table></figure><h2 id="2-注册新邮箱"><a href="#2-注册新邮箱" class="headerlink" title="2. 注册新邮箱"></a>2. 注册新邮箱</h2><p>进入 <a href="https://smailpro.com/，获得一个临时邮箱，进入">https://smailpro.com/，获得一个临时邮箱，进入</a> cursor，退出原有账号，然后用临时邮箱注册登录，临时邮箱的验证码会发送到 smailpro 网页上，注册完毕以后，就可以用这个临时邮箱继续白嫖 14 天 free trial 了</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用SiliconFlow API+Cursor+CherryStudio搭建DeepSeek AI工作流</title>
      <link href="/2025/02/12/DeepSeek-WorkFlow-SiliconFlow-Cursor-CherryStudio/"/>
      <url>/2025/02/12/DeepSeek-WorkFlow-SiliconFlow-Cursor-CherryStudio/</url>
      
        <content type="html"><![CDATA[<h2 id="1-API-的选择与获取"><a href="#1-API-的选择与获取" class="headerlink" title="1. API 的选择与获取"></a>1. API 的选择与获取</h2><p>目前使用过的 API 平台有三种：</p><ul><li>ds 官方：服务器老寄、目前已经限制了 API 账户的充值</li><li>腾讯云：暂时免费（2.25前）、但是其 API 不知为何在 Cursor 中调用报错</li><li>SiliconFlow：V3 8元/1M token，R1 16元/1M token</li></ul><p>处于可用性的考虑，目前只能选择 SiliconFlow</p><p><a href="https://cloud.siliconflow.cn/models">https://cloud.siliconflow.cn/models</a> 进入 SiliconFlow 网站，注册、实名、然后创建 API Key 即可，记得创建两个 API Key，分别给两个软件使用</p><p><img src="/images/DeepSeek-WorkFlow-SiliconFlow-Cursor-CherryStudio/image-20250212111702905.png" alt="image-20250212111702905"></p><h2 id="2-Cherry-Studio-配置"><a href="#2-Cherry-Studio-配置" class="headerlink" title="2. Cherry Studio 配置"></a>2. Cherry Studio 配置</h2><p>Cherry Studio 是一个支持多模型的 AI 助手客户端，只需要添加 API Key 即可对话</p><p>在 <a href="https://cherry-ai.com/">https://cherry-ai.com/</a> 下载和安装即可，进入软件后，在设置-模型服务中找到硅基流动（SiliconFlow）的服务添加 API Key 即可，设置默认模型以后，就可以和 deepseek 对话</p><p>如果你想先白嫖一段免费的腾讯云，Cherry Studio 也支持添加自定义的 API，选择添加，提供商名字可以取名叫”腾讯云deepseek“，提供商类型选择 OpenAI，API 地址为：<a href="https://api.lkeap.cloud.tencent.com，然后添加">https://api.lkeap.cloud.tencent.com，然后添加</a> deepseek-r1 和 deepseek-v3 模型即可</p><p><img src="/images/DeepSeek-WorkFlow-SiliconFlow-Cursor-CherryStudio/image-20250212112439082.png" alt="image-20250212112439082"></p><h2 id="3-Cursor-配置"><a href="#3-Cursor-配置" class="headerlink" title="3. Cursor 配置"></a>3. Cursor 配置</h2><p>Cursor 是基于 vscode 开发的 AI IDE，其 AI 功能比 vscode 更加强大，Cursor 的辅助功能大致分为三部分：</p><ul><li>Cursor Tab：类似 VSCode Copilot 的自动补全</li><li>Chat：在窗口右侧换出一个对话窗口，和正常的ChatGPT一致，但是可以更方便的将代码文件、报错信息等输入到Chat中</li><li>Edit：选中一部分代码，输入指令自动修改代码</li></ul><p><strong>注：</strong>Chat&amp;Edit 功能都支持使用自定义API，但是 Cursor Tab 只能使用官方提供的模型，因此<strong>使用 API 不能完全代替 Cursor 会员</strong>的所有功能，还是花钱开会员最省心（或者实在觉得20美刀一个月负担太大的话，可以折腾一下免费使用无线续杯等操作</p><p>下面进入正题，将 deepseek API 接入到 cursor chat&amp;editor 中：</p><p>在 Cursor-Model 中，首先取消勾选所有自带的模型（包括自带的 deepseek），添加两个模型：deepseek-ai/DeepSeek-R1和deepseek-ai/DeepSeek-V3</p><p><img src="/images/DeepSeek-WorkFlow-SiliconFlow-Cursor-CherryStudio/image-20250212113359216.png" alt="image-20250212113359216"></p><p>然后在下方的 OpenAI API Key 中，修改 Override OpenAI Base URL 为 <a href="https://api.siliconflow.cn/v1，然后在上方填入自己的">https://api.siliconflow.cn/v1，然后在上方填入自己的</a> API Key，如果能 Verify 通过的话就能正常使用了</p><p><img src="/images/DeepSeek-WorkFlow-SiliconFlow-Cursor-CherryStudio/image-20250212113427747.png" alt="image-20250212113427747"></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HelloWorld &amp; 建站教程</title>
      <link href="/2024/10/12/HelloWorld-and-Site-Deploy/"/>
      <url>/2024/10/12/HelloWorld-and-Site-Deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1. 简要介绍"></a>1. 简要介绍</h2><p><a href="https://hexo.nodejs.cn/">hexo</a> 是一个强大的博客框架项目，将 Markdown 文档转化为博客网站，并且拥有大量自定义主题模板可以使用。在安装了 hexo 以后，只需要在 hexo 博客目录下简单的执行一行 <code>hexo server</code> 命令即可生成网站，并且在本地的 4000 端口访问它。</p><p>因此，本教程的重点不是如何安装和使用 hexo，而是如何把你的 hexo 页面部署在网站上。</p><p>GitHub Pages 就是一个不错的部署平台，hexo 官方支持 GitHub 一键部署，可以直接将生成的网页文件推送到 GitHub Pages 对应的仓库中去。</p><p>但是 GitHub Pages 也有一些缺点：</p><ol><li>国内访问速度慢（emmm</li><li>源码和静态网站分离，也就是说，被我们 push 到 GitHub 仓库中的只有静态网站，而没有你的 hexo 目录</li></ol><p>第二个问题可以使用 GitHub Actions 解决。使用两个仓库（或者一个仓库的两个分支也可），一个存储 hexo 源码，一个存储静态网站。然后在 hexo 源码仓库中写一个 actions 脚本，当推送新内容的时候，自动运行 hexo 生成静态网站并且推送到另一个仓库。</p><p>而更好的方法是使用 Netlify，其在国内的访问速度比 GitHub Pages 快，而且非常方便：与你的 GitHub hexo 源码仓库关联以后，会自动拉取其源码，然后自动部署生成网站。</p><p><strong>唯一美中不足的是，在我使用了两年的 Netlify 后，我的账号莫名其妙被 ban 了</strong>，所以本网站目前又迁移回了 GitHub Pages。</p><h2 id="2-GitHub-Pages-配置教程"><a href="#2-GitHub-Pages-配置教程" class="headerlink" title="2. GitHub Pages 配置教程"></a>2. GitHub Pages 配置教程</h2><p>follow 这篇博客即可，实测没有问题：</p><p><a href="https://tech.yemengstar.com/hexo-tutorial-deploy-githubpages-beginner/">HEXO系列教程 | 使用GitHub部署静态博客HEXO | 小白向教程 – 夜梦星尘の折腾日记 (yemengstar.com)</a></p><p><a href="https://tech.yemengstar.com/hexo-tutorial-use-your-domain-beginner/">HEXO系列教程 | 为HEXO绑定自己的域名 | 小白向教程 – 夜梦星尘の折腾日记 (yemengstar.com)</a></p><h2 id="3-Netlify-配置教程"><a href="#3-Netlify-配置教程" class="headerlink" title="3. Netlify 配置教程"></a>3. Netlify 配置教程</h2><p>如果有幸能够注册 Netlify 账号而且不被 ban 的话，可以按照这个教程配置：</p><p><a href="https://blog.cuijiacai.com/blog-building/">个人博客搭建教程 | 爱扑bug的熊 (cuijiacai.com)</a></p><p>但是没有配置其中的CloudWare CDN加速，Netlify自带的已经够用</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zotero Setting</title>
      <link href="/2024/10/11/Zotero-Setting/"/>
      <url>/2024/10/11/Zotero-Setting/</url>
      
        <content type="html"><![CDATA[<h2 id="1-下载-zotero-amp-安装插件"><a href="#1-下载-zotero-amp-安装插件" class="headerlink" title="1. 下载 zotero &amp; 安装插件"></a>1. 下载 zotero &amp; 安装插件</h2><p>从 <a href="https://www.zotero.org/">Zotero官网</a> 下载 zotero 即可，教程下载的是 zotero7。</p><p>安装好 Zotero 以后，从 <a href="https://zotero-chinese.com/plugins/">Zotero 插件商店</a> 搜索并下载如下插件：</p><ul><li>Better Notes for Zotero</li><li>Easier Citation</li><li>Ethereal Reference</li><li>Ethereal Style</li><li>Green Frog</li><li>Jasminum</li><li>Sci-PDF</li><li>Translate for Zotero</li><li>Zotero Reading List</li></ul><p>下载插件后，在 zotero 中的 <strong><em>工具 &gt; 插件</em></strong> 中，点击右上角的 <strong><em>设置符号</em></strong> ，选择 <strong><em>Install Plugin From File…</em></strong> 安装下载好的插件。</p><h2 id="2-插件设置"><a href="#2-插件设置" class="headerlink" title="2. 插件设置"></a>2. 插件设置</h2><p>有些插件安装好之后可以直接使用，有些插件需要设置，在 <strong><em>编辑 &gt; 设置</em></strong> 中可以进行设置。</p><h3 id="2-1-翻译"><a href="#2-1-翻译" class="headerlink" title="2.1 翻译"></a>2.1 翻译</h3><p>翻译主要是要配置翻译的服务和API密钥。在翻译服务中，后面有钥匙🔑符号的代表需要密钥，要去对应的翻译官网注册账号并获取密钥，我用的是有道智云，注册送100元翻译额度，老牌的DeepL当然也不错。</p><p>如果懒得注册的话，也可以用前面几个不需要密钥的服务凑合一下。</p><p><img src="/images/Zotero-Setting/image-20241011171856198.png" alt="image-20241011171856198"></p><h3 id="2-2-绿青蛙"><a href="#2-2-绿青蛙" class="headerlink" title="2.2 绿青蛙"></a>2.2 绿青蛙</h3><p>绿青蛙可以从 <a href="https://www.easyscholar.cc/">easyScholar</a> 拉取期刊的数据如分区/等级，和翻译一样，在 easySchlar 官网注册得到密钥以后填入即可使用。</p><h3 id="2-3-笔记"><a href="#2-3-笔记" class="headerlink" title="2.3 笔记"></a>2.3 笔记</h3><p>笔记插件 Better Notes 本身不需要设置，但是之前遇到了写笔记时使用中文+数学公式就打不出字or闪退的情况，后面发现是需要在 <strong><em>设置&gt;高级&gt;语言和区域</em></strong> 中勾选 <strong><em>启用双向文本编辑工具</em></strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QMK 固件降低延迟</title>
      <link href="/2024/10/11/QMK-Low-Latency/"/>
      <url>/2024/10/11/QMK-Low-Latency/</url>
      
        <content type="html"><![CDATA[<p>平常打游戏的键盘用的是 kbdfans 的 kbd8x_mk2，一测延迟有 10ms，刚好又看到 qmk 仓库中有这把键盘的源码，于是想着修改一下参数，降低延迟。</p><p>在 config.h 中这些参数可能影响延迟：</p><ul><li>USB_POLLING_INTERVAL_MS 轮询率，默认 1 ms，所以也不是瓶颈所在</li><li>MATRIX_IO_DELAY 矩阵扫描率，默认 30 us，更加没问题了</li><li>DEBOUNCE 消抖时间，默认 5 ms，关系很大，根据轴体素质可以适当降低。我用的力驰的轴，素质比较高，测试了设置为 0 小键都不会有问题，但是空格会双击，最后调节到了 2 ms</li></ul><p>此外，还尝试了编译时加上 OPT=2 等，最后发现还是消抖最有用，可能是这把键盘使用的是垃圾 Atmega32U4，性能太差了，导致有些优化看不出来。</p><p>对于 STM32F401 等 MCU，可以参考这个开源工程做到 8K：</p><ul><li><a href="https://www.bilibili.com/video/BV1nA411d77x/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">QMK键盘延迟测试 以及1k与8khz回报率延迟对比_哔哩哔哩_bilibili</a></li><li><a href="https://github.com/luantty2/qmk_firmware/tree/qmk_master_build_2022q4/keyboards/akeypad">qmk_firmware/keyboards/akeypad at qmk_master_build_2022q4 · luantty2/qmk_firmware (github.com)</a></li><li><a href="https://github.com/luantty2/akeypad">luantty2/akeypad (github.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>家庭Mesh组网（二）—— 家庭 Mesh 配置</title>
      <link href="/2024/08/07/Home-Mesh-2/"/>
      <url>/2024/08/07/Home-Mesh-2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-家庭网络拓扑分析"><a href="#1-家庭网络拓扑分析" class="headerlink" title="1. 家庭网络拓扑分析"></a>1. 家庭网络拓扑分析</h2><p>设备介绍：</p><ul><li>GS3202：移动送的光猫，配置较差，只有1口是千兆，2-4口是百兆</li><li>RT-AC66U：老华硕路由器，暂时接在百兆口苟延残喘，只能给我的房间提供网络</li><li>E2633：据说是中兴 AX3000 巡天的运营商定制版，可以和中兴设备组网</li><li>IPTV：父母用的电视机顶盒</li></ul><p>需求主要两点：</p><ul><li>把老华硕路由换掉，并和 E2633 组网，因此需要换成中兴的路由器</li><li>IPTV 可以正常使用</li></ul><p><img src="/images/Home-Mesh-2/image-20240807002546154.png" alt="image-20240807002546154" style="zoom: 50%;" /></p><p>先介绍关于 IPTV 的内容：</p><p>如果 IPTV 和路由器都放在客厅电视柜的话，需要两根从客厅到弱电箱的网线分别连接千兆口（一般是1口）与路由器，电视口（一般是2口）与IPTV。</p><p>而之前家里装网络的电信师傅搞了一个很神奇的操作：把8芯的网线强行分成两个4芯，而4芯线的速度一般不到百兆，只能说操作非常难绷。</p><p><img src="/images/Home-Mesh-2/image-20240807003538442.png" alt="image-20240807003538442" style="zoom:50%;" /></p><p>而第一张图中移动的装法则是把 IPTV 连接到了 E2633 路由器的 LAN 口上，并且在路由器和光猫中进行了一些设置如下。</p><p>超级管理员进入光猫后台可以看到 IPTV 业务的 VLAN ID 为 512，正常而言，绑定选项中的 LAN2 是勾选的，然后直接用 IPTV 机顶盒连接到光猫的 LAN2 就行。而这里用不到把它取消绑定了。</p><p>在绑定配置中，将 VLAN 512 绑定至 LAN1，实现对连接 E2633 路由器和光猫网线的复用。</p><p><img src="/images/Home-Mesh-2/image-20240807005057259.png" alt="image-20240807005057259" style="zoom:50%;" /></p><p><img src="/images/Home-Mesh-2/image-20240807005332174.png" alt="image-20240807005332174"></p><p>然后，在路由器中设置IPTV透传，这样就可以让 IPTV 机顶盒连接路由器 LAN1 来看电视。</p><p><img src="/images/Home-Mesh-2/image-20240807090923306.png" alt="image-20240807090923306"></p><p>然而，设置完成后打开 IPTV 却没有网络。</p><p>经过排查，是路由器上网方式设置的问题导致的。光猫中，Internet 服务的模式是路由模式，并且带有 DHCP Server；而 IPTV 服务的模式是桥接模式，且不带有 DHCP Server。路由器设置的上网模式是桥接，对于 Internet 服务而言，光猫是路由模式，所以路由器是桥接模式不影响上网；而对于 IPTV 服务而言，光猫和路由都是桥接模式的话，自然就上不了网了，光猫和路由都不会分配 IP 地址和路由。</p><p>因此，这里把路由器的上网模式从桥接改为 DHCP 就可以了。</p><p><img src="/images/Home-Mesh-2/image-20240807010031313.png" alt="image-20240807010031313" style="zoom:50%;" /></p><h2 id="2-方案选择"><a href="#2-方案选择" class="headerlink" title="2. 方案选择"></a>2. 方案选择</h2><p>由于客厅和卧室到弱电箱的网线都只有一根，所以最简单的方案是：AX3000晴天是一种<strong>壁挂式</strong>路由，作为主路由挂在弱电箱旁边，然后直接可以连接客厅和卧室的子路由。</p><p>然而，经过多方咨询，了解到这种情况下 <strong>IPTV 只能接到主路由的 LAN 口</strong>，没有办法接到子路由的 LAN 口。因为如果 IPTV 要使用的话，主路由和子路由都要配置 IPTV 透传，那样主路由的 LAN1 口既要做 MESH，又要做 IPTV 透传，所以<strong>不可用！</strong></p><p><img src="/images/Home-Mesh-2/image-20240807091416567.png" alt="image-20240807091416567" style="zoom:50%;" /></p><p>而突发奇想的第二种方法是用旧华硕路由器关闭 WiFi 功能，或者是用软路由等，然后让两个中兴的路由器连接到上面做 AP Mesh。但是，同样也无法使用 IPTV。</p><p><img src="/images/Home-Mesh-2/image-20240807091804810.png" alt="image-20240807091804810" style="zoom:50%;" /></p><p>所以为了这个 IPTV，就只能使用最复杂的 VLAN 方案了，使用两个水星 GS105 pro 网管交换机。1口作为 trunk，复用传输数据；2 口划入 VLAN2，负责光猫和主路由 WAN 口连接；3 口划入 VLAN3，负责主路由 LAN 口和副路由 WAN 口连接；4 口划入 VLAN4，负责光猫 IPTV 口和 IPTV 机顶盒连接。</p><p>注意这里我把 AX3000 巡天和 E2633 调换了位置，是因为标准版比定制版更适合作为主路由。</p><p><img src="/images/Home-Mesh-2/image-20240807092605776.png" alt="image-20240807092605776"></p><h2 id="3-Mesh-配置"><a href="#3-Mesh-配置" class="headerlink" title="3. Mesh 配置"></a>3. Mesh 配置</h2><p>首先，在弱电箱旁边不使用交换机直接按照：光猫 - 主路由 - 子路由的顺序测试组网，这个过程非常简单，把主路由接上网线通电以后，连接默认的 WiFi 进入设置网站设置 WiFi 名和密码等即可。</p><p>然后在主路由的设置网页中关闭“自组网V2”选项，将子路由恢复默认设置（用牙签戳reset五秒以上，如果是全新的就不需要恢复了），然后把子路由的 WAN 接到主路由的 LAN，可以看到子路由闪灯，过一段时间等子路由灯绿了就是自动配置好 mesh 了，上到路由管理后台可以看到组网情况：</p><p><img src="/images/Home-Mesh-2/image-20240808103924014.png" alt="image-20240808103924014" style="zoom: 80%;" /></p><p>此时，说明两个路由器的组网功能是正常的，然后就把两个路由器分别放到客厅和卧室，然后配置 VLAN 交换机来单线复用。</p><p>在拓扑中可以看到，两个交换机的端口对应是对称的，所以两个交换机的设置是一模一样的。</p><p>首先，把交换机用网线接入到电脑上，交换机的默认配置地址是 192.168.0.1，所以将电脑有线网卡的 IP 设置为 192.168.0.x 网段，这里我设置为了 192.168.0.3：</p><p><img src="/images/Home-Mesh-2/image-20240808100011860.png" alt="image-20240808100011860" style="zoom: 80%;" /></p><p>然后，就可以在浏览器访问 192.168.0.1 来进入交换机的配置网页，然后输入交换机背面的默认账号密码登录。</p><p>首先进入到 “VLAN - 801.2Q VLAN”，开启 “802.1Q VLAN使能” 并应用，然后配置各个端口的 VLAN。</p><p>需要注意的是 trunk 端口（也就是复用多个 VLAN 的端口，这里是 1 号口）需要设置为 tagged，而只走一个 VLAN 的端口设置为 untagged，总体 VLAN 设置如下：</p><p><img src="/images/Home-Mesh-2/image-20240808102554708.png" alt="image-20240808102554708" style="zoom: 80%;" /></p><p>然后在 “VLAN - 802.1Q PVID设置” 中把三个 untagged 端口的 PVID 设置为对应的：</p><p><img src="/images/Home-Mesh-2/image-20240808103118558.png" alt="image-20240808103118558"></p><p>两台 VLAN 交换机保存退出以后，按照拓扑定义的方式接线，等待几十秒以后主路由和子路由都亮绿灯，组网成功。但是使用 VLAN4 的 IPTV 却没有正常工作，下面介绍 IPTV 的进一步配置方法。</p><h2 id="4-IPTV-配置"><a href="#4-IPTV-配置" class="headerlink" title="4. IPTV 配置"></a>4. IPTV 配置</h2><p>IPTV 通过 VLAN4 在光猫的 2 号口和机顶盒之间传输数据，但是机顶盒并不能联网。</p><p>在机顶盒上面检测，机顶盒到光猫的内网是通的，但是不能到外网。</p><p>在 1. 中通过路由器透传配置 IPTV 的情况中，需要把路由器上网设置从桥接改为 DHCP 才能让 IPTV 机顶盒上网，这是因为光猫中 IPTV 设置的模式是桥接模式，需要内网的路由器进行路由和 IP 地址分配。在使用 VLAN 交换机复用的配置中也是类似的，光猫无法直接路由 IPTV 的数据，但是这里的 IPTV 机顶盒又没有接入到路由器 LAN 口，那么要怎么给其配置呢？答案是先配置交换机，把交换机加入到主路由的网络中，而 IPTV 机顶盒又连接在交换机上面，可以通过这个方式继续让路由器给 IPTV 路由。</p><p>在交换机的 “系统管理 - IP设置” 中设置IP 和网络，由于主路由的 IP 是 192.168.5.1，所以把弱电箱交换机的 IP 设置为 192.168.5.252，客厅交换机的 IP 设置为 192.168.5.253，两者的默认网关都设置为主路由 192.168.5.1。</p><p>而且这样一来，两个交换机加入了主路由的网络，无需用网线连接到交换机上面才能设置，而是直接连上 WiFi，访问上面的两个 IP 地址就能设置交换机。</p><p>此外，在两个交换机的 “二层交换 - IGMP 侦听” 中，都把 IGMP 侦听关掉（IPTV 是基于 IGMP 组播实现的，至于为什么关闭侦听我也不是很清楚…）。</p><p>然后重新尝试 IPTV 就可以正常使用了。</p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>家庭Mesh组网（一）—— Mesh 介绍</title>
      <link href="/2024/08/06/Home-Mesh-1/"/>
      <url>/2024/08/06/Home-Mesh-1/</url>
      
        <content type="html"><![CDATA[<p>家里的老华硕 <a href="https://www.asus.com.cn/networking-iot-servers/wifi-routers/asus-wifi-routers/rt-ac66u-b1/">RT-AC66U</a> 在辛苦工作了五年后终于开始出问题了，WiFi 信号一天消失不见好几次，刚好电信的百兆宽带也要到期了，准备换成移动手机送的千兆。于是打算顺便把家里的路由器一换，组成现在流行的多路由器 Mesh 组网方案。</p><h2 id="1-什么是-Mesh？为什么要用-Mesh？"><a href="#1-什么是-Mesh？为什么要用-Mesh？" class="headerlink" title="1. 什么是 Mesh？为什么要用 Mesh？"></a>1. 什么是 Mesh？为什么要用 Mesh？</h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/343117525">2024年新版 路由器Mesh组网全攻略（网络拓扑方案、装修网线预埋方案） - 知乎 (zhihu.com)</a></p><p>在家庭无线网络中，由于水泥墙等阻隔，一个路由器产生的 WiFi 信号很难覆盖全家，在一些死角处信号会很差。一个常见的误区是：购买价格昂贵的高端路由器来获得超强的穿墙能力，从而覆盖全家。因为相关标准对无线发射功率做了限制，最好的路由器也无法发出足够穿墙的信号，除非是类似华硕改地区为澳大利亚（澳洲对无线发射功率的限制较为宽松）等骚操作来进行。</p><p>与其花大几百乃至上千买一个不一定有用的高端路由器，不如多买两个普通路由器，放在不同的房间里面来覆盖信号死角。</p><p>而单纯放置多个路由器的坏处就是在一个家中有好几个不同的 WiFi，走到不同的地方要切换到信号好的一个。而 Mesh 组网可以让多个路由器共享一个 WiFi 名称（SSID），在用户的感知上，全屋只有一个 WiFi。</p><p>Mesh 分为有线 Mesh 和无线 Mesh 两种方式，有线 Mesh 的路由器之间采用有线进行连接，而无线 Mesh 的路由器之间使用无线信号传输通信。很明显，有线 Mesh 更加稳定高效，但布局也比无线困难。下面介绍有线 Mesh 的几种常见拓扑：</p><h2 id="2-传统有线-Mesh"><a href="#2-传统有线-Mesh" class="headerlink" title="2. 传统有线 Mesh"></a>2. 传统有线 Mesh</h2><p><img src="/images/Home-Mesh-1/image-20240806234856308.png" alt="image-20240806234856308"></p><p>在最传统的 Mesh 拓扑结构中，主路由的 WAN 口连接光猫，而其他子路由的 WAN 口连接主路由的 LAN 口。</p><p><strong>注：</strong>WAN 口是路由器网线入口，LAN 口是路由器网线出口。</p><p>在传统的家庭网线布局中，光猫往往位于<strong>弱电箱</strong>，也就是一个墙内的铁皮小箱子。箱子中有多条网线连接至不同房间的网口。因此，<strong>主路由</strong>往往需要<strong>也放置在弱电箱</strong>中，导致主路由的<strong>信号被弱电箱削减</strong>很多，也<strong>不容易散热</strong>，且很多弱电箱<strong>放不下</strong>较好的主路由。</p><p>另一种方式是把主路由放在弱电箱之外，在弱电箱中再放一个<strong>交换机</strong>，把主路由的 LAN 口和子路由的 WAN 口连接到交换机上。</p><p>交换机是很便宜的，做起来不难。这样做最大的难点是<strong>主路由需要有两根网线连接到弱电箱</strong>，一根负责连接光猫与 WAN 口，一根负责连接 LAN 口与交换机。而大多数家庭装修的时候，都只给一个房间配备了一根网线。</p><p><img src="/images/Home-Mesh-1/v2-f29c72cec154b87a4af078255ea82333_r.jpg" alt="img"></p><p>但是这种在弱电箱中放置交换机，而把主路由放在外面的思路是好的，只不过需要一对 <strong>VLAN 交换机</strong>来进行<strong>单线复用</strong>。VLAN 虚拟局域网可以通过标签（tag）把一个物理 LAN <strong>隔离</strong>为多个虚拟 LAN。</p><p>位于弱电箱的 VLAN 交换机和主路由器旁的 VLAN 交换机只需要一根网线连接，但是却能够划分出两个 VLAN 来，图中的 VLAN2 用于连接光猫和主路由 WAN 口，VLAN3 用于连接主路由的 LAN 口和子路由的 WAN 口。</p><p><img src="/images/Home-Mesh-1/v2-02d1ba50ba96059fe345de8790661f25_r.jpg" alt="img"></p><h2 id="3-AP-Mesh"><a href="#3-AP-Mesh" class="headerlink" title="3. AP Mesh"></a>3. AP Mesh</h2><p>上述三种方法，要么浪费一个主路由，要么需要两个网线，要么需要复杂的 VLAN，来进行路由之间的串联，那么如果把路由之间并联，也就是每一个路由器都直接连接到光猫，能不能行得通呢？</p><p>答案是可以的，现在很多新路由器支持 AP Mesh 方式，来避免复杂的布线。</p><p>但是这样，又有一个缺点：路由器之间的 Mesh 数据交换都来到了光猫上，运营商送的小光猫很可能受不住负载，导致网络出问题。一些万兆光猫如中兴 g7615 系列可以胜任 AP Mesh 的数据交换，但是换光猫又是一项成本和复杂度很高的任务。</p><p><img src="/images/Home-Mesh-1/v2-18116bfe8d841f4dd76702b5bb04553b_r.jpg" alt="img"></p><p>另一个方式是在光猫后面接一个软路由来分担光猫<strong>拨号上网</strong>的任务，但是这玩意好像又是一个新的大坑了…</p><p><img src="/images/Home-Mesh-1/v2-b8618e750faf6b8d3482274e22cd9d44_720w.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 电源键功能修改</title>
      <link href="/2024/07/05/Linux-Power-Bottom-Change/"/>
      <url>/2024/07/05/Linux-Power-Bottom-Change/</url>
      
        <content type="html"><![CDATA[<p>最近有远程办公的需求，而**的 ToDesk 在换了 6.8 Kernel 的 Ubuntu 上老崩溃，所以买了一个米家只能开关，在手机上操控开关。</p><p>正常来说强制关机需要长按四五秒的样子，但是这个沟槽的开关只能短按，而不能长按。Ubuntu 20.04 LTS 的短按电源键是弹出一个询问窗口，等待 60s 以后才关机，非常的折磨。所以文本例举和尝试了网上的集中修改按下电源键反应的方法，最终找到了一种由于的方法。</p><ol><li><p>修改 systemd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">DefaultTimeoutStopSec=90s</span></span><br><span class="line">改为</span><br><span class="line">DefaultTimeoutStopSec=5s</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><ul><li>经过测试，无效</li></ul></li><li><p>修改 gnome settings 的 button-power</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.settings-daemon.plugins.power button-power &#x27;shutdown&#x27;</span><br><span class="line">或者还有人说</span><br><span class="line">gsettings set org.gnome.settings-daemon.plugins.power power-button-action &#x27;shutdown&#x27;</span><br></pre></td></tr></table></figure><ul><li>尝试了两种方法都没有用，而且我的版本的 gnome 中 power-button-action 根本没有 ‘shutdown’ 这个值</li></ul></li><li><p>修改 systemd-logind</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/logind.conf</span><br><span class="line"></span><br><span class="line">修改如下三行</span><br><span class="line">PowerKeyIgnoreInhibited=no</span><br><span class="line">HandlePowerKey=poweroff</span><br><span class="line">PowerKeyAction=poweroff</span><br><span class="line"></span><br><span class="line">sudo systemctl restart systemd-logind</span><br></pre></td></tr></table></figure><ul><li>无效，而且 restart systemd-logind 会重启电脑，吓我一跳</li></ul></li><li><p>修改 ACPI</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/acpi/events/powerbtn</span><br><span class="line"></span><br><span class="line">添加</span><br><span class="line">event=button/power</span><br><span class="line">action=/sbin/shutdown -h now</span><br><span class="line"></span><br><span class="line">sudo systemctl restart acpid</span><br></pre></td></tr></table></figure><ul><li>测试有效，短按电源键直接关机</li><li>如果你想重启的话，可以把 <code>action=/sbin/shutdown -h now</code> 改为 <code>action=/sbin/reboot</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux Network 2: 以太网驱动收包</title>
      <link href="/2024/07/01/Linux-Network-2-Ethernet-Driver-RX/"/>
      <url>/2024/07/01/Linux-Network-2-Ethernet-Driver-RX/</url>
      
        <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/wangquan1992/article/details/112129162">linux网络报文接收发送浅析_netif tx netif rx-CSDN博客</a></p><p><a href="https://blog.51cto.com/yaoyang/1269713">链路层和网络层的接口 （linux网络子系统学习 第五节 ） _51CTO博客_linux链路层编程</a></p><h2 id="1-以太网驱动收包处理流程"><a href="#1-以太网驱动收包处理流程" class="headerlink" title="1. 以太网驱动收包处理流程"></a>1. 以太网驱动收包处理流程</h2><p>以 ne2k_pci 驱动为例，介绍 linux 中以太网设备驱动是怎么从设备读取数据、构造 skb、并上传到上层的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((pkt_stat &amp; <span class="number">0x0F</span>) == ENRSR_RXOK) &#123;</span><br><span class="line">    <span class="keyword">struct</span> sk_buff *skb;</span><br><span class="line"></span><br><span class="line">    skb = netdev_alloc_skb(dev, pkt_len + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (skb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        netif_err(ei_local, rx_err, dev,</span><br><span class="line">                  <span class="string">&quot;Couldn&#x27;t allocate a sk_buff of size %d\n&quot;</span>,</span><br><span class="line">                  pkt_len);</span><br><span class="line">        dev-&gt;stats.rx_dropped++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        skb_reserve(skb, <span class="number">2</span>);    <span class="comment">/* IP headers on 16 byte boundaries */</span></span><br><span class="line">        skb_put(skb, pkt_len);  <span class="comment">/* Make room */</span></span><br><span class="line">        ei_block_input(dev, pkt_len, skb, current_offset + <span class="keyword">sizeof</span>(rx_frame));</span><br><span class="line">        skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">        <span class="keyword">if</span> (!skb_defer_rx_timestamp(skb))</span><br><span class="line">            netif_rx(skb);</span><br><span class="line">        dev-&gt;stats.rx_packets++;</span><br><span class="line">        dev-&gt;stats.rx_bytes += pkt_len;</span><br><span class="line">        <span class="keyword">if</span> (pkt_stat &amp; ENRSR_PHY)</span><br><span class="line">            dev-&gt;stats.multicast++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-分配-skb-和预留空间"><a href="#1-1-分配-skb-和预留空间" class="headerlink" title="1.1 分配 skb 和预留空间"></a>1.1 分配 skb 和预留空间</h3><p>如果要从设备接收 <code>pkt_len</code> 大小的数据，首先会从设备中分配 <code>pkt_len + 2</code> 大小的内存。</p><p>然后 <code>skb_reverse(skb, 2)</code>，这个函数很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">skb_reserve</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">         skb-&gt;data += len;  </span><br><span class="line">         skb-&gt;tail += len;  </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>也就是把 data 和 tail 都向后移动 2 位。</p><p>而 <code>skb_put(skb, pkt_len)</code> 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_put</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">         <span class="type">unsigned</span> <span class="type">char</span> *tmp = skb-&gt;tail;  </span><br><span class="line">         SKB_LINEAR_ASSERT(skb);            </span><br><span class="line">         skb-&gt;tail += len;                 <span class="comment">// 移动指针  </span></span><br><span class="line">         skb-&gt;len  += len;                 <span class="comment">// 数据空间增大len  </span></span><br><span class="line">         <span class="keyword">if</span> (unlikely(skb-&gt;tail&gt;skb-&gt;end)) <span class="comment">// 空间不够</span></span><br><span class="line">                 skb_over_panic(skb, len, current_text_addr());  </span><br><span class="line">         <span class="keyword">return</span> tmp;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>则是把 tail 向后移动 <code>pkt_len</code> 位，让线性数据的真实长度变为 <code>pkt_len</code>。</p><h3 id="1-2-读取数据"><a href="#1-2-读取数据" class="headerlink" title="1.2 读取数据"></a>1.2 读取数据</h3><p><code>ei_block_input(dev, pkt_len, skb, current_offset + sizeof(rx_frame));</code> 则是令 buf = skb-&gt;data，然后从硬件中 copy <code>pkt_len</code> 长度的数据到 buf 中。</p><h3 id="1-3-eth-type-trans"><a href="#1-3-eth-type-trans" class="headerlink" title="1.3 eth_type_trans"></a>1.3 eth_type_trans</h3><p>阅读有关源码，这个函数做了两件事情：</p><ul><li>将 mac_header 指向当前的 data 位置</li><li><code>skb_pull(ETH_HLEN)</code> 将 data 向后移动以太网帧头部长度，可以理解为丢弃了以太网帧头部</li><li>从 mac_header 读取网络层协议类型字段，并返回</li></ul><p>这个函数运行完成以后，skb 的以太网头部被丢弃了，并将返回的网络层协议类型赋值给了 protocol。</p><h3 id="1-4-上传-skb"><a href="#1-4-上传-skb" class="headerlink" title="1.4 上传 skb"></a>1.4 上传 skb</h3><p>调用 <code>netif_rx(skb);</code> 最终会调用到 <code>netif_receive_skb</code>，后者通过检查 skb-&gt;protocol 通过 ptype_base hash 表来上传给对应的上层协议栈处理。</p><h2 id="2-题外话"><a href="#2-题外话" class="headerlink" title="2. 题外话"></a>2. 题外话</h2><p>在第一章中说到，skb 除了线性部分，还有非线性部分，而从以太网驱动的处理流程中来看，数据全部都被放到了线性部分中。</p><p>而以太网头部在驱动就被处理掉了，传递给上层的包就只剩下 IP 往上层的包了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux Network 1: SKB</title>
      <link href="/2024/07/01/Linux-Network-1-SKB/"/>
      <url>/2024/07/01/Linux-Network-1-SKB/</url>
      
        <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/tzh36/p/5424564.html">Linux内核：sk_buff解析 - 唐稚骅 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.jianshu.com/p/3c5d5fa339fc">skb结构和相关操作函数 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/x_wukong/p/6650056.html">Linux 内核网络协议栈 ———sk_buff 结构体 以及 完全解释 （2.6.16） - 明明是悟空 - 博客园 (cnblogs.com)</a></p><h2 id="1-SKB-结构概览"><a href="#1-SKB-结构概览" class="headerlink" title="1. SKB 结构概览"></a>1. SKB 结构概览</h2><p>SKB 的结构是这样一个很复杂的图，可以看到 skb 分为三部分：控制（<code>struct sk_buff</code> 本身）、线性数据、非线性数据（skb_shared_info）</p><p><img src="/images/Linux-Network-1-SKB/SouthEast.png" alt="img"></p><h2 id="2-SKB-线性数据部分"><a href="#2-SKB-线性数据部分" class="headerlink" title="2. SKB 线性数据部分"></a>2. SKB 线性数据部分</h2><p>SKB 的线性数据部分是用于存放数据包的<strong>连续内存空间</strong>，所以称为是线性的，主要有 head, end, data, tail 四个指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">__u16 transport_header; <span class="comment">//传输头相对于skb-&gt;head的偏移</span></span><br><span class="line"></span><br><span class="line">__u16 network_header;<span class="comment">//网络头相对于skb-&gt;head的偏移</span></span><br><span class="line"></span><br><span class="line">__u16 mac_header;<span class="comment">//以太网头相对于skb-&gt;head的偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These elements must be at the end, see alloc_skb() for details. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">sk_buff_data_t</span> tail;</span><br><span class="line"></span><br><span class="line"><span class="type">sk_buff_data_t</span> end;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *head, *data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>head 和 end 指向数据趋于的头部和尾部，是分配的时候就固定的</li><li>data 和 tail 是真正数据的开头和结尾</li><li>head 与 data 之间的趋于被称为 headroom，data 和 tail 之间的区域被称为 tailroom。刚刚分配的时候，headroom 大小为 0，tailroom 大小为 size，后续的操作通过移动 data 和 tail 来完成。</li></ul><p>四者的关系在这个图里面很清楚：</p><p><img src="/images/Linux-Network-1-SKB/941007-20160423142022179-2013851116.jpg" alt="img"></p><h2 id="3-SKB-非线性数据部分"><a href="#3-SKB-非线性数据部分" class="headerlink" title="3. SKB 非线性数据部分"></a>3. SKB 非线性数据部分</h2><p>对于大型或者是分片的数据包，其数据无法存储到连续的内存块也就是 data 中，所以需要非线性的数据存储。</p><p>skb 中有一个叫做 skb_shared_info 的结构来管理非线性部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> dataref;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> nr_frags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gso_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gso_segs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gso_type;</span><br><span class="line">    __be32 ip6_frag_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag_list</span>;</span></span><br><span class="line">    <span class="type">skb_frag_t</span> frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>nr_frags：非线性部分的片段数量</li><li>frags：片段</li></ul><p>每一个片段 skb_frag_t 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct skb_frag_struct &#123;</span><br><span class="line">    struct page *page;</span><br><span class="line">    __u32 page_offset;</span><br><span class="line">    __u32 size;</span><br><span class="line">&#125; skb_frag_t;</span><br></pre></td></tr></table></figure><p>这个结构体记录了片段在内存中的位置和大小。</p><h3 id="3-1-非线性部分的用途"><a href="#3-1-非线性部分的用途" class="headerlink" title="3.1 非线性部分的用途"></a>3.1 非线性部分的用途</h3><p>非线性部分的用途主要有：</p><ul><li>数据包过大，难以分配连续内存</li><li>IP 分片和重组</li></ul><h2 id="4-skb-gt-len-与-skb-gt-data-len"><a href="#4-skb-gt-len-与-skb-gt-data-len" class="headerlink" title="4. skb-&gt;len 与 skb-&gt;data_len"></a>4. skb-&gt;len 与 skb-&gt;data_len</h2><p>len 指的是数据包的总长度，也就是线性和非线性长度之和。</p><p>data_len 虽然带有 data 字样，但<strong>不是</strong>线性部分 data 的长度，<strong>而是</strong>非线性部分的长度。</p><p>而线性部分 skb_headlen(skb) = skb-&gt;len - skb-&gt;data_len。</p>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tailscale: 在你的远程设备之间搭建局域网</title>
      <link href="/2024/06/18/tailscale/"/>
      <url>/2024/06/18/tailscale/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设想如何在外部远程连接你在校园网或实验室内网中的设备：</p><ul><li>采用 ToDesk 等远程桌面软件，缺点是卡、清晰度低、而且在 Linux 系统中的兼容性做的不是很好，容易崩溃。</li><li>采用系统自带的远程软件如：SSH、RDP、VNC。</li></ul><p>后者的性能和稳定性更好，但是一般都是直接通过 <code>ip:port</code> 连接。而对于局域网（如校园网、实验室内网）内的设备，是没有公网 IP 的，只能在局域网的出口路由处做端口映射，比较麻烦。</p><p>而已知解决办法是通过 FTP 进行内网穿透，将你的内网设备映射到一个外部 IP 例如 <code>your-id.ftp.com</code>，但是在很多学校中，这种内网直接映射公网 IP 的方法是非法的，有潜在的威胁。</p><p>而本文介绍的 tailscale 则会在你的设备之间组件个人虚拟局域网，而不是直接把你的设备暴露在公网上，更加安全，且可以达到同样的效果。</p><p>而要配置 tailscale，其实流程非常简单，在你的不同设备上安装 tailscale 软件，然后登陆同一个账号就可以互相访问了。但比较恶心的是这个软件非常难装，尤其是在 windows 上面。</p><h2 id="Windows-安装"><a href="#Windows-安装" class="headerlink" title="Windows 安装"></a>Windows 安装</h2><p>当你访问 tailscale 官方下载页下载 Windows 安装包的时候，会下载一个几百 kb 的 exe 包来安装，这个安装过程非常缓慢，而且大概率进行到一半报错失败了。下面是一个成功率更高的解决办法：</p><ol><li>关闭防火墙&amp;杀毒软件，<strong>这个很重要！！！</strong></li><li>在官方下载页下载 msi 安装包，大概有二十多 mb，可以有效防止 exe 包安装的时候下载到一半失败了。</li></ol><p>​        <a href="https://pkgs.tailscale.com/stable/#windows">pkgs.tailscale.com/stable/#windows</a></p><p>​        一般的 64 位 PC 下载 <code>tailscale-setup-x.y.z-amd64.msi</code> 即可。</p><p>然后，从 msi 安装，打开软件登录即可。</p><h2 id="Ubuntu-安装"><a href="#Ubuntu-安装" class="headerlink" title="Ubuntu 安装"></a>Ubuntu 安装</h2><p>官方给的安装方法也是运行一个脚本，然后和 windows 一样，脚本运行到一半容易因为网络问题报错。所以，直接下载其 deb 包安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkgs.tailscale.com/stable/ubuntu/pool/tailscale_x.y.z_amd64.deb</span><br><span class="line">sudo dpkt -i tailscale_x.y.z_amd64.deb</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>都安装和登陆好以后，就可以互相 ping 同对方的虚拟地址了，然后就可以直接通过 IP 进行 SSH、VNC 等连接了。</p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu编译Linux6.8内核</title>
      <link href="/2024/06/04/Ubuntu-Linux6.8-Kernel-compile/"/>
      <url>/2024/06/04/Ubuntu-Linux6.8-Kernel-compile/</url>
      
        <content type="html"><![CDATA[<p>记录一下踩的坑</p><h2 id="1-编译前准备"><a href="#1-编译前准备" class="headerlink" title="1. 编译前准备"></a>1. 编译前准备</h2><h3 id="1-1-下载源码"><a href="#1-1-下载源码" class="headerlink" title="1.1 下载源码"></a>1.1 下载源码</h3><p>请在 kernel.org 下载 tar 包并解压到 <code>~/linux-x.y.z</code> 目录。</p><h3 id="1-2-安装编译工具链"><a href="#1-2-安装编译工具链" class="headerlink" title="1.2 安装编译工具链"></a>1.2 安装编译工具链</h3><p>正常来说，需要安装的编译工具链为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libncurses5-dev build-essential openssl flex bison libssl-dev libelf-dev</span><br></pre></td></tr></table></figure><p>其次，6.8 版本还需要安装如下两个工具来支持对应特性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install dwarves # 支持 BTF 选项</span><br><span class="line">sudo apt install zstd # 支持 zstd 压缩内核镜像</span><br></pre></td></tr></table></figure><p>当然，这里我用的是 Clang-12 编译的，而不是 gcc。Linux 6.8 以后<strong>不推荐</strong>使用 Clang-12 而是 Clang-13 以上版本，但是用 Clang-12 也不会报错，Linux 6.9 就会直接报错了。</p><h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h2><h3 id="2-1-config-阶段"><a href="#2-1-config-阶段" class="headerlink" title="2.1 config 阶段"></a>2.1 config 阶段</h3><p>最重要的，把 Ubuntu 的 config 复制过来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/src/linux-headers-5.15.0-107-generic/.config ~/linux-x.y.z/.config</span><br></pre></td></tr></table></figure><p>由于 5.15 和 6.8 版本内核的选项有很多变化，后面编译的时候会弹出很多问题要确认，建议一路回车，这么多也看不过来…</p><p>然后，<code>make menuconfig</code> 修改你自己想要的选项。</p><h3 id="2-2-编译镜像"><a href="#2-2-编译镜像" class="headerlink" title="2.2 编译镜像"></a>2.2 编译镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(nproc) CC=clang-12</span><br></pre></td></tr></table></figure><p>报错过程中有很多坑，下面列出一些常见的：</p><ol><li><p>BTF 与 zstd 报错，缺少第一章中提到的 dwarves 与 zstd 工具，或者关掉 BTF 与 zstd 选项也可以。</p></li><li><p>certs 有关报错：Debian 系都会验证签名，修改 <code>.config</code> 文件中的如下选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot;</span><br><span class="line">CONFIG_SYSTEM_REVOVATION_KEYS=&quot;&quot;</span><br></pre></td></tr></table></figure></li><li><p>栈溢出 <code>error: the frame size of xxxx bytes is larger than 1024 bytes</code>。在 <code>.config</code> 中调整栈大小即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FRAME_WARN=XXXX # 4096 或者 8192</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-安装"><a href="#2-3-安装" class="headerlink" title="2.3 安装"></a>2.3 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make modules_install</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>没报错的话直接重启即可选择系统</p>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程桌面</title>
      <link href="/2023/11/09/Linux-remote-desktop/"/>
      <url>/2023/11/09/Linux-remote-desktop/</url>
      
        <content type="html"><![CDATA[<p>最近因为跑蓝牙 Fuzz 的原因，想要不在实验室的时候也能够远程看一下代码的运行情况，做出修改。所以需要配置一个远程环境。</p><p>单纯的配一个 Linux 远程环境是很简单的，ToDesk 软件就官方支持 Linux；但还有一个需求——重启，重启以后需要自动进行：</p><ul><li>选择规定的内核</li><li>自动进入桌面</li><li>自动运行 ToDesk</li></ul><p>那么设置步骤如下：</p><h2 id="一、选择默认内核"><a href="#一、选择默认内核" class="headerlink" title="一、选择默认内核"></a>一、选择默认内核</h2><p>编辑 grub 的默认选项：</p><p>例如，当我进入系统的时候，第一个界面是：</p><blockquote><p>Ubuntu</p><p>Advanced Options for Ubuntu</p><p>Windows Boot Manager</p></blockquote><p>在选择第二个选项以后，再次选择：</p><blockquote><p>Ubuntu, with Linux 6.5.0</p><p>Ubuntu, with Linux 6.5.0 (recovery mode)</p><p>Ubuntu, with Linux 6.2.0</p><p>Ubuntu, with Linux 6.2.0 (recovery mode)</p></blockquote><p>这里我想选择 6.2 的内核，那么选择的顺序是：第2个-&gt;第3个</p><p>就需要在 /etc/default/grub 中设置 <code>GRUB_DEFAULT=&quot;1&gt; 2&quot;</code></p><p>注意这里的选项编号是从 0 开始的，所以应该是 “1&gt; 2” 而不是 “2&gt; 3”</p><p>然后 <code>sudo update-grub</code> 以后重启就可以默认进入 6.2 内核了。</p><h2 id="二、自动进入桌面"><a href="#二、自动进入桌面" class="headerlink" title="二、自动进入桌面"></a>二、自动进入桌面</h2><p>打开设置，找到 “Users -&gt; Automatic Login” 这样开机以后就可以自己进入桌面。否则的话，即使 ToDesk 连上也无法显示任何东西。</p><h2 id="三、自动启动ToDesk"><a href="#三、自动启动ToDesk" class="headerlink" title="三、自动启动ToDesk"></a>三、自动启动ToDesk</h2><p>在 ToDesk 中设置开机启动，并且设置安全密码。因为重启以后临时密码会变（即使设置成manual重置密码也会变）。</p><p>同时，如果设置了代理的话，代理软件最好也提前打开防止上不了网，从而导致连不上。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客制化之旅记录OvO</title>
      <link href="/2023/08/27/KBD/"/>
      <url>/2023/08/27/KBD/</url>
      
        <content type="html"><![CDATA[<h2 id="CX60"><a href="#CX60" class="headerlink" title="CX60"></a>CX60</h2><p>送个我家猪的w &amp; 入坑作</p><ul><li><strong>套件</strong>：CX60 <em>by 大星</em></li><li><strong>轴体</strong>：Outemu 静音白轴</li><li><strong>键帽</strong>：Menphis</li></ul><p><img src="/images/KBD/wx_camera_1629278155067.jpg" alt="wx_camera_1629278155067"></p><p>不上键帽似乎更好看(?</p><p><img src="/images/KBD/wx_camera_1629706693126.jpg" alt="wx_camera_1629706693126"></p><h2 id="Cheap68"><a href="#Cheap68" class="headerlink" title="Cheap68"></a>Cheap68</h2><p>自己的第一把客制化</p><ul><li><strong>PCB</strong>：KBD67焊接版 <em>by KBDfans怡科</em></li><li><strong>外壳</strong>：Cheap 68</li><li><strong>轴体</strong>：TTC 快银轴</li><li><strong>键帽</strong>：珊瑚海 / Olivia / 微光</li></ul><p><img src="/images/KBD/IMG_20210905_160642.jpg" alt="IMG_20210905_160642"></p><p><img src="/images/KBD/IMG_20210905_164343.jpg" alt="IMG_20210905_164343"></p><p><img src="/images/KBD/IMG_20211128_140753.jpg" alt="IMG_20211128_140753"></p><h2 id="Mr-Hat复刻"><a href="#Mr-Hat复刻" class="headerlink" title="Mr.Hat复刻"></a>Mr.Hat复刻</h2><p>3D打印，自喷漆，自己修改键线分离模块…可以说是付出很多了</p><ul><li><strong>PCB</strong>：KBD8x mk2 <em>by KBDfans怡科</em></li><li><strong>外壳</strong>：Mr.Hat by MatrixLAB 3D打印&amp;自喷漆复刻</li><li><strong>轴体</strong>：集贤 牛紫轴 <em>by 发狗</em></li><li><strong>键帽</strong>：德古拉伯爵 <em>by Akko</em></li></ul><p><img src="/images/KBD/IMG_20211114_135527.jpg" alt="IMG_20211114_135527"></p><p><img src="/images/KBD/wx_camera_1637036762216.jpg" alt="wx_camera_1637036762216"></p><p><img src="/images/KBD/IMG_20211111_131645.jpg" alt="IMG_20211111_131645"></p><p><img src="/images/KBD/IMG_20211111_172345.jpg" alt="IMG_20211111_172345"></p><h3 id="一些小小的改造过程记录…"><a href="#一些小小的改造过程记录…" class="headerlink" title="一些小小的改造过程记录…"></a>一些小小的改造过程记录…</h3><p><img src="/images/KBD/IMG_20211105_083114.jpg" alt="IMG_20211105_083114"></p><p><img src="/images/KBD/IMG_20211025_225444.jpg" alt="IMG_20211025_225444"></p><h2 id="Buff67-v2"><a href="#Buff67-v2" class="headerlink" title="Buff67 v2"></a>Buff67 v2</h2><p>第一把铝坨坨了…</p><ul><li><strong>套件</strong>：Buff67 v2 <em>by MDD</em></li><li><strong>轴体</strong>：Lumia&amp;MMD Cream / HyperGlide BLACK <em>by cherry</em> / KTT 白轴v3 / 草莓酒红</li><li><strong>键帽</strong>：Merlin / 袜子</li></ul><p><img src="/images/KBD/IMG_20211204_102325.jpg" alt="IMG_20211204_102325"></p><p><img src="/images/KBD/IMG_20220116_104041.jpg" alt="IMG_20220116_104041"></p><h2 id="Next-75"><a href="#Next-75" class="headerlink" title="Next 75"></a>Next 75</h2><p>一伯块捡来打游戏的垃圾^ ^</p><ul><li><strong>套件</strong>：Next75 <em>by 老薛</em></li><li><strong>轴体</strong>：RGB Speed Silver <em>by cherry</em></li><li><strong>键帽</strong>：古风仓颉字根</li></ul><p><img src="/images/KBD/IMG_20220716_190525.jpg" alt="IMG_20220716_190525"></p><p><img src="/images/KBD/IMG_20220121_213411.jpg" alt="IMG_20220121_213411"></p><h2 id="JINX-67-powered-by-ZUOER"><a href="#JINX-67-powered-by-ZUOER" class="headerlink" title="JINX 67 powered by ZUOER"></a>JINX 67 powered by ZUOER</h2><p>算是自己半设计了，话是很喜欢这把的</p><ul><li><strong>PCB</strong>：CIY 68</li><li><strong>外壳</strong>：JINX V1/V2 <em>by boulevard</em></li><li><strong>轴体</strong>：Outemu 水蜜桃轴</li><li><strong>键帽</strong>：PBOW <em>by 神婆</em></li></ul><h3 id="JINX-V1"><a href="#JINX-V1" class="headerlink" title="JINX V1"></a>JINX V1</h3><p>镭射版本的</p><p><img src="/images/KBD/IMG_20220327_101958.jpg" alt="IMG_20220327_101958"></p><h3 id="JINX-V2"><a href="#JINX-V2" class="headerlink" title="JINX V2"></a>JINX V2</h3><p>UV磨砂版本的（更耐用&amp;更贵）</p><p><img src="/images/KBD/wx_camera_1652506151486.jpg" alt="wx_camera_1652506151486"></p><p><img src="/images/KBD/IMG_20220427_100407.jpg" alt="IMG_20220427_100407"></p><h3 id="内胆改造"><a href="#内胆改造" class="headerlink" title="内胆改造"></a>内胆改造</h3><p>灰常软弹的自制硅胶粒~</p><p><img src="/images/KBD/IMG_20220815_103133.jpg" alt="IMG_20220815_103133"></p><p><img src="/images/KBD/-6e71f0d90a73400e.jpg" alt="-6e71f0d90a73400e"></p><h2 id="VAST75"><a href="#VAST75" class="headerlink" title="VAST75"></a>VAST75</h2><p>贵还折腾，只能说新人团慎重= =不过外观确实有一手</p><ul><li><strong>套件</strong>：VAST75 <em>by Monster Keith</em></li><li><strong>轴体</strong>：Carol Switch <em>by JWICK</em></li><li><strong>键帽</strong>：SODA <em>by XIAO Studio</em></li></ul><p><img src="/images/KBD/IMG_20220627_191055.jpg" alt="IMG_20220627_191055"></p><p><img src="/images/KBD/wx_camera_1656914188764.jpg" alt="wx_camera_1656914188764"></p><h2 id="Cherry-G80-11900"><a href="#Cherry-G80-11900" class="headerlink" title="Cherry G80-11900"></a>Cherry G80-11900</h2><p>年纪比我还大…但是长得真的好有感觉，老黑处理完也挺不错的</p><ul><li><strong>套件</strong>：Cherry G80-11900</li><li><strong>轴体</strong>：Cherry BLACK</li><li><strong>键帽</strong>：Cherry Original Keycaps</li></ul><p><strong>Old：</strong></p><p><img src="/images/KBD/wx_camera_1658556962286.jpg" alt="wx_camera_1658556962286"></p><p><strong>Brand New：</strong></p><p><img src="/images/KBD/IMG_20220814_190042.jpg" alt="IMG_20220814_190042"></p><p><img src="/images/KBD/IMG_20220814_163859.jpg" alt="IMG_20220814_163859"></p><h2 id="亚克力-Spring"><a href="#亚克力-Spring" class="headerlink" title="亚克力 Spring"></a>亚克力 Spring</h2><ul><li><strong>内胆</strong>：Spring <em>By OWLAB</em></li><li><strong>定位板</strong>：黑芯沉金FR4 <em>by HyperBoring</em></li><li><strong>外壳</strong>：亚克力（暂用）</li><li><strong>轴体</strong>：草莓奶昔缝合轴 / MM Switch <em>by Wuque Studio</em></li><li><strong>键帽</strong>：手稿</li></ul><p><img src="/images/KBD/亚克力spring1.jpg" alt="亚克力spring1"></p><p><img src="/images/KBD/亚克力spring2.jpg" alt="亚克力spring2"></p><h2 id="Spirit-Blossom-Powered-by-ZUOER"><a href="#Spirit-Blossom-Powered-by-ZUOER" class="headerlink" title="Spirit Blossom Powered by ZUOER"></a>Spirit Blossom Powered by ZUOER</h2><p>🐽的第二把也来咯</p><ul><li><strong>PCB</strong>：CIY 68</li><li><strong>外壳</strong>：Spirit Blossom <em>by 紫炁&amp;boulevard</em></li><li><strong>轴体</strong>：灰木V3 <em>by LEOBERG</em></li><li><strong>键帽</strong>：紫罗兰 <em>by SUO</em></li></ul><p><img src="/images/KBD/3d5b1ea20ac892343c1735544d0d0c8.jpg" alt="3d5b1ea20ac892343c1735544d0d0c8"></p><p><img src="/images/KBD/68528fbdfb4a49e0f5be105ca982e40.jpg" alt="68528fbdfb4a49e0f5be105ca982e40"></p><p><img src="/images/KBD/cadaf8beee015f6e757722742a6d04e.jpg" alt="cadaf8beee015f6e757722742a6d04e"></p><h2 id="0xCB-Static"><a href="#0xCB-Static" class="headerlink" title="0xCB Static"></a>0xCB Static</h2><p>主要是被外观、功能、价格吸引了</p><p>一百出头的价格，很独特的电子工业风格、自己焊接所有的元器件，屏幕和小旋钮都有</p><p>可惜学校这把被折腾坏了只能当摆件用了，等寒假把家里的那把组了再玩玩</p><ul><li><strong>套件：</strong>0xCB Static</li><li><strong>轴体：</strong>RK粉轴 <em>by 九紫电子&amp;RK</em></li><li><strong>键帽：</strong>不知名黑透键帽</li></ul><p><img src="/images/KBD/8631281945e7f92ff0a440345cd9e0b.jpg" alt="8631281945e7f92ff0a440345cd9e0b"></p><p><img src="/images/KBD/71914539c5e763c412c334240f05b0f.jpg" alt="71914539c5e763c412c334240f05b0f"></p><h2 id="AMX55木坨坨"><a href="#AMX55木坨坨" class="headerlink" title="AMX55木坨坨"></a>AMX55木坨坨</h2><p>老周送的枫木套件，据说定制一个得400？确实比黑胡桃木好看很多。</p><p>因为是不标准配列，所以自己设计了一张PCB，顺便学习了一下Vial固件的写法<a href="https://blog-boulevard.top/2022/10/24/qmk-vial/">QMK编译+Vial在线改键功能 | Boulevard’s Blog (blog-boulevard.top)</a>。</p><p>不过折腾完40%的Static和50%的这个以后，真的是再也不想碰未成年配列的，基本上用不了…所以就出了</p><ul><li><strong>外壳：</strong>老周定制枫木外壳</li><li><strong>PCB：</strong>amx55 <em>by boulevard</em></li><li><strong>轴体：</strong>集贤白轴V2(送测版) <em>by FaDog</em></li><li><strong>键帽：</strong>手稿 <em>by 锄头</em></li></ul><p><img src="/images/KBD/e4716b76d8ba44d195c30168b31259a.jpg" alt="e4716b76d8ba44d195c30168b31259a"></p><p><img src="/images/KBD/10ea33626ea2168b667ab417629d67f.jpg" alt="10ea33626ea2168b667ab417629d67f"></p><h2 id="Mr-Hat复刻-闪黑"><a href="#Mr-Hat复刻-闪黑" class="headerlink" title="Mr.Hat复刻 闪黑"></a>Mr.Hat复刻 闪黑</h2><p>自喷漆用了一年，表面的黑色部分实在是顶不住了，重新找人做了个闪黑：</p><p><img src="/images/KBD/c9ce15a0fb1e6944337c89d7dd316e5.jpg" alt="c9ce15a0fb1e6944337c89d7dd316e5"></p><p><img src="/images/KBD/04d78c5901a2c93382ea25a6819cd34.jpg" alt="04d78c5901a2c93382ea25a6819cd34"></p><p><img src="/images/KBD/0ecb3434ff9f6b9118079e048206867.jpg" alt="0ecb3434ff9f6b9118079e048206867"></p><p><img src="/images/KBD/ed374227e28d2b29331fbbee4c2456f.jpg" alt="ed374227e28d2b29331fbbee4c2456f"></p><h2 id="PaperPlane-65"><a href="#PaperPlane-65" class="headerlink" title="PaperPlane 65%"></a>PaperPlane 65%</h2><p>在外网看到的，很有工业风设计感，所以就打算自己复刻。</p><p><strong>外壳：</strong>铝合金阳极喷砂工艺，边缘质感比较糙。带有镜面不锈钢配重</p><p><strong>定位板：</strong>铝合金在这个厚度变形太严重，所以换成了Fr-4</p><p><strong>PCB：</strong>用QMK+电磁阀+蜂鸣器+USB HUB+Vial方案制作，由于经费问题，采用的是黄芯紫线</p><p><strong>轴体：</strong>HG红 <em>by Cherry</em></p><p><strong>键帽：</strong>黑同刻-克苏鲁字根 <em>by 星河山川</em></p><p><img src="/images/KBD/d98ffa70af6c528186f075da6cf3fd8.jpg" alt="d98ffa70af6c528186f075da6cf3fd8"></p><p><img src="/images/KBD/c04a35c83c27d8fcda0509dfb512afe.jpg" alt="c04a35c83c27d8fcda0509dfb512afe"></p><p><img src="/images/KBD/bcf87c3bbecd758ef98a4b2ee339f99.jpg" alt="bcf87c3bbecd758ef98a4b2ee339f99"></p><h2 id="QwertyKeys-QK75"><a href="#QwertyKeys-QK75" class="headerlink" title="QwertyKeys QK75"></a>QwertyKeys QK75</h2><p>现在的主力键盘了，虽然设计不多，但是配上这套键帽出奇的好看，硬GAS的手感和轴体也很搭。也算是圆满了我对奶白黑镜的执念。</p><p><strong>轴体：</strong>雪兰灰轴 <em>by AKKO&amp;KTT&amp;XCJZ</em></p><p><strong>定位板：</strong>Fr-4</p><p><strong>键帽：</strong> C64 Dark <em>by AlephKeys</em></p><p><img src="/images/KBD/44ec3c260603dede5d253e1a7f30565.jpg" alt="44ec3c260603dede5d253e1a7f30565"></p><p><img src="/images/KBD/0ce27189c83180c4275dd102136ce5f.jpg" alt="0ce27189c83180c4275dd102136ce5f"></p><p><img src="/images/KBD/543105293eea1bbe46d29ccb929e744.jpg" alt="543105293eea1bbe46d29ccb929e744"></p><p><img src="/images/KBD/5ccb1d877c0ce5480b54c19c4248aa7.jpg" alt="5ccb1d877c0ce5480b54c19c4248aa7"></p><h2 id="Apple-M0110-注塑复刻"><a href="#Apple-M0110-注塑复刻" class="headerlink" title="Apple M0110 注塑复刻"></a>Apple M0110 注塑复刻</h2><p>两百多的价格，HHKB配列复古造型、无钢、电磁阀，可以说是一把很合格的复古玩具了，无钢茶轴确实也很舒服。</p><p><strong>轴体：</strong>Cherry Brown</p><p><strong>填充：</strong>AB硅胶+Poron</p><p><strong>键帽：</strong>复古键帽 俄文字根  <em>by 星河山川</em> + Caps 9009灯帽 <em>by EPBT</em></p><p><strong>个性：</strong>麦金塔</p><p><img src="/images/KBD/402f5cf3cb2b92f4b4dffc92906533d.jpg" alt="402f5cf3cb2b92f4b4dffc92906533d"></p><p><img src="/images/KBD/5471860c321ad27df849d8a6214650e.jpg" alt="5471860c321ad27df849d8a6214650e"></p><p><img src="/images/KBD/62c99344a60316089300e5b77914fdf.jpg" alt="62c99344a60316089300e5b77914fdf"></p><h2 id="炁-65-PCB"><a href="#炁-65-PCB" class="headerlink" title="炁 65% PCB"></a>炁 65% PCB</h2><p>两把zuoer用的CIY68 pcb在无线方面实在是太差劲了，而且老是抽风，所以用假期时间又用优联方案制作了一套代替PCB。</p><p>主控采用的是罗技k580的主控，优点是便宜，缺点是不像k375s主控自带排线接口，很方便接线，需要自己设计转接板来接线。第一次弄转接板的时候焊盘嘎嘎掉，差点给我心态弄爆炸了。</p><p><img src="/images/KBD/9056240104e7f405c4e802dc2487de7.jpg" alt="9056240104e7f405c4e802dc2487de7"></p><p>还有一个缺点就是不能改键，68配列的F区都需要使用多路复用器来实现，真·物理切层（反正CIY也好不到哪去）。</p><p><img src="/images/KBD/9eeacb13aba905bb1815c4b7ca472ee.jpg" alt="9eeacb13aba905bb1815c4b7ca472ee"></p><p>做好的板子印上Logo还是很帅的，锂电池充放电模块转移到了PCB上面，节省键盘内部空间，当然为了保留兼容性，还是设计了外接电池模块的接口。</p><p>配列也做到了多佩列兼容，支持小门牙67、阶梯Caps和7回。</p><p>最大的优点还是罗技优联的强大功能，连接稳定性高的同时耗电量非常的低、同时休眠以后的唤醒完全无延迟。</p><h2 id="CIY-GAS67外壳"><a href="#CIY-GAS67外壳" class="headerlink" title="CIY-GAS67外壳"></a>CIY-GAS67外壳</h2><p>实在不忍心看战损的JINX zuoer在包里挤来挤去了，换一个外壳和键帽，没想到都是两位数的外壳和键帽还挺好看的，就是外壳开关位置有点不兼容，只能短接常开了…</p><p><strong>PCB：</strong>炁 65%</p><p><strong>轴体：</strong>Box冰淇淋Pro静音轴 <em>by 凯华</em></p><p><strong>键帽：</strong>pagy 红半透 <em>by 爱菲</em> </p><p><img src="/images/KBD/image-20230322170536696.png" alt="image-20230322170404605"></p><p><img src="/images/KBD/image-20230322170506883.png" alt="image-20230322170408098"></p><p><img src="/images/KBD/QQ图片20230322170623.jpg" alt="QQ图片20230322170623"></p><h3 id="爱菲Vior键帽"><a href="#爱菲Vior键帽" class="headerlink" title="爱菲Vior键帽"></a>爱菲Vior键帽</h3><p>三个月以后，ABSFans的键帽已经比我的脸还油了…于是换上了闪粉版本的</p><p><img src="/images/KBD/a395f6a93d53fe36423d6d01523b28b.jpg" alt="a395f6a93d53fe36423d6d01523b28b"></p><p><img src="/images/KBD/bcf79f5f9ca628f75616814a948c6ae.jpg" alt="bcf79f5f9ca628f75616814a948c6ae"></p><p>（但愿这次能用久一点…</p><h2 id="Sugar-80"><a href="#Sugar-80" class="headerlink" title="Sugar 80"></a>Sugar 80</h2><p>去年的老东西了，🐎宝说他喜欢这种简约外壳就给弄了…不得不说，配出来真的很妹妹风。灰木V4比V3可舒服太多了</p><p><strong>外壳：</strong>Tiger80 lite <em>by KBDFans</em></p><p><strong>PCB：</strong>Y&amp;R 80 黑芯绿油 水果湖复刻</p><p><strong>键帽：</strong></p><ul><li>主体：PBOW</li><li>淡紫色部分：素白增补 <em>by milkway</em></li><li>R1其他键位：薰衣草 <em>by 锄头</em></li></ul><p><strong>轴体：</strong>灰木V4</p><p><img src="/images/KBD/image-20230801200953456.jpg" alt="image-20230801200953456"></p><p><img src="/images/KBD/image-20230801201000491.jpg" alt="image-20230801201000491"></p><h2 id="VGN-S99"><a href="#VGN-S99" class="headerlink" title="VGN S99"></a>VGN S99</h2><p>给🐍÷的游戏键盘，看中了VGN的低延迟无线。现在的键圈真的是越来越卷了啊…319的成品能有这个设计和内胆</p><ul><li><strong>轴体：</strong>草莓奶昔 <em>by SaroKeys</em></li><li><strong>键帽：</strong>KCA柠七 <em>by 森美</em></li></ul><p><img src="/images/KBD/image-20230827213720670.jpg" alt="image-20230827213720670"></p><p><img src="/images/KBD/image-20230827213834842.jpg" alt="image-20230827213834842"></p><p><img src="/images/KBD/image-20230827213829714.jpg" alt="image-20230827213829714"></p><p><img src="/images/KBD/image-20230827213823455.jpg" alt="image-20230827213823455"></p><h2 id="究极无敌复古缝合（半成品）"><a href="#究极无敌复古缝合（半成品）" class="headerlink" title="究极无敌复古缝合（半成品）"></a>究极无敌复古缝合（半成品）</h2><p>缝合了Hans80的正面与Class80的背面、还有Suit80内胆（<del>三个原版都买不起</del>），属于是究极缝合</p><p>打印出来的外壳有误差很大用不了，暂且搁置了。·        `</p><p><img src="/images/KBD/5ef4dc1c17fa0028dfcfc1f7bc2ee2b.jpg" alt="5ef4dc1c17fa0028dfcfc1f7bc2ee2b"></p><p><img src="/images/KBD/ffa4cd21c9724fef3998dae3d0448b2.jpg" alt="ffa4cd21c9724fef3998dae3d0448b2"></p><h2 id="INFI-75-Keepout"><a href="#INFI-75-Keepout" class="headerlink" title="INFI 75 Keepout"></a>INFI 75 Keepout</h2><p>实验室买的量产，键帽配色不错，设计也不错，就是屏幕是败笔、以及外壳质量不太好。</p><ul><li>换 EPDM 底棉 &amp; FR4 定位板</li><li><strong>轴体：</strong>心海轴 <em>by HMX</em></li></ul><p><img src="/images/KBD/image-20240618161314596.jpg" alt="image-20240618161314596"></p><p><img src="/images/KBD/image-20240618161329599.jpg" alt="image-20240618161329599"></p><h2 id="Yu75"><a href="#Yu75" class="headerlink" title="Yu75"></a>Yu75</h2><p>挺好看的一把黑胡桃木坨坨，去掉底棉声音不差的同时手感很弹，可惜乌拉的三模 PCB 太拉了。</p><ul><li><strong>轴体：</strong>鲸落轴 <em>by 狼蛛&amp;SWK</em></li><li><strong>键帽：</strong>宇航员 <em>by KeyBye Lab</em></li></ul><p><img src="/images/KBD/image-20240618161534633.jpg" alt="image-20240618161534633"></p><p><img src="/images/KBD/image-20240618161549252.jpg" alt="image-20240618161549252"></p><h2 id="YuPad-amp-Yu65"><a href="#YuPad-amp-Yu65" class="headerlink" title="YuPad  &amp; Yu65"></a>YuPad  &amp; Yu65</h2><p>参与开团的两把键盘，虽然只做了 PCB 但也算是圆满了，捞到了自己在键圈的第一桶金（估计也是最后一桶了）</p><p><img src="/images/KBD/image-20240618161717869.jpg" alt="image-20240618161717869"></p><p><img src="/images/KBD/image-20240618161738697.jpg" alt="image-20240618161738697"></p><p><img src="/images/KBD/image-20240618161800578.jpg" alt="image-20240618161800578"></p><h2 id="Neo-80"><a href="#Neo-80" class="headerlink" title="Neo 80"></a>Neo 80</h2><p>进入 Neo 时代咯，OG 的内胆和亚麻喷涂白真的很让人喜欢。</p><ul><li><strong>轴体：</strong>HG Black <em>by Cherry</em></li><li><strong>键帽1：</strong>C64 Dark <em>by AlephKeys</em></li><li><strong>键帽2</strong>：Game1989 <em>by TUTKeys</em></li></ul><p><img src="/images/KBD/image-20240618162058033.jpg" alt="image-20240618162058033"></p><p><img src="/images/KBD/image-20240618162109595.jpg" alt="image-20240618162109595"></p><p><img src="/images/KBD/image-20240618162130858.jpg" alt="image-20240618162130858"></p><p><img src="/images/KBD/image-20240618162141605.jpg" alt="image-20240618162141605"></p><p><img src="/images/KBD/image-20240618162149648.jpg" alt="image-20240618162149648"></p><h2 id="Purest-75"><a href="#Purest-75" class="headerlink" title="Purest 75"></a>Purest 75</h2><p>典🐶的恶心人巨制，买到老赖的键盘了…不过氪总的结构设计还是有手的。</p><p><strong>轴体：</strong>紫薇轴 <em>by WOB&amp;HMX</em></p><p><strong>键帽：</strong>无刻混灯 <em>by 爱菲</em></p><p><img src="/images/KBD/image-20240619100206110.png" alt="image-20240619100206110"></p><h2 id="Crush-80"><a href="#Crush-80" class="headerlink" title="Crush 80"></a>Crush 80</h2><p>量产铝坨坨，不得不说619成品的价格，这个设计和质感都非常超模，可惜就是营销和售后都太过恶心…</p><p><img src="/images/KBD/image-20240618162254159.jpg" alt="image-20240618162254159"></p><p><img src="/images/KBD/image-20240618162302566.jpg" alt="image-20240618162302566"></p><h2 id="Neo-Ergo"><a href="#Neo-Ergo" class="headerlink" title="Neo Ergo"></a>Neo Ergo</h2><p>亚克力 spring 以后再次尝试 alice 配列，指法进步了用起来还挺顺手。Neo 一贯的简约质感外观真的很讨喜，手机拍不出来这个深空灰的美，只好借舍友的相机来拍了。</p><ul><li>轴体：HG雪松轴 <em>by 7min Lab&amp;地瓜外设&amp;力驰创新</em></li><li>键帽：宇航员 <em>by KeyBye Lab</em></li></ul><p><img src="/images/KBD/image-20240618162552127.jpg" alt="image-20240618162552127"></p><p><img src="/images/KBD/image-20240618162649520.jpg" alt="image-20240618162649520"></p><h2 id="Mad60HE"><a href="#Mad60HE" class="headerlink" title="Mad60HE"></a>Mad60HE</h2><p>成为瓦批以后，发现在松手急停这块磁轴还是非常有用的，于是入了一把入门级别的磁轴 Mad60HE。</p><ul><li>轴体：磁珀轴pro</li><li>键帽：爱菲百灯拼的黑灯</li></ul><p><img src="/images/KBD/image-20241118124717470.png" alt="image-20241118124717470"></p><h3 id="改Null64外壳"><a href="#改Null64外壳" class="headerlink" title="改Null64外壳"></a>改Null64外壳</h3><p>这个仿wooting的飘带+斜坡设计外壳实在是受不了（至今无法理解wooting的价格和外观，可能是我不够潮吧^ ^），而这套pcb是标准GH60孔位的，所以就物色了很久外壳，最后意外发现之前用过的NULL64支持，然后在闲鱼收了一个巴西花梨木的套件。</p><p><img src="/images/KBD/image-20241118125709699.png" alt="image-20241118125709699"></p><p><img src="/images/KBD/image-20241118125714965.png" alt="image-20241118125714965"></p><p>键帽就没换了，只能说勉勉强强不是很搭也不丑，附上一张牢钊的NULL64的搭配：</p><p><img src="/images/KBD/image-20241118125749067.png" alt="image-20241118125749067"></p><h2 id="QK80mk2"><a href="#QK80mk2" class="headerlink" title="QK80mk2"></a>QK80mk2</h2><p>qk在QK65v2、QK75N、QK100等键盘中对屏幕像是魔怔了，强行把质感和设计与量产无异的屏幕加到键盘上，显得很廉价和生硬。所以本来买的是Taku65 reboot，打算玩一玩小屏幕的。结果过程中出了个QK80mk2，感觉屏幕的设计和功能性完爆之前的QK，再加上Taku的发货时间、补偿方案不合理、以及可以zf官方转单等，出掉了taku65上小黄鱼收了吧QK80mk2。</p><ul><li>轴体：心海轴 <em>by hmx</em></li><li>键帽：百灯 <em>by amk</em></li></ul><p><img src="/images/KBD/image-20241118130300153.png" alt="image-20241118130300153"></p><p><img src="/images/KBD/image-20241118130313959.png" alt="image-20241118130313959"></p><p><img src="/images/KBD/image-20241118130321259.png" alt="image-20241118130321259"></p><p><img src="/images/KBD/image-20241118130341327.png" alt="image-20241118130341327"></p><h2 id="nano68"><a href="#nano68" class="headerlink" title="nano68"></a>nano68</h2><p>在入了磁轴而且打瓦越来越熟练以后，打算把Mad60HE送给某🐷，然后自己入一把其他的磁轴。</p><p>一开始考虑的是小蜜蜂的Made68，但是塑料外壳卖899的价格，以及最难绷的是：灯带只支持单色光，想要其他颜色的灯光需要79块钱买一个半透明灯罩？只能说小蜜蜂还是那个1000块钱买一个Mojo的小蜜蜂。</p><p>然后在小蜜蜂没有什么用的律师函下，nano68诞生了，光是不用换灯罩可以自定义RGB色彩、甚至还能有彩虹流光效果这一点就薄纱前者了。</p><ul><li>轴体：封底磁银轴 &amp; 少数万磁王轴</li><li>键帽：C64 Dark <em>by alephkeys</em></li></ul><p><img src="/images/KBD/image-20241118130813272.png" alt="image-20241118130813272"></p><p>一开始一位这样一把主打RGB灯箱外观的键盘需要搭配科技风键帽，没想到尝试性的换上了我的传家宝C64Dark以后居然有种莫名的高级感。</p><p><img src="/images/KBD/image-20241118130739582.png" alt="image-20241118130739582"></p><p><img src="/images/KBD/image-20241118130748171.png" alt="image-20241118130748171"></p><h2 id="lucky65v2"><a href="#lucky65v2" class="headerlink" title="lucky65v2"></a>lucky65v2</h2><p>200出头的快拆铝，海棠紫的颜色在量产里面算比较好看的</p><ul><li>轴体：hg雪松轴 &amp; hmx雪花轴</li><li>键帽：薄荷糖紫色希腊文</li></ul><p><img src="/images/KBD/301736338021_.pic_hd.jpg" alt="301736338021_.pic_hd"></p><p><img src="/images/KBD/311736338023_.pic_hd.jpg" alt="311736338023_.pic_hd"></p><p><img src="/images/KBD/321736338030_.pic_hd.jpg" alt="321736338030_.pic_hd"></p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用自动脚本领取LOL国际服观赛礼包</title>
      <link href="/2023/06/30/LOL-EsportsHelper/"/>
      <url>/2023/06/30/LOL-EsportsHelper/</url>
      
        <content type="html"><![CDATA[<p>众所周知，除了<del>没</del>马服以外，拳头的自营服会在观赛直播间送出<strong>观赛引擎</strong>，而观赛引擎开多了就会出现很多重复的头像/表情，可以分解为橙色精粹。</p><p>于是小黄鱼上就出现了很多代挂，低至5元/月，高到30/月。</p><p>由于小黄鱼的卖家要么不太靠谱，要么收费太贵，于是决定根据他们的截图顺藤摸瓜去找找有没有开源的代挂，果不其然找到了两个：</p><ul><li><a href="https://github.com/LeagueOfPoro/CapsuleFarmerEvolved">LeagueOfPoro/CapsuleFarmerEvolved</a></li><li><a href="https://github.com/Yudaotor/EsportsHelper">Yudaotor/EsportsHelper</a></li></ul><p>第一个是一个老外做的，但是在2023年3月的时候被Riot律师函了，所以现在已经停止维护了。</p><p>第二个是国人做的，截至目前（2023-7）还在维护，而且可用性也相对较好，所以用这个。</p><h2 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h2><p>首先考虑的肯定是在宿舍的笔记本上配置，Github上可以直接从releases下载exe包，到config里面配置一下就可以跑，很方便。只不过是外服的观赛，所以需要先挂个梯子。</p><p>但是一天下来就发现了不对劲，直接跑了3G流量，VPN+校园网流量的双重收费实在是顶不住这么造。</p><p>所以考虑不如直接租一个海外的高带宽服务器。</p><p>于是在tx云上买了一个 2核4G 30m带宽每月1000G流量的服务器，地址在新加坡，耗费42元/月。先观察一下这个月的情况，再决定是否要修改配置。</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>这个库是经典的selenium + chrome_driver的web脚本，所以需要先配置好环境，作者自己写的教程：</p><p><a href="https://github.com/Yudaotor/EsportsHelper/wiki/如何在linux环境运行（run-in-linux）">如何在linux环境运行（run in linux） · Yudaotor/EsportsHelper Wiki (github.com)</a></p><p>大差不差，但是这个教程用的是pipenv虚拟环境，而这个环境在ubuntu上真的是巨容易报错，所以稍微修改和完善了流程，用conda。</p><h3 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h3><p>服务器的Ubuntu是纯命令行，但这并不代表其不能安装浏览器，chrome支持headless模式，不在前端运行。</p><p><code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code>下载最新的chrome包，此时运行<code>sudo dpkg -i google-chrome-stable_current_amd64.deb</code>会有依赖报错，下面是解决方法：</p><p>先<code>sudo apt -f -y install</code>安装依赖，然后再次<code>sudo dpkg -i google-chrome-stable_current_amd64.deb</code>即可安装完成。</p><p>完成以后输入<code>google-chrome --version</code>，应该是可以看到的。此时Chrome就安装好了。</p><h3 id="配置python环境"><a href="#配置python环境" class="headerlink" title="配置python环境"></a>配置python环境</h3><p>万恶的pipenv全是bug，推荐使用conda，这里建议安装miniconda即可，没必要用那么臃肿的anaconda。安装方法自行百度，非常多。</p><p>然后创建一个新的python虚拟环境，需要指定python版本，3.6版本太低依赖装不上，目前用的是3.9：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda ceate -n esHelper python=3.9</span><br></pre></td></tr></table></figure><p>安装好以后，activate进入环境，克隆Github库并进入，然后安装python依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="配置config"><a href="#配置config" class="headerlink" title="配置config"></a>配置config</h2><p>config文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">delay:</span> <span class="number">600</span>                <span class="comment"># 每次检查的时间间隔，单位为秒(默认为600秒)(每次检测时间会在你设置的时延0.8-1.5倍之间随机波动) / Time interval for each check in seconds (600 seconds by default). Each check time will randomly range between 0.8 and 1.5 times the time delay you set</span></span><br><span class="line"><span class="attr">headless:</span> <span class="literal">True</span>           <span class="comment"># 设置为True时，程序会在后台运行，否则会打开浏览器窗口(默认为False) / # When set to True, the program will run in the background; otherwise it will open a browser window (set False by default)</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">&quot;账号&quot;</span>     <span class="comment"># 必填，账号 / Required field, username</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">&quot;密码&quot;</span>          <span class="comment"># 必填，密码 / Required field, passward</span></span><br><span class="line"><span class="attr">nickName:</span> <span class="string">&quot;&quot;</span>              <span class="comment"># 绰号, 不填即为用户名. / NickName. default is username.</span></span><br><span class="line"><span class="attr">maxStream:</span> <span class="number">3</span>              <span class="comment"># 最大同时观看比赛数.默认为3 / Maximum number of matches to be watched simultaneously. Default is 3.</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">&quot;zh_CN&quot;</span>         <span class="comment"># 语言选择，zh_CN是简体中文，en_US是英文, zh_TW是繁体中文 / Language selection, zh_CN for Chinese (Simplified), en_US for English,zh_TW for Chinese (Traditional)</span></span><br><span class="line"><span class="attr">autoSleep:</span> <span class="literal">False</span>          <span class="comment"># 是否自动休眠,即没比赛时自动休眠，有比赛时自动唤醒(默认为False) / Whether to sleep automatically, that is, to sleep automatically when there is no match, and to wake up automatically when there is a match (default is False)</span></span><br><span class="line"><span class="attr">onlyWatchMatches:</span> [<span class="string">&quot;lcs&quot;</span>,<span class="string">&quot;lla&quot;</span>,<span class="string">&quot;lpl&quot;</span>,<span class="string">&quot;lck&quot;</span>,<span class="string">&quot;ljl-japan&quot;</span>,<span class="string">&quot;lco&quot;</span>,<span class="string">&quot;lec&quot;</span>,<span class="string">&quot;cblol-brazil&quot;</span>,<span class="string">&quot;pcs&quot;</span>,<span class="string">&quot;tft_esports&quot;</span>]   <span class="comment"># 只观看的赛区名称,小写. / # The name of the league to be watched only, lowercase.</span></span><br><span class="line"><span class="attr">platForm:</span> <span class="string">&quot;linux&quot;</span></span><br><span class="line"><span class="attr">connectorDropsUrl:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>主要需要修改如下几项：</p><ol><li>headless：设置为True，也就是chrome不显示前端运行，一方面是服务器纯命令行没法展示前端，另一方面是减少CPU占用。关于这个模式会不会更容易被封号，在issue中提问作者说问题不大</li><li>username、password</li><li>platForm：默认是windows，改为linux</li><li>connectorDropsUrl：这个是掉落提醒的链接，钉钉、Discord等软件中都有机器人，将机器人的Webhook填入以后，只要掉落了，机器人就会提醒。</li></ol><p>配置好以后<code>python main.py</code>运行即可</p><h2 id="设置webhook"><a href="#设置webhook" class="headerlink" title="设置webhook"></a>设置webhook</h2><p>在discord和钉钉群聊中都可以添加机器人，然后复制其Webhook填入到上面的config就可以了。</p><p>要注意的是钉钉的机器人需要配置安全认证，这里配置按照IP地址认证，填入服务器公网IP即可</p><h2 id="tmux后台"><a href="#tmux后台" class="headerlink" title="tmux后台"></a>tmux后台</h2><p>服务器上运行这种后台长时间待机任务都要用tmux，使用apt安装以后，创建一个tmux回话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s esHelper</span><br></pre></td></tr></table></figure><p>到会话中激活conda环境，运行main.py，然后就可以挂起到后台运行了：首先按一下<code>ctrl + b</code>，然后按一下<code>d</code>即可。</p><p>如果想要重新进去看看情况，可以用<code>tmux attach -t esHelper</code>进入查看和操作。</p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置esp-idf环境</title>
      <link href="/2023/04/25/esp-idf-env-build/"/>
      <url>/2023/04/25/esp-idf-env-build/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>esp32开发环境主流有三种：esp-idf、micropython、arduino：</p><ul><li>esp-idf：官方出品，使用C语言编辑，环境比较难装，不过集成了很多库还是不错。</li><li>micropython：没了解太多，不过python语法比C还是友好很多。</li><li>arduino：arduino的类C开发语言，比直接用嵌入式C开发简单，而且有巨大的arduino生态支持。</li></ul><p>虽然怎么看micropython和arduino都很香，但是无奈这次需要用到SM2椭圆曲线，看到的几个esp32上跑ecc的代码主要都在esp-idf上。本来就是刚入门，要是开发环境还和网上资料不一样的话感觉要寄…所以<strong>最终选择了ESP-IDF</strong>。</p><h2 id="（已放弃）Windows配置ESP-IDF"><a href="#（已放弃）Windows配置ESP-IDF" class="headerlink" title="（已放弃）Windows配置ESP-IDF"></a>（已放弃）Windows配置ESP-IDF</h2><h3 id="直接安装本地ESP-IDF-VSCode"><a href="#直接安装本地ESP-IDF-VSCode" class="headerlink" title="直接安装本地ESP-IDF + VSCode"></a>直接安装本地ESP-IDF + VSCode</h3><p><a href="https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/install.md">vscode-esp-idf-extension/install.md at master · espressif/vscode-esp-idf-extension · GitHub</a></p><p>看似很简单，直接在VSCode中下载插件，插件可以自动安装好环境（当然也可以先安装ESP-IDF，然后到VSCode中识别已有环境），然后就可以在VSCode里面进行编译/调试。</p><p>但是实际上ESP-IDF本并不适合在Windows本地装，编译速度比Linux慢5倍左右且不说。在Windows本地安装了好几遍不同版本的IDF，到最后编译HelloWorld工程的时候都会编译失败。</p><p>上网一查，很多人都遇到这个问题，可能是因为IDF的主程序是IDF.py，而Windows上面之前配过的python环境产生了一些冲突。在全新的Windows或者Linux系统下配置IDF编译就都没问题。</p><p>故放弃Windows本地的ESP-IDF</p><h3 id="Docker-WSL2-VSCode-Remote-WSL2串口工具"><a href="#Docker-WSL2-VSCode-Remote-WSL2串口工具" class="headerlink" title="Docker+WSL2+VSCode Remote+WSL2串口工具"></a>Docker+WSL2+VSCode Remote+WSL2串口工具</h3><p>然后就看到有人说WSL2+Docker+VSCode Remote+WSL2串口工具可以很方便的配置环境。</p><p>看了一下例子，不是那么方便…不过本地实在是配不好了，就考虑去试试。</p><p>然后最脑瘫的来了^ ^：</p><p>一打开我多年未动的WSL2和Docker Desktop居然发现他们寄了。仔细一想好像是这学期初装VBox的时候把Hyper-V虚拟化关掉了，然后一顿操作打开Hyper-V复活WSL2和Docker，我的VBox与VMWare又寄了…没办法这学期要做实验，只能老老实实删了WSL2和Docker，关闭Hyper-V，配了半天恢复原样</p><p>只能说和Hyper-V沾点的东西还是少去碰…</p><h2 id="Ubuntu虚拟机配置ESP-IDF-VSCode"><a href="#Ubuntu虚拟机配置ESP-IDF-VSCode" class="headerlink" title="Ubuntu虚拟机配置ESP-IDF+VSCode"></a>Ubuntu虚拟机配置ESP-IDF+VSCode</h2><h3 id="安装ESP-IDF"><a href="#安装ESP-IDF" class="headerlink" title="安装ESP-IDF"></a>安装ESP-IDF</h3><p>之前不是有人说在没配过Python环境的系统上随便配吗，既然到Windows上面跑是彻底泡汤了，那就直接开一个Ubuntu虚拟开装吧：</p><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.0.1/esp32/get-started/linux-macos-setup.html#get-started-prerequisites">Linux 和 macOS 平台工具链的标准设置 - ESP32 - — ESP-IDF 编程指南 v5.0.1 文档 (espressif.com)</a></p><p>由于是全新的虚拟机环境，装的过程还是很顺利地，开个连GitHub很稳定的加速器，跟着上文一顿输入脚本就行。</p><p>需要注意的是，ESP-IDF有很多环境变量，需要运行<code>$HOME/esp/esp-idf/export.sh</code>来导入配置。由于这些环境变量实在是太多了，所以写入到<code>~/.bashrc</code>里面又不是很合适，于是可以到<code>~/.bashrc</code>中加入一个运行<code>export.sh</code>的快捷命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias get_idf=&#x27;. $HOME/esp/esp-idf/export.sh&#x27;</span><br></pre></td></tr></table></figure><p>这样每次打开终端，只需要输入一句<code>get_idf</code>就激活idf环境了。</p><h3 id="简单使用IDF"><a href="#简单使用IDF" class="headerlink" title="简单使用IDF"></a>简单使用IDF</h3><p>随便搞一个工程，比如<code>hello_world</code>，进入到终端激活idf环境，首先可以设置目标芯片：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/esp/hello_world</span><br><span class="line">idf.py set-target esp32</span><br><span class="line">idf.py menuconfig</span><br></pre></td></tr></table></figure><p>menuconfig中会弹出来一个和电脑BIOS一样简陋的界面，可以到里面配置ESP32的一些设置，比如WIFI配置、处理器速度等等。</p><p>配置好以后，运行<code>idf.py build</code>即可编译出bin文件，总之，如果没有VSCode等IDE，就需要在终端中使用<code>idf.py</code>对工程操作。</p><h3 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h3><p>这个和在Windows上大差不差，安装插件，配置插件的时候选择之前安装好的IDF即可。</p><h3 id="烧录ESP32"><a href="#烧录ESP32" class="headerlink" title="烧录ESP32"></a>烧录ESP32</h3><p>虽然是在虚拟机上面，但是实际上和直接烧录大差不差（夸一夸VMWare做的还是挺好的，不像垃圾VBox^ ^）</p><p>注：如下设置方法仅支持ESP32 DevKitC v4通过USB烧录</p><ol><li>不插入ESP32，首先在终端输入<code>ls /dev/tty*</code></li><li>插入ESP32，VMWare会提示要把USB设备放在主机还是虚拟机使用，选择虚拟机</li><li>再次输入<code>ls /dev/tty*</code>，比第一次多出来的的就是你选的设备（我这里叫ttyUSB0）</li><li>使用<code>sudo code .</code>打开VSCode；或者<code>sudo chmod 777 /dev/ttyUSB0</code>（这一步是为了防止没有权限访问串口）</li><li>在VSCode左下角修改串口，选择步骤3中确定的串口</li><li>VSCode左下角第二个esp32，选择型号，我这里选择<code>esp32 &gt; esp32 with USB bridge</code>，也就是通过USB通信的esp32开发板</li><li>点击<code>编译-烧录-监视</code>（也就是一个火苗的图标）。第一次执行编译完毕以后，会让你选择烧录方式，选<code>UART</code>，然后开始烧录，按一下ESP32上面的<code>BOOT按键</code>，出现烧录进度。烧录完毕以后会自动打开监视界面。</li></ol><p>如果你没有开发板，而想要验证程序，可以在<a href="https://wokwi.com/projects/305457271083631168">esp32-bin-file.ino - Wokwi Arduino and ESP32 Simulator</a>上传bin文件仿真。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监听HTTPS加密流量</title>
      <link href="/2023/04/23/https-packet-capture/"/>
      <url>/2023/04/23/https-packet-capture/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Charles抓包软件"><a href="#安装Charles抓包软件" class="headerlink" title="安装Charles抓包软件"></a>安装Charles抓包软件</h2><p><a href="https://www.52pojie.cn/thread-1600964-1-1.html">网络抓包工具Charles 4.5.6 中文版(Windows便携免安装) - 『逆向资源区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p>安装破解即可</p><h2 id="启用SSL代理"><a href="#启用SSL代理" class="headerlink" title="启用SSL代理"></a>启用SSL代理</h2><h3 id="安装根证书"><a href="#安装根证书" class="headerlink" title="安装根证书"></a>安装根证书</h3><p><code>帮助 &gt; SSL代理 &gt; 安装Charles根证书</code>：</p><p>点击安装证书（I）：</p><p><img src="/images/charlesHTTPS/image-20230423201826079.png" alt="image-20230423201826079"></p><p>选择当前计算机，下一页，将证书存储到受信任的根证书颁发机构：</p><p><img src="/images/charlesHTTPS/image-20230423201921773.png" alt="image-20230423201921773"></p><p>安装完成</p><h3 id="安装浏览器证书"><a href="#安装浏览器证书" class="headerlink" title="安装浏览器证书"></a>安装浏览器证书</h3><p><code>帮助 &gt; SSL代理 &gt; 在移动设备或远程浏览器上安装Charles根证书</code>，会弹出一个保存页面，随便找个位置保存。</p><p>浏览器设置中搜索“证书”，进入证书添加页面加入保存的证书即可。</p><h2 id="测试HTTPS抓包"><a href="#测试HTTPS抓包" class="headerlink" title="测试HTTPS抓包"></a>测试HTTPS抓包</h2><p><code>代理 &gt; SSL代理设置 &gt; 包括</code>加入一条<code>*:*</code></p><p>然后开启SSL，访问一个HTTPS网页，发现可以抓包并解密：</p><p><img src="/images/charlesHTTPS/image-20230423202307163.png" alt="image-20230423202307163"></p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win11引导丢失翻车记录</title>
      <link href="/2023/03/24/Win11-efi-fix/"/>
      <url>/2023/03/24/Win11-efi-fix/</url>
      
        <content type="html"><![CDATA[<p>随意记录一下一次翻车过程</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>双硬盘，一个为基本磁盘，一个为动态磁盘，但是装Ubuntu双系统的时候好像识别不到动态磁盘，所以就用傲梅把动态转为了基本，结果开机直接丢失引导</p><h2 id="尝试过程"><a href="#尝试过程" class="headerlink" title="尝试过程"></a>尝试过程</h2><p>既然没有引导，那肯定就只能先弄个PE启动盘了</p><h3 id="老毛桃PE"><a href="#老毛桃PE" class="headerlink" title="老毛桃PE"></a>老毛桃PE</h3><p>做一个老毛桃PE，进去以后有MBR修复，修复完成以后重启还是不行</p><h3 id="Win11PE"><a href="#Win11PE" class="headerlink" title="Win11PE"></a>Win11PE</h3><p>做一个Win11安装PE，进去以后有引导修复，提示无法修复</p><p>那么打开PE的命令提示符工具，依次输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class"><span class="title">chkdsk</span> /<span class="title">r</span></span></span><br><span class="line"><span class="class"><span class="title">SFC</span> /<span class="title">SCANNOW</span></span></span><br><span class="line"><span class="class"><span class="title">BOOTREC</span> /<span class="title">SCANOS</span></span></span><br><span class="line"><span class="class"><span class="title">BOOTREC</span> /<span class="title">FIXMBR</span></span></span><br><span class="line"><span class="class"><span class="title">BOOTREC</span> /<span class="title">FIXBOOT</span></span></span><br><span class="line"><span class="class"><span class="title">BOOTREC</span> /<span class="title">REBUILDBCD</span></span></span><br></pre></td></tr></table></figure><p>结果还是不行…事实上，事情远不是丢失引导这么简单</p><h3 id="万能的TB"><a href="#万能的TB" class="headerlink" title="万能的TB"></a>万能的TB</h3><p>TB找了好几家店，几家都不能修说只能操作系统，直到遇到了一家高手给我解释原因：动态磁盘类似组了RAID，两个磁盘是关联的，那么，关闭到以后自然无法读取到很多信息，包括引导</p><p>然后根据我发过去的，坏之前我的硬盘分区，老板远程用diskgenius扫描分区，对于扫描出来的分区有的采纳、有的忽略（我也不知道怎么判断的），最后把所有分区都恢复了出来并重建了引导</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ol><li>动态、raid等不要乱改动</li><li>作死之前，先备份分区表和引导</li></ol>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暴力破解压缩包密码--John the Ripper/HashCat</title>
      <link href="/2023/03/24/John-the-Ripper-HashCat/"/>
      <url>/2023/03/24/John-the-Ripper-HashCat/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>某实验课程，四节课要啰嗦大概两节课的时间，且实验指导书设置了”Cst.******“（*为0-9/a-z/A-Z）的密码，网上随便下一个密码破解工具会很难破解（显示时间&gt;一年），所以想寻求一些高效的破解方法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>John the Ripper（以下简称JtR）：此工具有John和file2john两种子工具<ul><li>file2john会识别文件特征，提取出一串哈希值，如：运行<code>zip2john test.zip</code>会得到类似<script type="math/tex">pkzip2$1*1*...d*$/pkzip2</script>，虽然是哈希值，但是这玩意可以很大（比如我提取出来6M的哈希值文件），具体原理未知</li><li>John主程序会对上面的哈希值进行密码爆破，计算密码的哈希与其比对</li></ul></li><li>HashCat：此工具类似JtR的John，可以爆破密码哈希值与输入的哈希值比对，但是不能单独用于密码破解，需要用file2john提取特征哈希以后才可以破解</li></ul><p>两种工具都有尝试，且成功配好，但是都有其应用上的限制，建议两个都准备好，以备不时之需）</p><h2 id="HashCat"><a href="#HashCat" class="headerlink" title="HashCat"></a>HashCat</h2><p>配置环境为：</p><ul><li>Ubuntu 20.04 </li><li>NVIDIA Tesla A100-32GB with CUDA</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>参考：<a href="https://github.com/hashcat/hashcat">hashcat/hashcat: World’s fastest and most advanced password recovery utility (github.com)</a></p><p>需要已经安装好NVIDIA Driver和CUDA Toolkit，注意这玩意有点讲究，有详细的版本对应表，可以上网查一下</p><p>直接在上面的hashcat GitHub repo中下载最新release的7z包，<code>7z x</code>解压</p><h4 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h4><p>安装好以后需要测试hashcat能否使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -a 0 -m 500 example500.hash example.dict</span><br></pre></td></tr></table></figure><p>除了要注意是否可以跑通外，还需要注意输出的Device Info里面有没有GPU</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="准备哈希文件"><a href="#准备哈希文件" class="headerlink" title="准备哈希文件"></a>准备哈希文件</h4><p>之前说过，Hashcat爆破之前要准备好hash文件，还是要用到JtR。JtR可以在Kali虚拟机上面直接使用（只不过无法调用GPU），如果没有kali的话，可以参考下一节JtR的内容在Windows安装并编译JtR</p><p>安装好以后，使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip2john test.zip &gt; hash.txt</span><br></pre></td></tr></table></figure><p>此处需要注意：</p><ul><li>hash.txt一定要是<strong>UTF-8</strong>格式存储的，如果不是，请用vscode等工具将其用UTF-8编码保存</li><li>hash.txt的格式是 <code>test.zip:test.pdf:$pkzip2$1*1...d*$/pkzip2$:test.pdf:test.zip</code>，请掐头去尾，只保留<script type="math/tex">pkzip2$1*1...d*$/pkzip2</script>的内容</li><li>hash.txt不能有<strong>空格、不可见字符</strong>等</li></ul><h4 id="设置密码范围"><a href="#设置密码范围" class="headerlink" title="设置密码范围"></a>设置密码范围</h4><p>我们使用mask_attack模式<code>-a 3</code>来自定义密码，具体如下：</p><p>以下是mask_attack的字符集：</p><blockquote><ul><li>?l = abcdefghijklmnopqrstuvwxyz</li><li>?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ</li><li>?d = 0123456789</li><li>?h = 0123456789abcdef</li><li>?H = 0123456789ABCDEF</li><li>?s = «space»!”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~</li><li>?a = ?l?u?d?s</li><li>?b = 0x00 - 0xff</li></ul></blockquote><p>那么假设我要爆破的密码范围是”boulebard”+3位数字，就可以用<code>-a 3 boulevard?d?d?d</code> 来规定</p><p>如果是自定义字符集呢？可以用<code>-1 字符集1内容, -2 字符集2内容</code>自定义字符集，然后用<code>?1?2</code>使用字符集</p><p>例如，对于”Cst.******“（*为0-9/a-z/A-Z），需要定义数字+大小写字母的字符集：<code>-1 ?l?u?d</code></p><p>然后，密码则表达为<code>Cst.?1?1?1?1?1?1</code></p><h4 id="设置爆破模式"><a href="#设置爆破模式" class="headerlink" title="设置爆破模式"></a>设置爆破模式</h4><p>对于不同文件类型有不同的爆破模式<code>-m mode_num</code>，需要根据被爆破文件的格式和hash.txt的内容来在<a href="https://hashcat.net/wiki/doku.php?id=example_hashes">example_hashes [hashcat wiki\]</a>中查询到模式码，如：</p><p><img src="/images/john/image-20230324093110247.png" alt="image-20230324093110247"></p><p>对于上面的hash.txt，就只需要尝试<code>-m 17200/17210/17220/17225/17230</code></p><p>所以，最后的调用代码为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hashcat.bin -a 3 -m 17200 -1 ?l?u?d hash.txt Cst.?1?1?1?1?1?1</span><br></pre></td></tr></table></figure><h3 id="问题-amp-缺点"><a href="#问题-amp-缺点" class="headerlink" title="问题&amp;缺点"></a>问题&amp;缺点</h3><p>我遇到的两个问题都在<a href="https://hashcat.net/forum/thread-11358-post-57870.html#pid57870">Signature unmatched No hashed loaded. (hashcat.net)</a>提出</p><ul><li>第一个问题是之前提到的，hash.txt没有用UTF-8保存，注意以下即可解决</li><li>第二个问题就要看运气了，某些文件提取出的hash很大，导致hashcat无法处理，这种情况就只能去用JtR破解了</li></ul><h2 id="John-the-Ripper"><a href="#John-the-Ripper" class="headerlink" title="John the Ripper"></a>John the Ripper</h2><p>配置环境为</p><ul><li>Windows11 22H2</li><li>RTX2070-8GB</li></ul><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>参考：<a href="https://github.com/openwall/john/blob/bleeding-jumbo/doc/INSTALL-WINDOWS">john/INSTALL-WINDOWS at bleeding-jumbo · openwall/john (github.com)</a></p><p>在Windows下，需要用到CryWin安装，到<a href="https://cygwin.com/install.html">Cygwin Installation</a>下载<code>setup-x86_64.exe</code>，放到<code>C:/crywin64/</code>目录下，然后在Windows PowerShell执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\cygwin64\setup-x86_64.exe -q -P gcc-core -P libgcc1 -P make -P perl</span><br><span class="line">C:\cygwin64\setup-x86_64.exe -q -P libssl-devel -P libbz2-devel</span><br><span class="line">C:\cygwin64\setup-x86_64.exe -q -P libgmp-devel -P zlib-devel</span><br><span class="line">C:\cygwin64\setup-x86_64.exe -q -P libOpenCL-devel -P libcrypt-devel</span><br></pre></td></tr></table></figure><p>输入命令以后安装的过程基本上是自动的，只不过第一次安装的时候会要你选源，选一个国内的即可</p><p>然后下载<a href="https://github.com/openwall/john/archive/bleeding-jumbo.zip">https://github.com/openwall/john/archive/bleeding-jumbo.zip</a>，解压放到<code>C:/crywin64/home/[用户名]</code>目录</p><p>打开crywin64 terminal（点击图标即可），进入上面解压的目录，开始编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure &amp;&amp; make -s clean &amp;&amp; make -sj4</span><br><span class="line">make windows-package</span><br></pre></td></tr></table></figure><p>编译好以后，测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..\run\john --test=0</span><br></pre></td></tr></table></figure><p>然后查看你的OpenCL设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..\run\john --list=opencl-devices                                               </span><br></pre></td></tr></table></figure><p>但是有时候，很不幸，你可能<strong>只能看到CPU而看不到GPU</strong></p><p>这时候，参考<a href="https://miloserdov.org/?p=4961#131">Comprehensive Guide to John the Ripper. Part 1: Introducing and Installing John the Ripper - Ethical hacking and penetration testing (miloserdov.org)</a>中的方法：</p><ol><li>在<code>C:\cygwin64\bin\</code>中找到<code>cygOpenCL-1.dll</code>，重命名为<code>cygOpenCL-1.dll.bac</code></li><li>把<code>C:\Windows\System32\OpenCL.dll</code>复制到<code>C:\cygwin64\bin\</code>，重命名为<code>cygOpenCL-1.dll</code></li></ol><p>这时再次查看设备，就可以查看到显卡了</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>同样的，我们使用mask模式来爆破密码，其语法参考<a href="https://github.com/openwall/john/blob/bleeding-jumbo/doc/MASK">john/MASK at bleeding-jumbo · openwall/john (github.com)</a></p><p>语法和hashcat类似，自定义字符集可以用<code>-1=?l?u</code>表示，对于Cst.那个密码，爆破命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run/john/ -1=?d?l?u --mask=Cst.?1?1?1?1?1?1 hast.txt</span><br></pre></td></tr></table></figure><p>但是需要注意的是，即使查看到了GPU，JtR也会默认使用CPU，需要用<code>--format=wpapsk-opencl -dev=1</code>来设置使用OpenCL与GPU，但是，很遗憾，根据<a href="https://github.com/openwall/john/issues/4070">Issue #4070 · openwall/john (github.com)</a><em>**</em>的内容，zip文件并不支持OpenCL GPU破解，不过亲测对于上面的6位大小写+数字密码，即使是i5-10400也只需要20分钟就可以成功装好</p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WSL2配置Cuda</title>
      <link href="/2023/03/22/WSL2-Cuda/"/>
      <url>/2023/03/22/WSL2-Cuda/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-Ubuntu&amp;target_version=2.0&amp;target_type=deb_local">CUDA Toolkit 12.1 Downloads | NVIDIA Developer</a></p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="在Windows中安装显卡驱动"><a href="#在Windows中安装显卡驱动" class="headerlink" title="在Windows中安装显卡驱动"></a>在Windows中安装显卡驱动</h3><p>注意是在Windows而不是WSL中安装驱动，安装的是游戏驱动即可</p><p>如果已经安装（毕竟打游戏的一般都提前安装好了），只需要在Windows powershell中输入<code>nvidia-smi</code>即可验证</p><h3 id="在WSL2中配置"><a href="#在WSL2中配置" class="headerlink" title="在WSL2中配置"></a>在WSL2中配置</h3><p>参考开头给出的链接，只需要输入图中的这些命令就可以配置完成</p><p><img src="/images/wsl-cuda/image-20230322164339279.png" alt="image-20230322164339279"></p><p>然后到wsl里面再输入一遍<code>nvidia-smi</code>即可验证</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>显卡驱动是最新的Game Driver即可，安装在Windows而不是WSL</li><li>WSL版本需要为WSL2，WSL1不支持</li><li>不支持Maxwell架构显卡（截至博客发布时间</li><li>如果是SSH登录WSL，可能会提示没有<code>nvidia-smi</code>命令，可能是环境变量的问题，输入绝对路径<code>/usr/lib/wsl/lib/nvidia-smi</code>运行即可。方便起见，可以添加一个环境变量</li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WSL2配置SSH局域网访问</title>
      <link href="/2023/03/22/WSL2-SSH/"/>
      <url>/2023/03/22/WSL2-SSH/</url>
      
        <content type="html"><![CDATA[<h2 id="配置思路"><a href="#配置思路" class="headerlink" title="配置思路"></a>配置思路</h2><ul><li>和普通Linux一样，WSL也是通过OpenSSH配置SSH server</li><li>但是WSL是Windows的子系统，同一个局域网内的其他主机无法访问，所以要在Windows上面配置端口映射</li></ul><p>参考：</p><p><a href="https://blog.csdn.net/qq_24211837/article/details/117386077">wsl2 远程登陆ssh<em>_刘文凯</em>的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_42727710/article/details/122495314">Windows11，银河麒麟：如何打开端口<em>麒麟系统开放端口</em>全栈开发与测试的博客-CSDN博客</a></p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="配置OpenSSH"><a href="#配置OpenSSH" class="headerlink" title="配置OpenSSH"></a>配置OpenSSH</h3><p>过程比较基础，不再赘述，/etc/ssh/sshd_config如下所示：</p><p><img src="/images/wsl-ssh/image-20230322162125318.png" alt="image-20230322162125318"></p><p>打开以后在Windows powershell中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@localhost -p 2111</span><br></pre></td></tr></table></figure><p>即可在本地Windows系统访问WSL的SSH服务</p><h3 id="配置端口映射"><a href="#配置端口映射" class="headerlink" title="配置端口映射"></a>配置端口映射</h3><p>在Windows中使用netsh配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy set v4tov4 listenport=2233 listenaddress=0.0.0.0 connectport=2111 connectaddress=&#123;ip_wsl&#125;</span><br></pre></td></tr></table></figure><p>前面的port和ip表示Windows监听的ip和端口，后面的是wsl的ip和端口</p><p>此外，还要再Windows防火墙中打开2233端口，请参考第二篇博客</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT QQ机器人快速配置</title>
      <link href="/2023/03/21/ChatGPT-QQ-chatbot/"/>
      <url>/2023/03/21/ChatGPT-QQ-chatbot/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ol><li><p>ChatGPT-mirai-QQ-bot</p><p><a href="https://github.com/lss233/chatgpt-mirai-qq-bot">GitHub - lss233/chatgpt-mirai-qq-bot: 🚀 一键部署！真正的 ChatGPT QQ 聊天机器人！支持ChatGPT API、 ChatGPT Plus、新版 Bing，多账号负载均衡，人设调教，敏感词检测，虚拟女仆、对话上下文，图片渲染，代理加速 (内有视频教程）</a></p><p>在GitHub下载最新Release压缩包即可</p></li><li><p>手机滑块验证码工具</p><p><a href="https://pan.baidu.com/s/1Ij-CCHgY7S16cZo584RvsA">https://pan.baidu.com/s/1Ij-CCHgY7S16cZo584RvsA</a> </p><p>提取码：7qjk</p></li></ol><h2 id="配置思路"><a href="#配置思路" class="headerlink" title="配置思路"></a>配置思路</h2><p>本项目由mirai和chatgpt两个模块组成，mirai负责与QQ通信，将信息转发到chatpgt，然后把chatgpt的回复发送到QQ</p><p>只要在两个模块上分别登录好QQ和ChatGPT账户即可</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="初始化-amp-配置ChatGPT账户"><a href="#初始化-amp-配置ChatGPT账户" class="headerlink" title="初始化&amp;配置ChatGPT账户"></a>初始化&amp;配置ChatGPT账户</h3><p>解压缩安装包，会有一个<code>初始化.bat脚本</code>，直接运行，完毕以后会弹出一个cfg配置文件，在其中配置ChatGPT账户：</p><ul><li>配置QQ号</li></ul><p><img src="/images/ChatGPT-Mirai/image-20230322163044228.png" alt="image-20230322163044228"></p><ul><li>配置梯子<img src="/images/ChatGPT-Mirai/image-20230322163126537.png" alt="image-20230322163126537"></li><li>配置OpenAI API密钥<img src="/images/ChatGPT-Mirai/image-20230322163141324.png" alt="image-20230322163141324"></li></ul><p>当然，提供了很多的OpenAI登陆账号，这里选择除了贵没有缺点的API方式（反正有免费额度</p><h3 id="配置Mirai"><a href="#配置Mirai" class="headerlink" title="配置Mirai"></a>配置Mirai</h3><p>这玩意配置bug很多，出问题了建议多上GitHub看看issue（毕竟是“非法”登陆腾讯的东西^ ^</p><p>点击<code>启动Mirai.bat</code>，然后等待Mirai初始化完成，输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Login qq号 qq密码 设备类型</span><br></pre></td></tr></table></figure><p>设备类型等于是模拟在什么设备上面登录，一开始选择的是ANDROID_WATCH也就是安卓手表，出现了error，查询了<a href="https://mirai.mamoe.net/topic/223/无法登录的临时处理方案?lang=zh-CN">Mirai官方的解决方案</a>，把设备改为了MACOS就行了</p><p>然后，如果是第一次登陆的话，会要进行验证，如下图所示：</p><p><img src="/images/ChatGPT-Mirai/image-20230322163737380.png" alt="image-20230322163737380"></p><p>复制这个captcha链接，在滑动验证码app中输入并完成验证：</p><p><img src="/images/ChatGPT-Mirai/image-20230322163809239.png" alt="image-20230322163809239"></p><p>会得到一串TX值，赋值TX值，直接输入到Mirai终端就可以完成登录</p><h3 id="启动ChatGPT"><a href="#启动ChatGPT" class="headerlink" title="启动ChatGPT"></a>启动ChatGPT</h3><p>然后点击<code>启动ChatGPT.bat</code>，如下图就是登陆成功：</p><p><img src="/images/ChatGPT-Mirai/image-20230322163918590.png" alt="image-20230322163918590"></p><p>到私聊或者到群里@进行对话测试</p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓查看电池寿命</title>
      <link href="/2022/12/26/Android-battery-capacity/"/>
      <url>/2022/12/26/Android-battery-capacity/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>查看系统内的uevent文件可以查找到电池容量</p><p>这个文件，按照网上大多数的说法，在：<code>/sys/class/power_supply/bms/uevent</code>，不过我的路径略有出入，建议进入到<code>/sys/class/power_supply</code>以后自己找一找</p><h2 id="读取uevent文件"><a href="#读取uevent文件" class="headerlink" title="读取uevent文件"></a>读取uevent文件</h2><p>那么难点就在怎么获得这个文件了</p><h3 id="方法一：termux（需要root）"><a href="#方法一：termux（需要root）" class="headerlink" title="方法一：termux（需要root）"></a>方法一：termux（需要root）</h3><h4 id="安装termux"><a href="#安装termux" class="headerlink" title="安装termux"></a>安装termux</h4><p>在此下载：<a href="https://github.com/termux/termux-app/releases">Releases · termux/termux-app (github.com)</a></p><p>里面有很多版本，需要下载和你的手机CPU架构一致的。所以需要查看CPU架构，方法可以选择：</p><ul><li>搜索你的CPU型号是什么架构</li><li>使用ADB命令：<code>adb shell getprop ro.product.cpu.abi</code></li></ul><p>我的手机CPU是865，ADB返回的架构是arm64-v8a</p><p>所以下载后面标注arm64-v8a的apk包</p><h4 id="获取文件"><a href="#获取文件" class="headerlink" title="获取文件"></a>获取文件</h4><p>安装好以后，termux就等于在你的手机里面运行了一个Linux Shell，直接cat就好</p><p>不过我cat不到，估计是没有root导致的</p><h3 id="方法二：adb（还是需要root）"><a href="#方法二：adb（还是需要root）" class="headerlink" title="方法二：adb（还是需要root）"></a>方法二：adb（还是需要root）</h3><p>同样的，adb其实也是Linux shell，能访问的话cat就好，但是普通的adb是没有root权限的。</p><p>adb root的方法有两种，第一个是直接 adb root访问，第二个是装adbd insecure</p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓卸载自带应用</title>
      <link href="/2022/12/25/Android-uninstall-system-apps/"/>
      <url>/2022/12/25/Android-uninstall-system-apps/</url>
      
        <content type="html"><![CDATA[<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>电脑：ADB工具</p><p>手机：ES文件浏览器、打开USB调试</p><h2 id="查找包名"><a href="#查找包名" class="headerlink" title="查找包名"></a>查找包名</h2><p>在<code>ES文件浏览器 -&gt; 应用 -&gt; 系统应用</code>中找到想要卸载的应用，点开的属性中回显示包名</p><p>比如这里我想卸载的是Oxygen13自带的Netflix，其包名为<code>com.netflix.mediaclient</code></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>在输入<code>adb devices</code>可以找到设备以后，输入<code>adb shell</code></p><p>然后输入<code>pm uninstall --user 0 包名</code>即可卸载</p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一加8T9008救砖</title>
      <link href="/2022/12/24/oneplus8T-9008/"/>
      <url>/2022/12/24/oneplus8T-9008/</url>
      
        <content type="html"><![CDATA[<p>在折腾8T各种系统的道路上，已经翻车过两次了（变砖），每次变砖以后临时上网查教程就还是挺急的，所以写一篇救砖的博客</p><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>软件：救砖包+9008驱动</p><p>我是从一加社区找过来的<a href="https://bbs.oneplus.com/thread/5689136?mod=viewthread&amp;tid=5689136">OnePlus8T 官方ROM+9008救砖包</a></p><p>最终下载的版本如下：</p><p><img src="/images/8T/image-20221224103300683.png" alt="image-20221224103300683"></p><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>点击上面第二个exe文件，会弹出一个网络下载驱动（要你选择什么Ethernet之类的），不选这个，点击Cancel-&gt;是。你会发现把这个窗口关掉以后下面还会有一个本地安装的选项，这个才是需要的，然后一路next/accept安装即可。</p><h3 id="解决和windows的冲突"><a href="#解决和windows的冲突" class="headerlink" title="解决和windows的冲突"></a>解决和windows的冲突</h3><p>第一次安装驱动已经过了好久了，当时好像是和windows有点冲突，只安装好还用不了，解决办法如下：</p><p>windows设置-&gt;恢复-&gt;高级启动（重启）-&gt;疑难解答-&gt;高级选择-&gt;启动设置-&gt;重启-&gt;“7”禁用驱动程序强制签名-&gt;进系统</p><h2 id="救砖"><a href="#救砖" class="headerlink" title="救砖"></a>救砖</h2><p>采用各种办法让你的手机关机：</p><ol><li>音量加和电源键不松，强制关机</li><li>可以进recovery的话到rec关机也行</li><li>可以连接fastboot的话，从命令行fastboot restart recovery，然后再到rec关机</li></ol><p>反正从上面的方法找到一个可以关机的</p><p>关机以后，解压下载的9008线刷包，里面有一个<code>MsmDownloadTool V4.0.exe</code></p><p>打开，选择other然后login进入界面</p><p>界面里面，取消勾选sha256chesum、target选择H2（或者O2）</p><p>手机<strong>断开连接</strong>的情况下，按住音量上下不松手，然后接入电脑</p><p>这时软件里面会显示串口连接，这时候点击start，然后再松手</p><p>然后就会自动救砖，等待自动进入新系统就行</p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一加8T提取image底包 &amp; namelssOS刷氧OS13踩坑</title>
      <link href="/2022/12/24/oneplus8T-extract-base-package/"/>
      <url>/2022/12/24/oneplus8T-extract-base-package/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前因为不满ColorOS的臃肿刷入了原生的nameless A13：<a href="https://blog-boulevard.top/2022/12/19/一加8t刷入namelessos/">一加8T刷入namelessOS | Boulevard’s Blog (blog-boulevard.top)</a></p><p>但是nameless的功能实在太少，bug实在太多，堪比从MI10搬运过来的MIUI13包。所以继续折腾一下，从nameless A13刷入到大氢的亲兄弟——国外测试已经更新到了安卓13的OxygenOS</p><p><strong>附：一加8系，9R，9RT，10R的OxygenOS13 Full OTA包地址</strong><a href="https://www.xda-developers.com/oneplus-8-series-9r-9rt-10r-oxygenos-13-stable/">Stable Android 13 update rolls out to the OnePlus 8 series and more (xda-developers.com)</a></p><h2 id="提取images"><a href="#提取images" class="headerlink" title="提取images"></a>提取images</h2><p>一加8T的底层可能比较多样化（低情商：混乱）。刷系统ROM包之前，如果你搞不清现在的系统底层和目标系统的底层是否是一致的，最好先刷入目标系统的四个img文件<code>boot.img,vbmeta.img,vbmeta_system.img,recovery.img</code></p><p>良心的安装包提供者会把这四个文件的下载连接也给你，当然如果他没给的话，也可以从Full OTA包里面提取出来，只需要<strong>payload dumper</strong>这个工具。</p><p>首先下载payload dumper，这个工具有Go和Py的源码可以自己build，但是懒人还是选择大佬做好了的exe包，点击即可使用：<a href="https://yun.daxiaamu.com/files/tool/payload.bin解包工具/payload dumper_go_大侠阿木重制/">tool/payload.bin解包工具/payload dumper<em>go</em>大侠阿木重制 - 其他文件 - 一加手机官方ROM下载 (daxiaamu.com)</a></p><p>下载好以后，解压Full OTA的zip包，可以看到一个payload.bin文件，把这个文件图标拖动到payload dumper图标上就会自动出现一个终端黑框，开始提取。提取完毕以后，会在payload.bin同目录下出现一个extraced_xxx文件夹，点进去就可以看到很多img文件，从中找到我们需要的四个image即可。</p><p><img src="/images/8T/image-20221224092710542.png" alt="image-20221224092710542"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>虽然提取img是成功的，但是从一个第三方刷到OOS13对我来说还是有点困难了，在刷入四个image以后再从recovery sideload失败变砖了</p><p>然后就只好开始9008救砖会H2OS，再从H2OS卡刷回OOS</p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一加8T刷入namelessOS</title>
      <link href="/2022/12/19/oneplus8T-namelessOS/"/>
      <url>/2022/12/19/oneplus8T-namelessOS/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>一台一加8/9手机（废话）</p><ul><li>本教程使用一加8T、ColorOS13</li></ul></li><li><p><a href="https://nameless.wiki/category/download">Download | Nameless AOSP</a>下载如下软件：</p><ul><li><p>最新刷机包：</p><p><img src="/images/oneplusnameless/image-20221219110803199.png" alt="image-20221219110803199"></p></li><li><p>四个image镜像：</p><p><img src="/images/oneplusnameless/image-20221219110826171.png" alt="image-20221219110826171"></p></li></ul></li><li><p><a href="https://nameless.wiki/getting-started/install/for_8_9R">For OnePlus 8/8 Pro &amp; 8T/9R | Nameless AOSP</a>下载工具：</p><ul><li><p>platform-tools：</p><p><img src="/images/oneplusnameless/image-20221219111008416.png" alt="image-20221219111008416"></p></li><li><p>Google USB driver：</p><p><img src="/images/oneplusnameless/image-20221219111028900.png" alt="image-20221219111028900"></p></li></ul></li></ul><h2 id="系统内解锁"><a href="#系统内解锁" class="headerlink" title="系统内解锁"></a>系统内解锁</h2><p>下面的操作在手机系统内完成：</p><h3 id="解锁开发者模式"><a href="#解锁开发者模式" class="headerlink" title="解锁开发者模式"></a>解锁开发者模式</h3><p>设置-关于本机-版本信息，快速连续点击十次版本号，然后就会提示输入锁屏密码进入开发者模式</p><p><img src="/images/oneplusnameless/50e68c266b5449ff106a54535127cf3.jpg" alt="50e68c266b5449ff106a54535127cf3"></p><h3 id="开启USB调试与OEM解锁"><a href="#开启USB调试与OEM解锁" class="headerlink" title="开启USB调试与OEM解锁"></a>开启USB调试与OEM解锁</h3><p>打开了开发者模式中，可以在设置-系统设置中找到开发者选项，开启其中的OEM解锁和USB调试：</p><p><img src="/images/oneplusnameless/7cda331d6b562b1b9ad338d2ff14b6c.jpg" alt="7cda331d6b562b1b9ad338d2ff14b6c"></p><h2 id="解锁Bootloader"><a href="#解锁Bootloader" class="headerlink" title="解锁Bootloader"></a>解锁Bootloader</h2><p><strong>注意：解锁BL会格式化手机、做好备份</strong></p><p>手机开机状态下连接电脑，会弹出USB调试信息，同意即可。</p><p>在之前下载的platform-tools文件夹打开命令行，输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./adb.exe devices</span><br></pre></td></tr></table></figure><p>就可以看到设备了：</p><p><img src="/images/oneplusnameless/image-20221219112346386.png" alt="image-20221219112346386"></p><p>然后输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./adb.exe reboot bootloader</span><br></pre></td></tr></table></figure><p>这时手机会自动重启到这个界面（图是网上随便找的）：</p><p><img src="/images/oneplusnameless/image-20221219112200025.png" alt="image-20221219112200025"></p><p>然后输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fastboot.exe flashing unlock</span><br></pre></td></tr></table></figure><p>你的手机会提示你是否要解锁bl：</p><p><img src="/images/oneplusnameless/image-20221219112628704.png" alt="image-20221219112628704"></p><p>按音量上下可以选择，选第二个，然后按电源键确认。</p><p>然后手机格式化并解锁BL，等待一会以后，重新进入系统。</p><p>由于系统被格式化了，所以需要重复第一步打开USB调试和OEM解锁。</p><h2 id="刷入四个image"><a href="#刷入四个image" class="headerlink" title="刷入四个image"></a>刷入四个image</h2><p>在plateform-tools目录下使用cmd（注意是cmd命令提示符，而不是windows powershell）</p><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb.exe reboot fastboot</span><br></pre></td></tr></table></figure><p>手机会进入fastboot模式：</p><p><img src="/images/oneplusnameless/image-20221219115434920.png" alt="image-20221219115434920"></p><p>把四个img文件放入到platform-tools/images文件夹，然后依次执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash boot images/boot.img</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash --disable-verity --disable-verification vbmeta images/vbmeta.img</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash --disable-verity --disable-verification vbmeta_system images/vbmeta_system.img</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash recovery images/recovery.img</span><br></pre></td></tr></table></figure><p><img src="/images/oneplusnameless/image-20221219113849951.png" alt="image-20221219113849951"></p><h2 id="刷入系统"><a href="#刷入系统" class="headerlink" title="刷入系统"></a>刷入系统</h2><p>上一步四个image都刷入完毕以后，在手机上选择：高级-重启到恢复模式：</p><p>然后如图所示手机会进入恢复模式（注意恢复模式是可以直接触屏操作的哦）：</p><p><img src="/images/oneplusnameless/image-20221219115529504.png" alt="image-20221219115529504"></p><p>选择Install update - ADB Sideload</p><p>然后把刷机包的zip文件也放到platform-tools文件夹，cmd输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb sideload 刷机包名字.zip</span><br></pre></td></tr></table></figure><p>然后你的手机就会开始刷入新系统了…</p><p><img src="/images/oneplusnameless/image-20221219114930221.png" alt="image-20221219114930221"></p><h2 id="刷入完毕"><a href="#刷入完毕" class="headerlink" title="刷入完毕"></a>刷入完毕</h2><p>上面的windows进度条会有一些bug，刷入完成后进度条大概只在50%左右</p><p>所以以手机显示的进度为准，完成时如下图，手机最下面会有一个Step2/2：</p><p><img src="/images/oneplusnameless/image-20221219115635311.png" alt="image-20221219115635311"></p><p>然后点击左上角的返回键，回到recovery首页，选择”Factory reset”-&gt;”Format data/factory reset”-&gt;”Format data”</p><p>然后Format data结束以后，返回到recovery首页点击reboot to system就可以进入新系统了。</p><p><img src="/images/oneplusnameless/image-20221219115943950.png" alt="image-20221219115943950"></p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX语法支持教程</title>
      <link href="/2022/12/07/hexo-latex-support/"/>
      <url>/2022/12/07/hexo-latex-support/</url>
      
        <content type="html"><![CDATA[<h2 id="教程来源"><a href="#教程来源" class="headerlink" title="教程来源"></a>教程来源</h2><p>主要参考<a href="https://blog.csdn.net/crazy_scott/article/details/79293576">(98条消息) hexo下LaTeX无法显示的解决方案_zealscott的博客-CSDN博客</a></p><p>略有不同，主要在主题的_config.yml</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>首先需要安装mathjax：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math -save</span><br></pre></td></tr></table></figure><p>然后需要把hexo默认的md渲染引擎<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>换成<a href="https://github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uinstall hexo-renderer-marked -save</span><br><span class="line">npm install hexo-renderer-kramed -save</span><br></pre></td></tr></table></figure><h2 id="修改转义"><a href="#修改转义" class="headerlink" title="修改转义"></a>修改转义</h2><p>LaTeX与markdown语法有语义冲突，在markdown中，斜体和加粗可以用*或者_表示，在这里我们修改变量，将_用于LaTeX，而使用*表示markdown中的斜体和加粗</p><p>找到博客下<code>node_modules\kramed\lib\rules\inline.js</code>修改如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>原文中说需要找到主题下的<code>_config.yml</code>修改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><p>但是我用的<code>Chic</code>主题，进去以后发现<code>config.yml</code>有关部分是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plugin functions</span></span><br><span class="line"><span class="comment">## Mathjax: Math Formula Support</span></span><br><span class="line"><span class="comment">## https://www.mathjax.org</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">import:</span> <span class="string">demand</span> <span class="comment"># global or demand</span></span><br><span class="line">  <span class="comment">## global: all pages will load mathjax,this will degrade performance and some grammers may be parsed wrong.</span></span><br><span class="line">  <span class="comment">## demand: Recommend option,if your post need fomula, you can declare &#x27;mathjax: true&#x27; in Front-matter</span></span><br></pre></td></tr></table></figure><p>就没修改了</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在博客开头加上 <code>mathjax: true</code></p><p>然后测试效果如下：</p><p>$\Sigma _0 ^n \frac{1}{n}$</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何制作更好看的客制化PCB及其渲染图</title>
      <link href="/2022/11/11/prettier-pcb/"/>
      <url>/2022/11/11/prettier-pcb/</url>
      
        <content type="html"><![CDATA[<h2 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h2><p>键盘的PCB与其他电子元器件里面的PCB有所不同，需要一些颜值和声音（玄学）上的改变来吸引顾客，其中最著名的就是owlab的suit、spring系列pcb：黑芯，沉金，漏线。同时还有IRIS65等pcb采用黑芯，线路单独上颜色的pcb。</p><p>最近这几天没有继续折腾pcb代码功能了，试一试这些奇奇怪怪的东西，当然目前还没有合适的板子（和钱）去打样。</p><h2 id="PCB基本介绍"><a href="#PCB基本介绍" class="headerlink" title="PCB基本介绍"></a>PCB基本介绍</h2><p>要知道各种PCB的效果是怎么做的，就需要首先知道PCB的基本结构和其中的一些术语。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>对于键盘的FR-4双层板来说，我们可以这样理解其结构：</p><p>PCB的<strong>基础（core）是一张FR-4板</strong>（通常是黄白色的，很丑，但也有黑色磨砂质感的，很贵），在这个线路上，会<strong>蚀刻一层铜（copper）</strong>，是你画的线路和焊盘。然后，为了保护线路，pcb最上层还会有一层<strong>阻焊（solder）</strong>，可以理解成一层油漆，也就是导致pcb出现黑白绿等多种不同颜色的东西。当然，焊盘是不能被阻焊覆盖，要露出来焊东西的，这种给阻焊留空的工艺我们叫做<strong>开窗</strong>。</p><p>所以简单理解，<strong>PCB从里到外就是这三层结构：FR-4基板、铜线路、阻焊</strong>。</p><h3 id="铺铜"><a href="#铺铜" class="headerlink" title="铺铜"></a>铺铜</h3><p>所以铺铜，其实是一种另类的走线，铺铜一般用在GND线路上面，增加接地性能。在链接完出了GND的所有线路之后，还会剩下很多空位置是没有走线的，这时候我们就可以用铺铜把这些位置用铜填起来，并给将其作为一大块GND线路连接各个GND焊盘。</p><h2 id="不同类型PCB方案分析"><a href="#不同类型PCB方案分析" class="headerlink" title="不同类型PCB方案分析"></a>不同类型PCB方案分析</h2><h3 id="黑色-漏线（owlab）"><a href="#黑色-漏线（owlab）" class="headerlink" title="黑色 漏线（owlab）"></a>黑色 漏线（owlab）</h3><p>最经典的spring、suit80的pcb样式，线是铜色的（而不是金色，这个线路的颜色和焊盘沉金的颜色是不一样的，这个线路更偏红），板材是黑色的。</p><p>其思路为：</p><ul><li>不铺铜，GND也用走线连接（不过一般GND、VCC走线会稍微宽一点）</li><li>透明阻焊</li><li>黑芯板材</li></ul><p>不铺铜的原因很简单，露出来一大块一大块的铜太丑了</p><p>所以要制造这种pcb，主要是对工厂要求高：黑芯板材、透明阻焊</p><p>目前找到能做这两种的只有猎板网</p><p><img src="/images/pretty-pcb/image-20221112095259973.png" alt="image-20221112095259973"></p><h3 id="白色-漏线"><a href="#白色-漏线" class="headerlink" title="白色 漏线"></a>白色 漏线</h3><p>观感效果与上面的类似，都是露出了金色的走线，但是实际上设计思路很不一样</p><p>之前我们提到过，阻焊是可以开窗的，而正常情况下只有需要焊接的焊盘是露出来的。而这张PCB不一样，他给导线也开窗了，也就是说导线上面是没有阻焊的。</p><p>这个<strong>操作很简单</strong>，在立创eda就可以完成：点一下导线，右边的属性栏中会有一个开窗选项，点一下就给你的导线开窗了。</p><p>仔细对比可以发现，这张板子的导线和上面ow板子的导线都是金色的，但是色调却不一样：ow板子的是偏红的铜色、这一张板子其实是和沉金焊盘一样的灿金色。</p><p>铜裸露出来很容易氧化，所以实际上这个板子漏的线上面还沉金保护了。</p><p><strong>不推荐这种设计</strong>：裸露的导线容易被短接出问题，而且焊接的时候一不小心沾了一点锡到导线上面就真的寄了。如果非要用这种设计的话，请<strong>只给按键矩阵的走线开窗</strong>，其他位置的导线为了安全起见不要开窗。</p><p><img src="/images/pretty-pcb/O1CN01VysK0c1UKaY1uTAYH_!!980092499.jpg" alt="img"></p><h3 id="黑色-彩色走线"><a href="#黑色-彩色走线" class="headerlink" title="黑色 彩色走线"></a>黑色 彩色走线</h3><p>最初见到这种PCB是在Iris 65上面</p><p>与owlab的pcb相同的点是在于，都采用黑芯板材并将其露了出来</p><p>不同的点是这张PCB的走线采用了红色阻焊覆盖</p><p>所以这张板子的思路为：</p><ul><li>不铺铜</li><li>黑芯板材</li><li>除导线以外全部开窗</li></ul><p>这张板子的省去了透明阻焊的钱，会比ow那种便宜一些，至于哪个好看就见仁见智了。</p><p><strong>难点</strong>在于，如何只给导线上阻焊，而其他位置全部开窗的。这个操作稍微难一些，在下一节详细介绍。</p><p><img src="/images/pretty-pcb/image-20221112100202737.png" alt="image-20221112100202737"></p><h2 id="第三种PCB板子画法教程"><a href="#第三种PCB板子画法教程" class="headerlink" title="第三种PCB板子画法教程"></a>第三种PCB板子画法教程</h2><p>在立创eda中，要么选择导线给他开窗，要么自己到阻焊层画一个区域，这个区域内就开窗了。</p><p>这里提到了<strong>阻焊层</strong>这个概念，这一层是在画pcb时常常被忽略的一层。一般来说，默认给焊盘开窗而其他地方不开，所以阻焊层就没什么人去管了。</p><p>阻焊层是负逻辑的，也就是说，你在阻焊层画了一个形状，这一块就进行开窗了，而没画东西的地方就任然保留阻焊。</p><p>那么要画出Iris65的pcb效果，就要在阻焊层画出所有没有导线的地方的形状。立创eda目前没有区域选择或者反向选择的功能，所以需要手动描摹出导线意外区域的形状，想想给不是给人干的。</p><p>那有没有什么办法，可以自动在没有导线的地方画满呢？答案是<strong>铺铜</strong></p><p>我们需要在线路层，创造一个不属于任何网络（no-net）的铺铜，然后将其转移到阻焊层即可。就这么简单</p><p>但是遗憾的是，立创eda的铺铜不支持创建不属于任意网络的铺铜，所以我们只能求助于其他功能更强大的eda。</p><p>这里我们选择了<strong>Altium Designer</strong>（简称AD），版本使用AD17版本。因为嘉立创的pcb可以导出为AD，而在其官网说明中，导出兼容性最好的是17版本。</p><h3 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h3><h4 id="修改板子大小"><a href="#修改板子大小" class="headerlink" title="修改板子大小"></a>修改板子大小</h4><p>嘉立创导出pcb到ad以后，pcb的边框是比在立创eda中要大的：</p><p><img src="/images/pretty-pcb/image-20221112102949830.png" alt="image-20221112102949830"></p><p>我们需要先修改一下大小，首先删掉立创导出的边框（这个一般会有bug），在下方<strong>切换到Keep-Out Layer</strong>，然后按住P+L在这一层开始画线，画出你想要的边框。</p><p>ad中的<strong>多选</strong>是按住shift不放开，按住shift选中你画的边框。</p><p>然后在<strong>菜单&gt;设计&gt;板子形状</strong>中点击<strong>按选择对象定义</strong>，板子就变小了：</p><p><img src="/images/pretty-pcb/image-20221112103752107.png" alt="image-20221112103752107"></p><h4 id="修改铺铜规则"><a href="#修改铺铜规则" class="headerlink" title="修改铺铜规则"></a>修改铺铜规则</h4><p>铺铜的时候，线路和铺铜之间肯定是有一段距离的，同时太小的地方也不会铺铜。但是我们只是借助铺铜来画开窗的区域，希望是能在没有导线和焊盘的地方全部铺铜，然后再转移到阻焊层。所以需要修改一下铺铜规则：</p><p>参考文章<a href="https://blog.csdn.net/LJin19910205/article/details/80520207">Altium Designer 敷铜间距规则设置<em>lijinaaaaa的博客-CSDN博客</em>覆铜间距</a>，将铺铜间距设为0（或者很小的数）</p><h3 id="创建铺铜"><a href="#创建铺铜" class="headerlink" title="创建铺铜"></a>创建铺铜</h3><p>规则如下：</p><p><img src="/images/pretty-pcb/image-20221112104632422.png" alt="image-20221112104632422"></p><p>创建完以后是这样的：</p><p><img src="/images/pretty-pcb/image-20221112104720008.png" alt="image-20221112104720008"></p><h3 id="转移到阻焊层"><a href="#转移到阻焊层" class="headerlink" title="转移到阻焊层"></a>转移到阻焊层</h3><p>选择铺铜，右键&gt;多边形操作&gt;Explod Selected Polygons to Free Primitives，变成这样：</p><p><img src="/images/pretty-pcb/image-20221112104908031.png" alt="image-20221112104908031"></p><p>把外面不要的红色删掉，选择板子里面的铺铜，右键&gt;查找相似对象，选择同一层，同类型，同网络（No Net）的对象：</p><p><img src="/images/pretty-pcb/image-20221112105042719.png" alt="image-20221112105042719"></p><p>选中以后，修改到阻焊层：</p><p><img src="/images/pretty-pcb/image-20221112105125419.png" alt="image-20221112105125419"></p><p>板子变成了这样：</p><p><img src="/images/pretty-pcb/image-20221112105144999.png" alt="image-20221112105144999"></p><p>到3D模式查看，发现已经成功了：</p><p><img src="/images/pretty-pcb/image-20221112105221245.png" alt="image-20221112105221245"></p><h2 id="AD输出Gerber"><a href="#AD输出Gerber" class="headerlink" title="AD输出Gerber"></a>AD输出Gerber</h2><p>既然已经用AD改板子了，那转回立创EDA再导出Gerber又会多一次风险，倒不如直接导出Gerber。</p><p>这里不再赘述，给出立创官方AD打板的指导<a href="https://www.jlc.com/portal/server_guide_10171.html">技术指导：Altium Designer输出Gerber文件步骤 (jlc.com)</a></p><h2 id="渲染AD-PCB"><a href="#渲染AD-PCB" class="headerlink" title="渲染AD PCB"></a>渲染AD PCB</h2><p>AD自带的3D浏览只是能看级别的，所以顺带学习了一下怎么渲染PCB，这里也是全程跟教程走的，直接给教程了：</p><p><a href="https://www.bilibili.com/video/BV1Aa411U7d1/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">如何快速渲染一个美观的PCB图_哔哩哔哩_bilibili</a></p><p>需要用到KeyShot软件，大概安装包1G多，网上很多破解</p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>APM32键盘开发板の开发记录</title>
      <link href="/2022/10/29/apm32-developer/"/>
      <url>/2022/10/29/apm32-developer/</url>
      
        <content type="html"><![CDATA[<h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><p>本开发板采用<code>apm32f103</code>系列的<code>c8t6</code>或<code>cbt6</code>主控，目的是作为一个QMK固件学习的廉价开发板，其基本情况：</p><p>开发板外观如下</p><p><img src="/images/apm32dvlp/8f71e3499f27e378391ac2a1cbdc555.jpg" alt="8f71e3499f27e378391ac2a1cbdc555"></p><h3 id="关于主控"><a href="#关于主控" class="headerlink" title="关于主控"></a>关于主控</h3><p>主控方面，有四个选择：<code>stm32/apm32 f103 c8t6/cbt6</code></p><p>apm32是stm32的国产版，软硬件都兼容，也就是说在设计电路和写固件的时候直接按stm32弄就行。</p><p>c8t6和cbt6的区别主要是flash大小，也就是最大支持的固件大小，其中c8t6为<code>64k</code>、cbt6为<code>128k</code>，目前而言两者价格差别很小，所以建议选择后者。</p><p>文章使用的是<code>apm32 f103 cbt6</code></p><h3 id="关于电路设计"><a href="#关于电路设计" class="headerlink" title="关于电路设计"></a>关于电路设计</h3><p>电路分为两个部分，左边是apm32开发板，包含1个apm32键盘最小系统、9个按键、1个旋钮、2个插线母座。</p><p>其中apm32开发板的硬件设计参考苏达酱的apm32最小系统板：</p><p>b站教程：<a href="https://www.bilibili.com/video/BV1FV4y1K7mm/?spm_id_from=333.788&amp;vd_source=a42d90bcf7fcd7bedcf7188f6b5545c7">【苏达】还在用32u4？该换apm啦！apm主控键盘教程第一期（前期准备）_哔哩哔哩_bilibili</a></p><p>立创开源工程：<a href="https://oshwhub.com/nimrodlord/apm32-jian-pan-zui-xiao-ji-tong">apm32键盘最小系统 - 嘉立创EDA开源硬件平台 (oshwhub.com)</a></p><p>在此基础上，添加了按键和旋钮，将一部分无用的引脚引出连接插线段子，便于后续功能开发。</p><p>右边的usb hub部分基本与该开源工程一致<a href="https://oshwhub.com/apana/usbhub">【已验证】USB拓展坞 USB集线器 USBHub - 嘉立创EDA开源硬件平台 (oshwhub.com)</a></p><p>该项目只用了SL2.1A芯片，支持四个USB 2.1输入，本项目只是在其基础上，去掉了一个USB输入，将其换成了一个FFP连接器，然后在开发板的Type-C输出也接入到另一个FFP连接器上，可以通过一根FFP软排线将左侧的开发板接入到右侧的HUB。</p><h3 id="关于固件"><a href="#关于固件" class="headerlink" title="关于固件"></a>关于固件</h3><p>基础固件参考了上述苏达的教程以及<a href="https://www.bilibili.com/video/BV1pt4y1a7dG/?spm_id_from=333.880.my_history.page.click">【QMK教程】从配置编译环境到实现RBG矩阵灯效 OLED屏幕动画 旋钮编码器功能 VIA改键 ARM移植的详细大教学，看完就会写QMK固件_哔哩哔哩_bilibili</a>。</p><p>基础固件与之前的博客<a href="https://blog-boulevard.top/2022/10/24/qmk-vial/">QMK编译+Vial在线改键功能 | Boulevard’s Blog (blog-boulevard.top)</a>基本类似，只是更改了主控有关。</p><h2 id="Bootloader烧录"><a href="#Bootloader烧录" class="headerlink" title="Bootloader烧录"></a>Bootloader烧录</h2><p>apm32出厂是不带dfu的，也就是说不能和Atmega32u4一样，焊接好板子以后连上USB即可使用qmk工具箱烧录。apm32和stm32都需要刷写好bootloader以后才能够用usb连接qmk工具箱烧录固件。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>烧录器：支持对Arm Cortex M3设备进行SWD接口烧录的烧录器，ST-Link、CMSIS-DAP即可。我使用的是猛龙电子的CMSIS-DAP v2。</li><li>Keil5：软件方面，使用Keil进行烧录。Keil是常用的单片机开发软件，下载和安装都非常傻瓜。</li></ol><h3 id="Bootloader准备"><a href="#Bootloader准备" class="headerlink" title="Bootloader准备"></a>Bootloader准备</h3><p>使用苏达视频中提供的BL，不过需要注意的是，keil只支持hex文件，苏达群里的是bin文件，需要进行转换。</p><h3 id="Keil配置"><a href="#Keil配置" class="headerlink" title="Keil配置"></a>Keil配置</h3><h4 id="下载Apm32设备包"><a href="#下载Apm32设备包" class="headerlink" title="下载Apm32设备包"></a>下载Apm32设备包</h4><p>在Keil官网的包下载页面<a href="https://www.keil.com/dd2/pack/#!#eula-container">MDK5 Software Packs (keil.com)</a> &gt; APEXMIC &gt; APEX Microelectronics APM32F1软件包下载即可：</p><p><img src="/images/apm32dvlp/image-20221029163444442.png" alt="image-20221029163444442"></p><h4 id="导入包到Keil"><a href="#导入包到Keil" class="headerlink" title="导入包到Keil"></a>导入包到Keil</h4><p>打开Keil，打开Pack Installer</p><p><img src="/images/apm32dvlp/1667032525749.png" alt="1667032525749"></p><p>在Pack Installer菜单中找到File&gt;Import，找到上面下载的包导入即可</p><h4 id="配置apm32烧录工程"><a href="#配置apm32烧录工程" class="headerlink" title="配置apm32烧录工程"></a>配置apm32烧录工程</h4><p>新建一个工程，将Bootloader的hex文件放置到工程文件夹中：</p><p><img src="/images/apm32dvlp/image-20221029164114604.png" alt="image-20221029164114604"></p><p>在Keil中，工程会有一个Target1：</p><p><img src="/images/apm32dvlp/image-20221029164202675.png" alt="image-20221029164202675"></p><p>右键第一个，设置：</p><p>在Device中选择到对应的芯片</p><p><img src="/images/apm32dvlp/image-20221029164235505.png" alt="image-20221029164235505"></p><p>在Output中，把Name of Executable改为BL的hex文件：</p><p><img src="/images/apm32dvlp/image-20221029164313095.png" alt="image-20221029164313095"></p><p>再Device中选择你的烧录器，我这里选择CMSIS-DAP Debugger：</p><p><img src="/images/apm32dvlp/image-20221029164424713.png" alt="image-20221029164424713"></p><p>然后在烧录器右边的Settings中继续设置烧录器：</p><p>在Debug中，选择你的CMSIS-DAP版本，这里我选择CMSIS-DAP v2；然后在Flash Download中设置如下，注意Programming Algorithm需要选择你芯片对应的，如果没有需要点Add加进来：</p><p><img src="/images/apm32dvlp/image-20221029164602341.png" alt="image-20221029164602341"></p><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>在上述的Keil工程配置完毕以后，将烧录器连接好开发板的SWD接口，点击LOAD即可：</p><p><img src="/images/apm32dvlp/image-20221029164735953.png" alt="image-20221029164735953"></p><h3 id="固件烧录"><a href="#固件烧录" class="headerlink" title="固件烧录"></a>固件烧录</h3><p>在Bootloader烧录好以后，插上开发板的type-c，在<code>设备管理器&gt;通用串行总线设备</code>中会看到一个<code>Maple 003</code>的设备，就说明上面的BL烧录没有问题了。</p><p>打开QMK Toolbox，可以看到设备已经被识别了，后续就可以和32u4一样，用QMK工具箱烧录QMK键盘固件了：</p><p><img src="/images/apm32dvlp/image-20221029165051241.png" alt="image-20221029165051241"></p><h2 id="固件开发过程"><a href="#固件开发过程" class="headerlink" title="固件开发过程"></a>固件开发过程</h2><h3 id="rev0"><a href="#rev0" class="headerlink" title="rev0"></a>rev0</h3><h4 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h4><p>rev0是一个<strong>最基础的验证MCU电路的版本，只验证了键盘功能</strong></p><p>最基础的版本参考我的博客：<a href="https://blog-boulevard.top/2022/10/24/qmk-vial/">QMK编译+Vial在线改键功能 | Boulevard’s Blog (blog-boulevard.top)</a></p><p>下面只描写apm32版本与atmega32u4版本不同的地方</p><h4 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h4><p><img src="/images/apm32dvlp/image-20221029165533531.png" alt="image-20221029165533531"></p><p>工程结构如下，对比32u4版本，只多了<code>chconf.h</code>、<code>halconf.h</code>、<code>mcuconf.h</code>三个文件，下面一一说明每个文件修改之处。</p><h4 id="keymap、键盘名-c、键盘名-h、config-h"><a href="#keymap、键盘名-c、键盘名-h、config-h" class="headerlink" title="keymap、键盘名.c、键盘名.h、config.h"></a>keymap、键盘名.c、键盘名.h、config.h</h4><p>这三个文件不变，和32u4完全一样</p><h4 id="chconf-h"><a href="#chconf-h" class="headerlink" title="chconf.h"></a>chconf.h</h4><p>照抄就行，不知道干啥的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CH_CFG_ST_TIMEDELTA 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CH_CFG_USE_CONDVARS_TIMEOUT FALSE</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;chconf.h&gt;</span><br></pre></td></tr></table></figure><h4 id="halconf-h"><a href="#halconf-h" class="headerlink" title="halconf.h"></a>halconf.h</h4><p>第一行和最后一行照抄，中间两行是启用SPI和PWM总线，普通的键盘功能可以不需要。后续可能需要修改，比如OLED需要使用I2C总线。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define HAL_USE_PWM TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define HAL_USE_SPI TRUE</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;halconf.h&gt;</span><br></pre></td></tr></table></figure><h4 id="mcuconf-h"><a href="#mcuconf-h" class="headerlink" title="mcuconf.h"></a>mcuconf.h</h4><p>暂时也只需要照抄，需要和上面规定的总线对应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;mcuconf.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #undef STM32_PWM_USE_TIM1</span></span><br><span class="line"><span class="comment">// #define STM32_PWM_USE_TIM1 TRUE</span></span><br></pre></td></tr></table></figure><h4 id="rules-mk"><a href="#rules-mk" class="headerlink" title="rules.mk"></a>rules.mk</h4><p>MCU和BL类型改为STM32对应的，下面这些设置在上次的博客已经说明了，一样。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MCU name</span></span><br><span class="line">MCU = STM32F103</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bootloader selection</span></span><br><span class="line">BOOTLOADER = stm32duino</span><br><span class="line"></span><br><span class="line">LTO_ENABLE = yes</span><br><span class="line">BOOTMAGIC_ENABLE ?= yes<span class="comment"># Virtual DIP switch configuration</span></span><br><span class="line">MOUSEKEY_ENABLE ?= no<span class="comment"># Mouse keys</span></span><br><span class="line">EXTRAKEY_ENABLE ?= yes<span class="comment"># Audio control and System control</span></span><br><span class="line">CONSOLE_ENABLE ?= no<span class="comment"># Console for debug</span></span><br><span class="line">COMMAND_ENABLE ?= no    <span class="comment"># Commands for debug and configuration</span></span><br><span class="line">SLEEP_LED_ENABLE ?= no  <span class="comment"># Breathing sleep LED during USB suspend</span></span><br><span class="line">NKRO_ENABLE ?= yes    <span class="comment"># USB Nkey Rollover</span></span><br><span class="line">BACKLIGHT_ENABLE ?= no</span><br><span class="line">RGBLIGHT_ENABLE ?= no</span><br></pre></td></tr></table></figure><h4 id="问题备注"><a href="#问题备注" class="headerlink" title="问题备注"></a>问题备注</h4><p>功能比较简单，没有其他问题，但是reset键不是很灵，不知道是啥原因。所以<strong>在固件中为键盘设置一个reset的组合键</strong>，方便进入BL模式刷机。</p><h3 id="rev0-5"><a href="#rev0-5" class="headerlink" title="rev0.5"></a>rev0.5</h3><h4 id="版本说明-1"><a href="#版本说明-1" class="headerlink" title="版本说明"></a>版本说明</h4><p>rev0.5是一个添加了旋钮的版本，旋钮还有一些问题没有提及</p><h4 id="代码内容"><a href="#代码内容" class="headerlink" title="代码内容"></a>代码内容</h4><p>这里的代码是不支持vial的，若需要vial旋钮代码，请见博客<a href="https://blog-boulevard.top/2022/10/24/qmk-vial/">QMK编译+Vial在线改键功能 | Boulevard’s Blog (blog-boulevard.top)</a>。</p><p>添加旋钮需要修改如下内容</p><ol><li>在rules.mk中开启旋钮：</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENCODER_ENABLE = yes</span><br></pre></td></tr></table></figure><ol><li>在config.h中设置旋钮：</li></ol><p>第一二行，显而易见是设置旋钮的A、B脚连接的MCU引脚。</p><p>第三行设置的是ENCODER的分辨率（灵敏度），也就是编码器在每个止动之间记录的脉冲数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Encoder Setting */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODERS_PAD_A &#123; A10 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODERS_PAD_B &#123; A8 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODER_RESOLUTION 4</span></span><br></pre></td></tr></table></figure><ol><li>在keymap.c中定义<code>encoder_update_user</code>：</li></ol><p>分别定义了顺时针，逆时针的键码。注意，如果键码是音量加减等功能，需要把<code>tap_code</code>改为<code>tap_code(KC_COLU, 10)</code>这样。同时需要在<code>rules.mk</code>里面开启<code>EXTRAKEY_ENABLE = yes</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">encoder_update_user</span><span class="params">(<span class="type">uint8_t</span> index, <span class="type">bool</span> clockwise)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (clockwise) &#123;</span><br><span class="line">        tap_code(KC_1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tap_code(KC_2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题备注-1"><a href="#问题备注-1" class="headerlink" title="问题备注"></a>问题备注</h4><p>有一个很奇怪的BUG，在我的电路设计中，我将旋钮的上面两个脚当作轴体接到了ROW0, COL3，将下面的A、B脚接到了主控的B0, B1脚。然而在排除旋钮、固件本身问题的情况以后，无论是按下还是旋转都没有反应，将旋钮上面两个脚飞线到ROW0,COL0以后就可以触发这个键。</p><p>在DEBUG很久以后，还是没有效果，于是我将另一个旋钮的A、B脚接到主控的A8、A9，C接地，其他不接。这个旋钮就可以正常工作了。</p><p>目前还未找到原因，旋钮本身是可以用的。不知道是MCU这两个脚的原因还是电路设计的原因，有空再去排除。</p><h5 id="2022·11·12更新"><a href="#2022·11·12更新" class="headerlink" title="2022·11·12更新"></a>2022·11·12更新</h5><p>除了把旋钮接到了A8A9，按下的两个脚也飞线到了轴座焊盘上面，仍然可以用</p><h3 id="rev1"><a href="#rev1" class="headerlink" title="rev1"></a>rev1</h3><h4 id="版本说明-2"><a href="#版本说明-2" class="headerlink" title="版本说明"></a>版本说明</h4><p>rev1主要是写了OLED屏幕的demo，屏幕为128*32分辨率的SSD1306驱动OLED。</p><h4 id="I2C基础"><a href="#I2C基础" class="headerlink" title="I2C基础"></a>I2C基础</h4><p>OLED屏幕需要<strong>开启I2C总线</strong>，下面简介一下I2C的一些基础知识。</p><p>使用I2C的OLED屏幕有四个脚：VCC、GND、SCL(有的叫SCK，都是SClock的意思)、SDA。</p><p>其中VCC理论上接入3.3V和5V都可以，但是为了避免烧掉，还是建议接3.3V。GND不必多说，接地。</p><p>SCL和SPA是I2C的两个脚，直接连接到MCU，但是需要注意的是这两个脚不能够随便接，需要<strong>查阅主控说明书</strong>，查看其<strong>支持I2C的脚</strong>。</p><p>一般而言，一个MCU可以有多对I2C的脚记为I2C1、I2C2…。<strong>对于APM32F103而言，我们使用其I2C1，其SCL为B6、SDA为B7</strong>。</p><h4 id="代码内容-1"><a href="#代码内容-1" class="headerlink" title="代码内容"></a>代码内容</h4><h5 id="开启I2C"><a href="#开启I2C" class="headerlink" title="开启I2C"></a>开启I2C</h5><p>需要在与芯片相关的文件中开启I2C：</p><p><code>chconf.h</code>不需要修改。</p><p><code>halconf.h</code>需要开启I2C：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;halconf.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HAL_USE_I2C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_USE_I2C TRUE</span></span><br></pre></td></tr></table></figure><p><code>mcuconf.h</code>则需要选择I2C使用I2C1这根：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">#include_next &lt;mcuconf.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STM32_I2C_USE_I2C1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STM32_I2C_USE_I2C1 TRUE</span></span><br></pre></td></tr></table></figure><h5 id="设置I2C参数，OLED参数"><a href="#设置I2C参数，OLED参数" class="headerlink" title="设置I2C参数，OLED参数"></a>设置I2C参数，OLED参数</h5><p>在<code>config.h</code>中加入如下：</p><p>第一行，开启I2CD1。对应的还有I2CD2，这是I2C的两个版本v1、v2。其选择与主控型号有关，在qmk官方文档中给出了，常用的STM32 F1X F3X系列都是I2Cv1。</p><p>后面四行，设置I2C1的时钟速率、第二个我也不知道、后面两个是I2C1的两个Pin，前面说了是B6/B7（注意别写反）</p><p>最后五行，设置OLED的亮度，超时时间，滚动时间等显示参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_DRIVER I2CD1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C1_CLOCK_SPEED 400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C1_DUTY_CYCLE FAST_DUTY_CYCLE_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C1_SCL_PIN B6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C1_SDA_PIN B7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_BRIGHTNESS 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_TIMEOUT 80000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_FADE_OUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_FADE_OUT_INTERVAL 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SCROLL_TIMEOUT 40000</span></span><br></pre></td></tr></table></figure><h5 id="内容代码"><a href="#内容代码" class="headerlink" title="内容代码"></a>内容代码</h5><p>内容代码主要在keymap.c的函数<code>oled_task_user()</code>中：</p><p>下面这个实例是官方给的显示文字的实例，内容比较简单，显示不出汉字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OLED_ENABLE</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">oled_task_user</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Host Keyboard Layer Status</span></span><br><span class="line">    oled_write_P(PSTR(<span class="string">&quot;Layer: &quot;</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (get_highest_layer(layer_state)) &#123;</span><br><span class="line">        <span class="keyword">case</span> _HOME:</span><br><span class="line">            oled_write_P(PSTR(<span class="string">&quot;HOME\n&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> _FN2:</span><br><span class="line">            oled_write_P(PSTR(<span class="string">&quot;FN\n&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Or use the write_ln shortcut over adding &#x27;\n&#x27; to the end of your string</span></span><br><span class="line">            oled_write_ln_P(PSTR(<span class="string">&quot;Undefined&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Host Keyboard LED Status</span></span><br><span class="line">    <span class="type">led_t</span> led_state = host_keyboard_led_state();</span><br><span class="line">    oled_write_P(led_state.num_lock ? PSTR(<span class="string">&quot;NUM &quot;</span>) : PSTR(<span class="string">&quot;    &quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    oled_write_P(led_state.caps_lock ? PSTR(<span class="string">&quot;CAP &quot;</span>) : PSTR(<span class="string">&quot;    &quot;</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    oled_write_P(PSTR(<span class="string">&quot;\n\nCCRzzz(- -)&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>下面这个是显示LOGO的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">oled_task_user</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> PROGMEM qmk_logo[] = &#123;</span><br><span class="line">            <span class="number">0x80</span>, <span class="number">0x81</span>, <span class="number">0x82</span>, <span class="number">0x83</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x86</span>, <span class="number">0x87</span>, <span class="number">0x88</span>, <span class="number">0x89</span>, <span class="number">0x8A</span>, <span class="number">0x8B</span>, <span class="number">0x8C</span>, <span class="number">0x8D</span>, <span class="number">0x8E</span>, <span class="number">0x8F</span>, <span class="number">0x90</span>, <span class="number">0x91</span>, <span class="number">0x92</span>, <span class="number">0x93</span>, <span class="number">0x94</span>,</span><br><span class="line">            <span class="number">0xA0</span>, <span class="number">0xA1</span>, <span class="number">0xA2</span>, <span class="number">0xA3</span>, <span class="number">0xA4</span>, <span class="number">0xA5</span>, <span class="number">0xA6</span>, <span class="number">0xA7</span>, <span class="number">0xA8</span>, <span class="number">0xA9</span>, <span class="number">0xAA</span>, <span class="number">0xAB</span>, <span class="number">0xAC</span>, <span class="number">0xAD</span>, <span class="number">0xAE</span>, <span class="number">0xAF</span>, <span class="number">0xB0</span>, <span class="number">0xB1</span>, <span class="number">0xB2</span>, <span class="number">0xB3</span>, <span class="number">0xB4</span>,</span><br><span class="line">            <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0xC2</span>, <span class="number">0xC3</span>, <span class="number">0xC4</span>, <span class="number">0xC5</span>, <span class="number">0xC6</span>, <span class="number">0xC7</span>, <span class="number">0xC8</span>, <span class="number">0xC9</span>, <span class="number">0xCA</span>, <span class="number">0xCB</span>, <span class="number">0xCC</span>, <span class="number">0xCD</span>, <span class="number">0xCE</span>, <span class="number">0xCF</span>, <span class="number">0xD0</span>, <span class="number">0xD1</span>, <span class="number">0xD2</span>, <span class="number">0xD3</span>, <span class="number">0xD4</span>, <span class="number">0x00</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    oled_write_P(qmk_logo, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们可以在keymap.c同级文件夹中定义一个.h文件，在其中定义多个render_xxx函数显示不同内容，然后在keymap.c中include这个文件并进行逻辑调用，如在默认层和FN层显示不同内容，调用不同函数等。</p><h4 id="问题备注-2"><a href="#问题备注-2" class="headerlink" title="问题备注"></a>问题备注</h4><p>播放动画时，需要把每一帧都存到Flash中，再加上可能的Vial等功能，很容易导致固件大小超出B8T6的Flash大小（64k），但是却小于CBT6的Flash（128k）。</p><p>但是我们在rules.mk定义MCU的时候，只填了<code>MCU = STM32F103</code>，并未标注MCU为什么版本，所以默认认为其是C8T6，导致固件超过64K的时候会报错。</p><p>所以需要把C8T6改为CBT6：</p><p>在qmk_firmware根目录中，有<code>builddefs</code>这个文件夹，点进去有很多mk文件，需要修改其中的两个：</p><ol><li>bootloader.mk</li></ol><p>找到这个文件的191行，把<code>x8</code>改为<code>xB</code></p><p><img src="/images/apm32dvlp/image-20221101153707975.png" alt="image-20221101153707975"></p><ol><li>mcu_selection.mk</li></ol><p>找到这个文件的第278行，同样<code>x8</code>改为<code>xB</code></p><p><img src="/images/apm32dvlp/image-20221101153800616.png" alt="image-20221101153800616"></p><p>这样的话，固件超过64k而小于128k时就还是可以编译了。当然，由于C8和CB在其他地方时没有区别的，所以不会导致编译出来的小于64k的固件用在C8T6上有问题。</p><h3 id="rev2"><a href="#rev2" class="headerlink" title="rev2"></a>rev2</h3><h4 id="版本说明-3"><a href="#版本说明-3" class="headerlink" title="版本说明"></a>版本说明</h4><p>该版本主要加入了电磁阀，下面说明其软硬件</p><h4 id="外部电路说明"><a href="#外部电路说明" class="headerlink" title="外部电路说明"></a>外部电路说明</h4><p>不借助外部供电，能够用到的最大电压是5V1A的Type-C输出，很明显电流太小不够电磁阀用的，需要用三极管放大电流，这里我采用的是官方给出的TIP120达林顿晶体管。</p><p>网上抄的一段原理，没学过模电的laymen真的看不懂了= =</p><p><img src="/images/apm32dvlp/image-20221102102713479.png" alt="image-20221102102713479"></p><p>QMK官方给的参考电路图<a href="https://cdn-shop.adafruit.com/product-files/412/solenoid_driver.pdf">solenoid_driver (adafruit.com)</a>如下：</p><p><img src="/images/apm32dvlp/image-20221102102128385.png" alt="image-20221102102128385"></p><p>这里，Solenoid Power我们直接选用Type-C的5V电压，除此之外还需要一个TIP120达林顿晶体管（有人说IRF540也可以）、一个1N4004或1N4001或MUR340的整流二极管、一个1K或2.2K的电阻。</p><p>其中TIP120的三级脚定义如下：</p><p><img src="/images/apm32dvlp/image-20221102102937082.png" alt="image-20221102102937082"></p><p>根据官方给出的电路，三个脚分别这样接：</p><p><strong>B(Base级)：</strong>接一个1K/2.2K的电阻，然后接入到主控的一个脚（这里我用A15脚），电阻最终选的是1K。</p><p><strong>C(Collector级)：</strong>接一个1N4001二极管（或上面提到的另外两个），二极管正极（没有杠的一边）接C级。二极管的负极（有杠的一边）接Type-C 5V供电。</p><p><strong>E(Emitter级)：</strong>接地。</p><p><strong>电磁阀：</strong>电磁阀的两根线分别接在1N4001二极管的两端即可。</p><p>最终，焊接好的电路如下：</p><p><img src="/images/apm32dvlp/image-20221102103601649.png" alt="image-20221102103601649"></p><h4 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h4><p><code>rules.mk</code>中开启反馈、添加反馈为电磁阀SOLENOID:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAPTIC_ENABLE = yes</span><br><span class="line">HAPTIC_DRIVER += SOLENOID</span><br></pre></td></tr></table></figure><p>在<code>config.h</code>中加上电磁阀的引脚，使能，时间设置：</p><p>最后一个参数是默认电磁阀的通电时间（单位：ms），我设置的100ms，效果不是很明显，但是不重要，后续可以设置按键自己加减电磁阀通电时间来控制效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SOLENOID_PIN A15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOLENOID_ACTIVE true</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOLENOID_DEFAULT_DWELL 100</span></span><br></pre></td></tr></table></figure><p>在keymap.c中可以添加电磁阀控制有关的键码，我主要使用了四个：</p><p><code>HPT_TOG</code>：开关电磁阀</p><p><code>HPT_FBK</code>：切换触发时机，可以有按下时触发、抬起时触发、按下抬起都触发。</p><p><code>HPT_DWLI</code>：增加通电时间以增加反馈强度</p><p><code>HPT_DWLD</code>：减少反馈强度</p><h4 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h4><p>这里暂时是没有发现BUG的。</p><p>主要的问题是TIP120这个晶体管太大了，而且只有插件型的不能SMT，导致PCB和生产会比较麻烦。</p><p>所以目前想做的是寻找同样功能的贴片三极管、但是因为模电知识不够暂时找不到。</p><h3 id="rev2-5"><a href="#rev2-5" class="headerlink" title="rev2.5"></a>rev2.5</h3><p>添加了<strong>有源</strong>蜂鸣器</p><p><strong>关于有源无源蜂鸣器区别：</strong>有源指带有震荡源，加上电压就会响；无源指没有震荡源，需要加上一个震荡信号驱动。</p><p>软件不需要变，和电磁阀的一样；硬件更简单，把蜂鸣器正级接到MCU，负极接地</p><h3 id="rev3（最终版本）"><a href="#rev3（最终版本）" class="headerlink" title="rev3（最终版本）"></a>rev3（最终版本）</h3><h4 id="版本说明-4"><a href="#版本说明-4" class="headerlink" title="版本说明"></a>版本说明</h4><p>采用了ULN2003A驱动电磁阀，相比TIP120更小</p><p>将与电磁阀共引脚的5v有源蜂鸣器换为使用AUDIO系统控制的无源压电蜂鸣器，单独使用A8引脚控制，做到了与电磁阀独立按键控制</p><h4 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h4><h5 id="电磁阀"><a href="#电磁阀" class="headerlink" title="电磁阀"></a>电磁阀</h5><p>ULN2003A是一种贴片式达林顿晶体管阵列，是在参考有电磁阀的套件（m0110、Sodd65）时发现的，其资料如下</p><p><img src="/images/apm32dvlp/v2-40761f2fc2d5e7df823236032800a417_r.jpg" alt="img"></p><p>uln2003a集成了七个达林顿阵列，可以有七组独立的输入输出。当然，如果一对输入输出带来的电流增益太小，无法驱动你的设备的话，也可以进行串联，即：一个输入信号接入到几个IN脚，负载接到对应的几个out脚。</p><p>网上的电路：</p><p><img src="/images/apm32dvlp/2018041516285477" alt="img"></p><p>按照电路，先用一对达林顿管，发现力度不是很够，电磁阀只有微弱的运动。</p><p>于是一个一个并联尝试，增加到四对达林顿管并联的时候发现效果还可以了。</p><h5 id="压电蜂鸣器"><a href="#压电蜂鸣器" class="headerlink" title="压电蜂鸣器"></a>压电蜂鸣器</h5><p>压电蜂鸣器比较简单，似乎不分正负极，一个接规定的输出引脚（推荐A8）、一个接地即可。</p><h4 id="代码攥写"><a href="#代码攥写" class="headerlink" title="代码攥写"></a>代码攥写</h4><p>电磁阀方面，只是改变了外围电路，代码还是和之前一样。</p><p>蜂鸣器方面，因为期望与电磁阀分开用按键控制，而之前选用的反馈功能是不支持的，所以在qmk官方文档中搜索buzzer关键字的时候，发现了除了反馈功能以外，音频功能（audio）也支持piezo buzzer（压电蜂鸣器）。</p><p>于是就决定使用压电蜂鸣器，并开始攥写其代码。</p><h5 id="DAC与PWM驱动"><a href="#DAC与PWM驱动" class="headerlink" title="DAC与PWM驱动"></a>DAC与PWM驱动</h5><p>压电式蜂鸣器也是一种无源蜂鸣器，需要使用模拟信号驱动，QMK官方给出的两种方式是DAC数模转换与PWM脉冲宽度调制。</p><p>具体是什么不用理解（因为我也不会），只要知道我们需要这两种方式是让单片机输出模拟信号驱动蜂鸣器的方法即可。</p><p>而qmk官方文档提到，stm32f1xx系列是不支持DAC的，所以我们可以选择的就只有PWM模式。</p><p>PWM又分为软件PWM和硬件PWM，具体差别在哪我也没看懂，用硬件PWM就行。</p><p>注意不是每一个脚都支持硬件PWM的，官方给出的是A8脚，我们也使用这个。如果一定要用其他脚的话，需要查看STM32/APM32的datasheet，寻找有TIMx_CHy表示的脚，这表示这个脚使用TIMER X、属于PWM CHANNEL Y。</p><h5 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h5><p>首先需要根据<a href="https://docs.qmk.fm/#/audio_driver?id=pwm-hardware">Audio Driver (qmk.fm)</a>开启PWM，设置TIM1,CHANNEL1（如果用的不是A8，这里需要对应修改）：</p><p><code>halconf.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//halconf.h:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_USE_PWM                 TRUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_USE_PAL                 TRUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_USE_GPT                 TRUE</span></span><br><span class="line">#include_next &lt;halconf.h&gt;</span><br></pre></td></tr></table></figure><p><code>mcuconf.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mcuconf.h:</span></span><br><span class="line">#include_next &lt;mcuconf.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STM32_PWM_USE_TIM1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STM32_PWM_USE_TIM1                  TRUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STM32_GPT_USE_TIM4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STM32_GPT_USE_TIM4                  TRUE</span></span><br></pre></td></tr></table></figure><p><code>config.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//config.h:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUDIO_PIN A8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUDIO_PWM_DRIVER PWMD1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUDIO_PWM_CHANNEL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUDIO_STATE_TIMER GPTD4</span></span><br></pre></td></tr></table></figure><p>然后到<code>rules.mk</code>开启AUDIO、设置驱动方式为pwm硬件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AUDIO_ENABLE = yes</span><br><span class="line">AUDIO_DRIVER = pwm_hardware</span><br></pre></td></tr></table></figure><p>最后，再到<code>config.h</code>加上一行<code>#define AUDIO_CLICKY</code></p><p>AUDIO_CLICKY是指按键的时候发出声音，这正是我们需要的，同时，音频还有很多其他功能，甚至可以放8bit位宽的歌曲，这里就不细说，可以参见qmk官方文档（这个真的很重要）。</p><p>添加几个关于AUDIO_CLICKY的按键：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keymap.c:</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = &#123;</span><br><span class="line"></span><br><span class="line">[_HOME] = LAYOUT(</span><br><span class="line">KC_1, KC_2, KC_3,</span><br><span class="line">KC_4, KC_5, KC_6, </span><br><span class="line">KC_7, KC_8, MO(<span class="number">1</span>)),</span><br><span class="line"></span><br><span class="line">    [_FN2] = LAYOUT(</span><br><span class="line">CLICKY_TOGGLE, HPT_TOG, QK_BOOT,</span><br><span class="line">HPT_FBK, CLICKY_UP, CLICKY_DOWN,  </span><br><span class="line">HPT_DWLI, HPT_DWLD, KC_9),</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>CLICKY_TOGGLE</code>：开关按键声音，这个和旁边的<code>HPT_TOG</code>分开了，自然也就可以独立控制属于AUDIO模块的蜂鸣器和属于Haptic Feedback模块的电磁阀了</p><p><code>CLICKY_UP</code>：按键时蜂鸣器声音频率+，也就是调整PWM波形的频率来提高音调</p><p><code>CLICKY_DOWN</code>：与上一个相反</p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QMK编译+Vial在线改键功能</title>
      <link href="/2022/10/24/QMK-VIAL/"/>
      <url>/2022/10/24/QMK-VIAL/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>QMK MSYS 0.18.0</p><p>环境配置不再赘述，msys集成度较高，git clone不出问题基本上就不会出问题。</p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p><a href="https://kbfirmware.com/">Keyboard Firmware Builder</a>，参考丈二、苏达等人教程，配置好PIN、MAP等，到COMPILE中下载第二项：Download.zip，即可下载源码。</p><p><strong>但是要注意的是，在线固件网站的QMK版本很老，在0.18.0版本中编译不会通过，所以我们只在需要时复制其中的一些代码过去，整体模板并不适用。</strong></p><h2 id="编写基本源码"><a href="#编写基本源码" class="headerlink" title="编写基本源码"></a>编写基本源码</h2><h3 id="QMK基本代码结构"><a href="#QMK基本代码结构" class="headerlink" title="QMK基本代码结构"></a>QMK基本代码结构</h3><p>QMK MSYS的工程默认放置于<code>C:/用户/用户名/qmk_firmware</code>/中，为了方便，记为<code>~</code></p><p><code>~/.build/</code>中存放的是编译输出的固件，<code>~/keyboards/</code>中存储的是各种键盘的源码，主要在这个目录编写代码</p><p>在<code>~/keyboards/键盘名/</code>文件夹中，是该键盘对应的源码，如果你的键盘有多版本的话，可以在文件夹下创建各个版本的文件夹<code>~/keyboards/键盘名/rev_x</code></p><p>进入到qmk工程目录以后，使用<code>qmk compile -kb 键盘名[/rev_x]</code>，即可在keyboards中自动找到并编译</p><p>在一个键盘基本的工程中，存在如下结构：</p><blockquote><p>│  键盘名.c<br>│  键盘名.h<br>│  config.h<br>│  rules.mk<br>│<br>└─keymaps<br>    ├─default<br>            keymap.c</p></blockquote><h2 id="基础文件内容编写"><a href="#基础文件内容编写" class="headerlink" title="基础文件内容编写"></a>基础文件内容编写</h2><h3 id="rules-mk"><a href="#rules-mk" class="headerlink" title="rules.mk"></a>rules.mk</h3><p>规定编译选项：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MCU name</span></span><br><span class="line">MCU = atmega32u4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bootloader selection</span></span><br><span class="line">BOOTLOADER = atmel-dfu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build Options</span></span><br><span class="line"><span class="comment">#   change yes to no to disable</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">LTO_ENABLE = yes</span><br><span class="line">BOOTMAGIC_ENABLE = yes      <span class="comment"># Enable Bootmagic Lite</span></span><br><span class="line">EXTRAKEY_ENABLE = yes       <span class="comment"># Audio control and System control</span></span><br><span class="line">NKRO_ENABLE = yes           <span class="comment"># Enable N-Key Rollover</span></span><br><span class="line"></span><br><span class="line">MOUSEKEY_ENABLE = no        <span class="comment"># Mouse keys</span></span><br><span class="line">CONSOLE_ENABLE = no         <span class="comment"># Console for debug</span></span><br><span class="line">COMMAND_ENABLE = no         <span class="comment"># Commands for debug and configuration</span></span><br><span class="line">BACKLIGHT_ENABLE = no     <span class="comment"># Enable keyboard backlight functionality</span></span><br><span class="line">RGBLIGHT_ENABLE = no      <span class="comment"># Enable keyboard RGB underglow</span></span><br><span class="line">AUDIO_ENABLE = no           <span class="comment"># Audio output</span></span><br></pre></td></tr></table></figure><p>最开始两个MCU和BL选项，本次使用的是最简单的32u4。</p><p>LTO_ENABLE：压缩固件内容，编译时间稍微长一点，编译出来的固件内容小一点，一般开启。</p><p>后面的具体每一个对应什么参见QMK官方文档。</p><h3 id="config-h"><a href="#config-h" class="headerlink" title="config.h"></a>config.h</h3><p>规定键盘基本设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config_common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USB Device descriptor parameter */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VENDOR_ID       0xFEED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRODUCT_ID      0x6060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_VER      0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MANUFACTURER    boulevard</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRODUCT         amx55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* key matrix size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_ROWS 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_COLS 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* key matrix pins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_ROW_PINS &#123; F0, F1, F4, F5, F6 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_COL_PINS &#123; C7, C6, D7, D6, D5, D4, D3, D2, D1, D0, B7, B6 &#125;</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* COL2ROW or ROW2COL */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIODE_DIRECTION ROW2COL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set 0 if debouncing isn&#x27;t needed */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBOUNCE 5</span></span><br></pre></td></tr></table></figure><p>第一二行，照抄</p><p><strong>下面的几行就可以从下载的源码复制过来</strong>，具体定义如下：</p><p>USB Device descriptor parameter：下面的五个Define是USB的ID和名字，自己设置就行</p><p>key matrix size：矩阵的行列数</p><p>key matrix pins：矩阵行、列引脚编号</p><p>DIODE_DIRECTION：二极管方向，写反了会按键没反应。有时候键盘连接显示名称但是按键没反应可以看看这个有没有反。</p><p>DEBOUNCE：消抖次数，一般设置为5就行</p><h3 id="键盘名-h"><a href="#键盘名-h" class="headerlink" title="键盘名.h"></a>键盘名.h</h3><p>定义LAYOUT：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quantum.h&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAYOUT( \</span></span><br><span class="line"><span class="meta">K000, K001, K002, K003, K004, K005, K006, K007, K008, K009, K010, K011, \</span></span><br><span class="line"><span class="meta">K100, K101, K102, K103, K104, K105, K106, K107, K108, K109, K110, K111, \</span></span><br><span class="line"><span class="meta">K200, K201, K202, K203, K204, K205, K206, K207, K208, K209,       K211, \</span></span><br><span class="line"><span class="meta">K300,       K302, K303, K304, K305, K306, K307, K308, K309, K310, K311, \</span></span><br><span class="line"><span class="meta">K400, K401, K402,       K404,       K406,       K408, K409, K410, K411  \</span></span><br><span class="line"><span class="meta">) &#123; \</span></span><br><span class="line"><span class="meta">&#123; K000,  K001,  K002,  K003,  K004,  K005,  K006,  K007,  K008,  K009,  K010,  K011 &#125;, \</span></span><br><span class="line"><span class="meta">&#123; K100,  K101,  K102,  K103,  K104,  K105,  K106,  K107,  K108,  K109,  K110,  K111 &#125;, \</span></span><br><span class="line"><span class="meta">&#123; K200,  K201,  K202,  K203,  K204,  K205,  K206,  K207,  K208,  K209,  KC_NO, K211 &#125;, \</span></span><br><span class="line"><span class="meta">&#123; K300,  KC_NO, K302,  K303,  K304,  K305,  K306,  K307,  K308,  K309,  K310,  K311 &#125;, \</span></span><br><span class="line"><span class="meta">&#123; K400,  K401,  K402,  KC_NO, K404,  KC_NO, K406,  KC_NO, K408,  K409,  K410,  K411 &#125;  \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>上面两行任然照抄，下面的<code>#define LAYOUT()</code>内容也是从下载的源码复制。</p><h3 id="键盘名-c"><a href="#键盘名-c" class="headerlink" title="键盘名.c"></a>键盘名.c</h3><p>只有一行，就是include一下上面的.h文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;amx55.h&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="keymaps文件夹"><a href="#keymaps文件夹" class="headerlink" title="keymaps文件夹"></a>keymaps文件夹</h3><p>存放的是默认按键配列，下面可以放很多个文件夹，名称是配列名。编译的时候可以通过<code>-km 配列名</code>选择编译的配列。最简单的版本只需要有一个default文件夹，文件夹下面只需要一个：<code>keymap.c</code>文件，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> QMK_KEYBOARD_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = &#123;</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>] = LAYOUT(</span><br><span class="line">KC_GRV, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_SPC, </span><br><span class="line">KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_BSLS, </span><br><span class="line">KC_CAPS, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_ENT, </span><br><span class="line">KC_LSFT, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_LSFT, KC_UP, KC_DEL, </span><br><span class="line">KC_LCTL, KC_LGUI, KC_LALT, KC_SPC, KC_SPC, MO(<span class="number">1</span>), KC_LEFT, KC_DOWN, KC_RGHT),</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>] = LAYOUT(</span><br><span class="line">KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_LBRC, KC_RBRC, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_SCLN, KC_QUOT, KC_TRNS, </span><br><span class="line">MO(<span class="number">2</span>), KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_COMM, KC_DOT, KC_SLSH, MO(<span class="number">2</span>), KC_TRNS, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">[<span class="number">2</span>] = LAYOUT(</span><br><span class="line">KC_ESC, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, RESET, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, </span><br><span class="line">KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一行的#include照抄，这个数组注意不能直接复制源码，和源码有所不同。</p><p>首先写好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = LAYOUT(),</span><br><span class="line">    ...</span><br><span class="line">    [n] = LAYOUT(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认配置有几层写几个LAYOUT就行，然后去下载的源码里边把LAYOUT复制过来。</p><h2 id="编译固件"><a href="#编译固件" class="headerlink" title="编译固件"></a>编译固件</h2><p><code>qmk compile -kb 键盘名\[rev_x] -km keymap名</code></p><p>编译成功以后刷入测试即可。</p><p>注意有的时候会有一个什么backslash报错，需要在报错的文件最后加一个空行即可…</p><h2 id="Vial配置"><a href="#Vial配置" class="headerlink" title="Vial配置"></a>Vial配置</h2><h3 id="via与vial介绍"><a href="#via与vial介绍" class="headerlink" title="via与vial介绍"></a>via与vial介绍</h3><p>via是客制化常用的改键方案了，老版的via需要下载软件、导入配置好的json文件。新版可以使用网页且不用导入json，但是暂时还不知道怎么写固件…</p><p>vial有网页和软件两个方式，都不需要导入json，写好固件以后连接即可识别，且不需要保存，即改即存，功能似乎也比via完善。和不需要json的via版本一致，最大的缺点是把json需要的信息量存入到了键盘mcu的flash中，导致固件大很多，flash不是很大的mcu（比如又贵又拉的32u4）可能有点吃不消。</p><h3 id="支持vial的qmk编译环境搭建"><a href="#支持vial的qmk编译环境搭建" class="headerlink" title="支持vial的qmk编译环境搭建"></a>支持vial的qmk编译环境搭建</h3><p>在qmk msys中输入命令：</p><p><code>qmk setup -H 分支目录 -b vial vial-kb/vial-qmk</code></p><p>分支目录是你vial版本qmk工程文件放置的目录，然后会开始git clone和setup，和最开始的qmk环境搭建基本一致</p><p>然后cd到分支目录中，这个目录和qmk默认的工程目录几乎是一样的，把之前的keyboards中的键盘文件夹复制到这边，继续修改即可</p><h3 id="支持vial的固件编写"><a href="#支持vial的固件编写" class="headerlink" title="支持vial的固件编写"></a>支持vial的固件编写</h3><p>在keymap中新建一个文件夹vial，把之前default中的keymap.c复制过去，然后还需要三个文件：</p><p>config.h、rules.mk、vial.json</p><p>下面介绍三个文件的配置</p><h4 id="rules-mk-1"><a href="#rules-mk-1" class="headerlink" title="rules.mk"></a>rules.mk</h4><p>只有两行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VIA_ENABLE = yes</span><br><span class="line">VIAL_ENABLE = yes</span><br></pre></td></tr></table></figure><h4 id="vial-json"><a href="#vial-json" class="headerlink" title="vial.json"></a>vial.json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lighting&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;matrix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cols&quot;</span><span class="punctuation">:</span> <span class="number">12</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;layouts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;keymap&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>lighting是灯光模式，方便在vial中设置灯光，我没有用灯，none</p><p>matrix中写入行列数</p><p>layouts中的keymap比较有趣，需要在常用的配列网站<a href="http://www.keyboard-layout-editor.com/#/">Keyboard Layout Editor</a>中，使用自己的配列，把每个键上面的字改为:<code>row,col</code>，表示这个键所在的行列：</p><p><img src="/images/QMK/image-20221024090736063.png" alt="image-20221024090736063"></p><p>然后再&lt;/&gt; Raw data中到处json，这个json的内容复制到keymap后面去就行。</p><h4 id="config-h-1"><a href="#config-h-1" class="headerlink" title="config.h"></a>config.h</h4><p>内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0-or-later */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIAL_KEYBOARD_UID &#123;0xDA, 0xDB, 0x70, 0x9F, 0xE7, 0x18, 0x63, 0x55&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIAL_UNLOCK_COMBO_ROWS &#123; 0, 2 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIAL_UNLOCK_COMBO_COLS &#123; 0, 11 &#125;</span></span><br></pre></td></tr></table></figure><p>第一行，按惯例，照抄</p><p>第二行，UID的配置，这个不能自己乱配，需要在工程目录下执行python脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python util/vial_generate_keyboard_uid.py</span><br></pre></td></tr></table></figure><p>执行完成后会显示一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VIAL_KEYBOARD_UID &#123;0xXX, 0xXX, 0xXX, 0xXX, 0xXX, 0xXX, 0xXX, 0xXX&#125;</span></span><br></pre></td></tr></table></figure><p>把生成的这个内容复制过去就行。</p><p>第三四行，定义了两个键的组合：</p><p>由于vial的权限比via高很多，可以执行一些危险操作，所以有的功能是被上锁的，执行这些功能之前，必须要按下两个固定的键解锁，这两行就是要设置这两个键。</p><p>这两行的坐标是竖着看的，上面这个代码的意思就是按下(0,0)、(2,11)两个键可以解锁vial的危险功能。</p><h3 id="支持vial的固件编译"><a href="#支持vial的固件编译" class="headerlink" title="支持vial的固件编译"></a>支持vial的固件编译</h3><p>仍然在vial分支的qmk工程目录下面执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qmk compile -kb 键盘名/[rev_x] -km vial</span><br></pre></td></tr></table></figure><p>生成以后，刷入固件，访问网站<a href="https://vial.rocks/">Vial Web</a>就可以在线改键。</p><h3 id="进阶：Vial旋钮固件自定义"><a href="#进阶：Vial旋钮固件自定义" class="headerlink" title="进阶：Vial旋钮固件自定义"></a>进阶：Vial旋钮固件自定义</h3><h4 id="开启QMK编码器映射功能"><a href="#开启QMK编码器映射功能" class="headerlink" title="开启QMK编码器映射功能"></a>开启QMK编码器映射功能</h4><p>QMK旋钮固件有两种编写方式：编码器映射（Mapping）、回调（Callback）。Vial的目前版本只支持映射方式。</p><p>首先需要在<code>rules.mk</code>中打开编码器映射：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENCODER_ENABLE = yes</span><br><span class="line">ENCODER_MAP_ENABLE = yes</span><br></pre></td></tr></table></figure><p>然后在<code>config.h</code>中配置旋钮引脚和解析度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Encoder Setting */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODERS_PAD_A &#123; A10 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODERS_PAD_B &#123; A8 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCODER_RESOLUTION 4</span></span><br></pre></td></tr></table></figure><p>再到<code>keymap.c</code>中支持开启编码器映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ENCODER_MAP_ENABLE)</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> PROGMEM encoder_map[][NUM_ENCODERS][<span class="number">2</span>] = &#123;</span><br><span class="line">    [_HOME] =   &#123; ENCODER_CCW_CW(KC_1, KC_2) &#125;,</span><br><span class="line">    [_FN2] =  &#123; ENCODER_CCW_CW(KC_VOLD, KC_VOLU) &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>映射支持多层多旋钮，这里以两层（HOME、FN2）一个旋钮为例。</p><p>到这里，就通过编码器映射方式启用了旋钮，功能应该是可以正常使用的。</p><h4 id="开启Vial对于旋钮改键支持"><a href="#开启Vial对于旋钮改键支持" class="headerlink" title="开启Vial对于旋钮改键支持"></a>开启Vial对于旋钮改键支持</h4><p>到配列编辑网站加入两个按键，代表旋钮的两个方向，按键内容如下：</p><p><img src="/images/QMK/image-20221112130821772.png" alt="image-20221112130821772"></p><p>然后按照前面教程所说的，把这个网站生成的json复制到vial.json-&gt;layouts-&gt;keymap即可</p><p>再次编译刷写，进入vial就可以看到了。</p><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><h3 id="手把手视频教学"><a href="#手把手视频教学" class="headerlink" title="手把手视频教学"></a>手把手视频教学</h3><p><strong>32u4主控PCB绘制，在线固件生成：</strong>B站/zf用户：丈二先生</p><p> <a href="https://www.bilibili.com/video/BV1ch411x7J2/?spm_id_from=333.788">【零基础】客制化键盘DIY系列教程（二）Keyboard Editor 编辑自己的配列~_哔哩哔哩_bilibili</a></p><p><strong>qmk本地代码修改、编译：</strong>B站用户：HiryKun</p><p><a href="https://www.bilibili.com/video/BV1pt4y1a7dG/?spm_id_from=333.880.my_history.page.click">【QMK教程】从配置编译环境到实现RBG矩阵灯效 OLED屏幕动画 旋钮编码器功能 VIA改键 ARM移植的详细大教学，看完就会写QMK固件_哔哩哔哩_bilibili</a></p><p><strong>vial固件编写：</strong>B站用户：HiryKun</p><p><a href="https://www.bilibili.com/video/BV1ft4y1t7vx/?spm_id_from=333.999.0.0">【QMK教程】Vial的支持与配置，让你的键盘方便改键/改编码器/改灯效，无需选择JSON，比VIA更方便_哔哩哔哩_bilibili</a></p><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><strong>qmk官方文档：</strong><a href="https://docs.qmk.fm/#/">QMK Firmware</a></p><p><strong>vial官方文档：</strong><a href="https://get.vial.today/">Home - Vial</a></p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo建站图片加载问题</title>
      <link href="/2022/10/03/hexo-picture-load-error/"/>
      <url>/2022/10/03/hexo-picture-load-error/</url>
      
        <content type="html"><![CDATA[<h2 id="试错方法"><a href="#试错方法" class="headerlink" title="试错方法"></a>试错方法</h2><p>网上有多种多样的方法，把试过但是没有用的几种主流方法写一下：</p><ul><li>安装hexo-asset-image插件，并在config中打开功能。在md文档同目录下建立同名文件夹放置图片即可。</li><li>修改hexo-asset-image插件代码中的bug，更改package.json。</li><li>修改各种存储路径，如：<ul><li>使用Blog文件夹为根目录</li><li>直接使用图片名</li><li>使用source文件夹作为根目录</li><li>使用./同名文件夹/xxx.jpg</li></ul></li></ul><p>最后一种方法种的有几种路径在本地是有效的，但是上传到Netlify托管以后就出问题了，最终还是翻阅了官方文档找到了最暴力的方法。</p><h2 id="最终方法"><a href="#最终方法" class="headerlink" title="最终方法"></a>最终方法</h2><p>直接在source文件夹下面创建一个image文件夹，用来存放图片，然后每次写一个博客就在下面建立一个同名文件夹用来存储图片。md文档中图片的引用格式为: ![](/image/同名文件夹/xxx.jpg)</p><p><strong>特别注意是/不是\ ！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LotLab固件编译教程</title>
      <link href="/2022/09/23/LotKB-firmware-build-env/"/>
      <url>/2022/09/23/LotKB-firmware-build-env/</url>
      
        <content type="html"><![CDATA[<p>之前在Win和Linux上尝试配置了好多次LotLab蓝牙键盘的固件编译环，每次都寄了，后来发现有Docker环境…</p><p>直接docker run lotlab/nrf52-keyboard即可</p><p>把你的项目文件夹（包含config.h，keymap_common.h等）放入容器的/work/keyboard目录即可，然后进入项目文件夹输入<code>make -j</code>即可，注意可用的蓝牙文件是nrf52_keyboard_with_sd.hex</p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>amx40新固件刷机教程</title>
      <link href="/2022/09/23/amx40-firmware-flashing/"/>
      <url>/2022/09/23/amx40-firmware-flashing/</url>
      
        <content type="html"><![CDATA[<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>固件蓝牙发射功率增加了4dBm，减少断连可能性（但是介于使用环境不同，不保证完全不断连）</p><h2 id="更新固件教程"><a href="#更新固件教程" class="headerlink" title="更新固件教程"></a>更新固件教程</h2><h3 id="下载群文件"><a href="#下载群文件" class="headerlink" title="下载群文件"></a>下载群文件</h3><p>下载群文件中的<strong>amx40刷机文件.zip</strong>，解压，有如下两个文件：</p><p><img src="/images/amx40firmware/image-20220923152342798.png" alt="image-20220923152342798"></p><p>其中<strong>烧录工具箱-1.2.2.0.7z</strong>中是烧录固件的工具，<strong>nrf52_kbd_with_sd.hex</strong>是新固件。</p><h3 id="安装烧录工具箱"><a href="#安装烧录工具箱" class="headerlink" title="安装烧录工具箱"></a>安装烧录工具箱</h3><p>解压<strong>烧录工具箱-1.2.2.0.7z</strong>，进入解压后的文件夹是这样的：</p><p><img src="/images/amx40firmware/image-20220923152530993.png" alt="image-20220923152530993"></p><p>首先点击<strong>首次使用点我安装驱动.EXE</strong>，进入这个界面：</p><p><img src="/images/amx40firmware/image-20220923152608293.png" alt="image-20220923152608293"></p><p>点击安装，过几秒出现：</p><p><img src="/images/amx40firmware/image-20220923152633738.png" alt="image-20220923152633738"></p><p>然后关掉窗口即可。</p><h3 id="刷写固件"><a href="#刷写固件" class="headerlink" title="刷写固件"></a>刷写固件</h3><p>点击烧录工具箱中的<strong>wch_nrf_burner.exe</strong></p><p><img src="/images/amx40firmware/image-20220923152727227.png" alt="image-20220923152727227"></p><p><strong>有线</strong>连接amx40键盘，在当前设备一行的最右边点击刷新（最右边那个小圈圈），过几秒钟后，就可以在当前设备中看到这两个了（点击最右边那个倒三角形）</p><p><img src="/images/amx40firmware/image-20220923152951204.png" alt="image-20220923152951204"></p><p>然后选择其中的一个（CMSIS-DAP和Lotlab Configurator都可）</p><p>再在蓝牙固件中，选择amx40刷机文件中的<strong>nrf52_kbd_with_sd.hex</strong></p><p><img src="/images/amx40firmware/image-20220923153250363.png" alt="image-20220923153250363"></p><p>USB固件和下面的两个选项都不要管，选择好设备和蓝牙固件以后直接点击<strong>烧录</strong></p><p>然后稍微等待几十秒，下面出现这一堆英文提示，左下角显示准备就绪以后就刷好了：</p><p><img src="/images/amx40firmware/image-20220923153426919.png" alt="image-20220923153426919"></p><p>然后断开USB，重新插入即可</p><h2 id="（特别注意）关于刷机以后键位的问题"><a href="#（特别注意）关于刷机以后键位的问题" class="headerlink" title="（特别注意）关于刷机以后键位的问题"></a>（特别注意）关于刷机以后键位的问题</h2><p>刷机以后<strong>键位有可能被重置</strong>了，导致出现一些问题，比如你原来设置的蓝牙设备连接键位被改变了。</p><p>参考<strong>群文件&gt;爱丽丝40&gt;AMX40_配置网页改建服务教程.pdf</strong>改成你习惯的键位。</p>]]></content>
      
      
      <categories>
          
          <category> 客制化键盘 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
